# Nextcloud ä¸šåŠ¡è§„åˆ™å®ç°æŒ‡å—

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäºNextcloudæºä»£ç åˆ†æå’Œä¸šåŠ¡è§„åˆ™è¯¦è§£ï¼Œæä¾›å…·ä½“çš„ä»£ç å®ç°ç¤ºä¾‹å’Œæœ€ä½³å®è·µï¼Œå¸®åŠ©å¼€å‘å›¢é˜Ÿå‡†ç¡®å®ç°å„é¡¹ä¸šåŠ¡åŠŸèƒ½ã€‚

## ğŸ—‚ï¸ 1. æ–‡ä»¶ç®¡ç†ä¸šåŠ¡è§„åˆ™å®ç°

### 1.1 æ–‡ä»¶ä¸Šä¼ æƒé™éªŒè¯å®ç°

#### 1.1.1 æƒé™æ£€æŸ¥ä»£ç ç¤ºä¾‹
```php
<?php
// lib/private/Files/View.php å®ç°å‚è€ƒ
class FileUploadValidator {
    
    /**
     * éªŒè¯æ–‡ä»¶ä¸Šä¼ æƒé™
     */
    public function validateUploadPermissions(string $path, IUser $user): bool {
        // 1. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰CREATEæƒé™
        if (!$this->hasCreatePermission($path, $user)) {
            throw new ForbiddenException('No create permission for path: ' . $path);
        }
        
        // 2. æ£€æŸ¥å­˜å‚¨é…é¢
        if (!$this->checkStorageQuota($user, $fileSize)) {
            throw new InsufficientStorageException('Storage quota exceeded');
        }
        
        // 3. éªŒè¯æ–‡ä»¶ååˆè§„æ€§
        if (!$this->validateFileName($fileName)) {
            throw new InvalidPathException('Invalid file name: ' . $fileName);
        }
        
        return true;
    }
    
    /**
     * æ£€æŸ¥CREATEæƒé™
     */
    private function hasCreatePermission(string $path, IUser $user): bool {
        $permissions = $this->getPermissions($path, $user);
        return ($permissions & Constants::PERMISSION_CREATE) !== 0;
    }
    
    /**
     * æ£€æŸ¥å­˜å‚¨é…é¢
     */
    private function checkStorageQuota(IUser $user, int $fileSize): bool {
        $quota = $this->getUserQuota($user);
        $usedSpace = $this->getUsedSpace($user);
        
        return ($quota === -1) || (($usedSpace + $fileSize) <= $quota);
    }
    
    /**
     * éªŒè¯æ–‡ä»¶å
     */
    private function validateFileName(string $fileName): bool {
        // æ£€æŸ¥æ–‡ä»¶åé•¿åº¦
        if (strlen($fileName) > 255) {
            return false;
        }
        
        // æ£€æŸ¥ç¦ç”¨å­—ç¬¦
        $forbiddenChars = ['/', '\\', ':', '*', '?', '"', '<', '>', '|'];
        foreach ($forbiddenChars as $char) {
            if (strpos($fileName, $char) !== false) {
                return false;
            }
        }
        
        // æ£€æŸ¥ç³»ç»Ÿä¿ç•™åç§°
        $reservedNames = ['CON', 'PRN', 'AUX', 'NUL', 'COM1', 'LPT1'];
        if (in_array(strtoupper($fileName), $reservedNames)) {
            return false;
        }
        
        return true;
    }
}
```

#### 1.1.2 æ–‡ä»¶å®‰å…¨æ£€æŸ¥å®ç°
```php
<?php
class FileSecurityChecker {
    
    /**
     * æ–‡ä»¶å®‰å…¨æ£€æŸ¥
     */
    public function performSecurityCheck(string $filePath, string $mimeType): bool {
        // 1. MIMEç±»å‹éªŒè¯
        if (!$this->validateMimeType($mimeType)) {
            throw new UnsupportedMediaTypeException('Unsupported file type: ' . $mimeType);
        }
        
        // 2. æ–‡ä»¶å¤§å°æ£€æŸ¥
        if (!$this->validateFileSize($filePath)) {
            throw new FileTooLargeException('File size exceeds limit');
        }
        
        // 3. ç—…æ¯’æ‰«æï¼ˆå¦‚æœå¯ç”¨ï¼‰
        if ($this->isVirusScanEnabled() && !$this->scanForVirus($filePath)) {
            throw new VirusDetectedException('Virus detected in file');
        }
        
        return true;
    }
    
    /**
     * MIMEç±»å‹ç™½åå•éªŒè¯
     */
    private function validateMimeType(string $mimeType): bool {
        $allowedTypes = $this->config->getSystemValue('allowed_mime_types', []);
        $blockedTypes = $this->config->getSystemValue('blocked_mime_types', [
            'application/x-executable',
            'application/x-msdownload',
            'application/x-msdos-program'
        ]);
        
        // æ£€æŸ¥é»‘åå•
        if (in_array($mimeType, $blockedTypes)) {
            return false;
        }
        
        // æ£€æŸ¥ç™½åå•ï¼ˆå¦‚æœé…ç½®äº†ï¼‰
        if (!empty($allowedTypes) && !in_array($mimeType, $allowedTypes)) {
            return false;
        }
        
        return true;
    }
    
    /**
     * æ–‡ä»¶å¤§å°éªŒè¯
     */
    private function validateFileSize(string $filePath): bool {
        $maxFileSize = $this->config->getSystemValue('max_file_size', 512 * 1024 * 1024); // 512MB
        $fileSize = filesize($filePath);
        
        return $fileSize <= $maxFileSize;
    }
}
```

### 1.2 æ–‡ä»¶ç‰ˆæœ¬æ§åˆ¶å®ç°

#### 1.2.1 ç‰ˆæœ¬åˆ›å»ºé€»è¾‘
```php
<?php
class FileVersionManager {
    
    /**
     * åˆ›å»ºæ–‡ä»¶ç‰ˆæœ¬
     */
    public function createVersion(File $file, IUser $user): ?IVersion {
        // 1. æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ›å»ºç‰ˆæœ¬
        if (!$this->shouldCreateVersion($file)) {
            return null;
        }
        
        // 2. æ£€æŸ¥ç‰ˆæœ¬åˆ›å»ºæƒé™
        if (!$this->hasVersionPermission($file, $user)) {
            throw new ForbiddenException('No permission to create version');
        }
        
        // 3. åˆ›å»ºç‰ˆæœ¬è®°å½•
        $version = $this->doCreateVersion($file, $user);
        
        // 4. è§¦å‘ç‰ˆæœ¬åˆ›å»ºäº‹ä»¶
        $this->eventDispatcher->dispatchTyped(new VersionCreatedEvent($file, $version));
        
        // 5. æ¸…ç†æ—§ç‰ˆæœ¬ï¼ˆå¦‚æœéœ€è¦ï¼‰
        $this->cleanupOldVersions($file);
        
        return $version;
    }
    
    /**
     * åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ›å»ºç‰ˆæœ¬
     */
    private function shouldCreateVersion(File $file): bool {
        $lastVersion = $this->getLatestVersion($file);
        
        // å¦‚æœæ²¡æœ‰ç‰ˆæœ¬ï¼Œåˆ›å»ºç¬¬ä¸€ä¸ªç‰ˆæœ¬
        if ($lastVersion === null) {
            return true;
        }
        
        // æ£€æŸ¥æ—¶é—´é—´éš”ï¼ˆæœ€å°5åˆ†é’Ÿï¼‰
        $minInterval = 5 * 60; // 5åˆ†é’Ÿ
        if ((time() - $lastVersion->getTimestamp()) < $minInterval) {
            return false;
        }
        
        // æ£€æŸ¥æ–‡ä»¶å¤§å°å˜åŒ–ï¼ˆè¶…è¿‡1%æ‰åˆ›å»ºç‰ˆæœ¬ï¼‰
        $sizeChangeThreshold = 0.01; // 1%
        $oldSize = $lastVersion->getSize();
        $newSize = $file->getSize();
        $sizeChange = abs($newSize - $oldSize) / max($oldSize, 1);
        
        return $sizeChange > $sizeChangeThreshold;
    }
    
    /**
     * ç‰ˆæœ¬æ¸…ç†ç­–ç•¥
     */
    private function cleanupOldVersions(File $file): void {
        $versions = $this->getAllVersions($file);
        $maxVersions = $this->config->getAppValue('files_versions', 'max_versions', 50);
        
        if (count($versions) <= $maxVersions) {
            return;
        }
        
        // æŒ‰æ—¶é—´æ’åºï¼Œä¿ç•™æœ€æ–°çš„ç‰ˆæœ¬
        usort($versions, function($a, $b) {
            return $b->getTimestamp() - $a->getTimestamp();
        });
        
        // åˆ é™¤è¶…å‡ºé™åˆ¶çš„ç‰ˆæœ¬
        $versionsToDelete = array_slice($versions, $maxVersions);
        foreach ($versionsToDelete as $version) {
            if (!$version->isImportant()) { // é‡è¦ç‰ˆæœ¬ä¸åˆ é™¤
                $this->deleteVersion($version);
            }
        }
    }
}
```

## ğŸ‘¥ 2. ç”¨æˆ·ç®¡ç†ä¸šåŠ¡è§„åˆ™å®ç°

### 2.1 ç”¨æˆ·è®¤è¯å®ç°

#### 2.1.1 å¤šé‡è®¤è¯æœºåˆ¶å®ç°
```php
<?php
class AuthenticationManager {
    
    /**
     * æ‰§è¡Œç”¨æˆ·è®¤è¯
     */
    public function authenticate(IRequest $request): ?IUser {
        // 1. Apacheè®¤è¯æ£€æŸ¥
        if ($user = $this->tryApacheAuth($request)) {
            return $user;
        }
        
        // 2. Tokenè®¤è¯æ£€æŸ¥
        if ($user = $this->tryTokenAuth($request)) {
            return $user;
        }
        
        // 3. Cookieè®¤è¯æ£€æŸ¥
        if ($user = $this->tryCookieAuth($request)) {
            return $user;
        }
        
        // 4. Basicè®¤è¯æ£€æŸ¥
        if ($user = $this->tryBasicAuth($request)) {
            return $user;
        }
        
        return null;
    }
    
    /**
     * Tokenè®¤è¯å®ç°
     */
    private function tryTokenAuth(IRequest $request): ?IUser {
        $authHeader = $request->getHeader('Authorization');
        
        if (!$authHeader || !str_starts_with($authHeader, 'Bearer ')) {
            return null;
        }
        
        $token = substr($authHeader, 7); // ç§»é™¤ "Bearer " å‰ç¼€
        
        try {
            $tokenObject = $this->tokenProvider->getToken($token);
            
            // æ£€æŸ¥Tokenæœ‰æ•ˆæ€§
            if ($this->isTokenExpired($tokenObject)) {
                throw new InvalidTokenException('Token expired');
            }
            
            // æ£€æŸ¥Tokenæƒé™èŒƒå›´
            if (!$this->hasRequiredScope($tokenObject, $request)) {
                throw new InsufficientScopeException('Insufficient token scope');
            }
            
            // æ›´æ–°Tokenæœ€åä½¿ç”¨æ—¶é—´
            $this->tokenProvider->updateTokenActivity($tokenObject);
            
            return $this->userManager->get($tokenObject->getUID());
            
        } catch (InvalidTokenException $e) {
            $this->logger->warning('Invalid token used', ['token' => substr($token, 0, 8) . '...']);
            return null;
        }
    }
    
    /**
     * å¯†ç éªŒè¯å®ç°
     */
    public function validatePassword(string $uid, string $password): bool {
        // 1. æ£€æŸ¥æš´åŠ›ç ´è§£ä¿æŠ¤
        if ($this->isBruteForceProtected($uid)) {
            throw new TooManyRequestsException('Too many failed login attempts');
        }
        
        // 2. éå†ç”¨æˆ·åç«¯è¿›è¡ŒéªŒè¯
        foreach ($this->userBackends as $backend) {
            if ($backend->checkPassword($uid, $password)) {
                // éªŒè¯æˆåŠŸï¼Œé‡ç½®å¤±è´¥è®¡æ•°
                $this->resetFailedAttempts($uid);
                return true;
            }
        }
        
        // 3. éªŒè¯å¤±è´¥ï¼Œè®°å½•å¤±è´¥å°è¯•
        $this->recordFailedAttempt($uid);
        return false;
    }
    
    /**
     * æš´åŠ›ç ´è§£ä¿æŠ¤
     */
    private function isBruteForceProtected(string $uid): bool {
        $attempts = $this->getFailedAttempts($uid);
        $maxAttempts = $this->config->getSystemValue('auth.bruteforce.max_attempts', 5);
        $lockoutTime = $this->config->getSystemValue('auth.bruteforce.lockout_time', 300); // 5åˆ†é’Ÿ
        
        if ($attempts['count'] >= $maxAttempts) {
            $timeSinceLastAttempt = time() - $attempts['last_attempt'];
            return $timeSinceLastAttempt < $lockoutTime;
        }
        
        return false;
    }
}
```

### 2.2 æƒé™æ§åˆ¶å®ç°

#### 2.2.1 æƒé™è®¡ç®—é€»è¾‘
```php
<?php
class PermissionManager {
    
    /**
     * è®¡ç®—ç”¨æˆ·å¯¹æ–‡ä»¶çš„æœ‰æ•ˆæƒé™
     */
    public function calculatePermissions(File $file, IUser $user): int {
        // 1. è·å–åŸºç¡€æƒé™
        $basePermissions = $this->getBasePermissions($file, $user);
        
        // 2. è·å–å…±äº«æƒé™
        $sharePermissions = $this->getSharePermissions($file, $user);
        
        // 3. è·å–ç»„æƒé™
        $groupPermissions = $this->getGroupPermissions($file, $user);
        
        // 4. è®¡ç®—æœ€ç»ˆæƒé™ï¼ˆå–äº¤é›†ï¼‰
        $finalPermissions = $basePermissions & $sharePermissions & $groupPermissions;
        
        // 5. åº”ç”¨ç‰¹æ®Šè§„åˆ™
        $finalPermissions = $this->applySpecialRules($file, $user, $finalPermissions);
        
        return $finalPermissions;
    }
    
    /**
     * è·å–å…±äº«æƒé™
     */
    private function getSharePermissions(File $file, IUser $user): int {
        $shares = $this->shareManager->getSharesBy($user->getUID(), IShare::TYPE_USER, $file);
        
        if (empty($shares)) {
            return Constants::PERMISSION_ALL; // æ²¡æœ‰å…±äº«é™åˆ¶
        }
        
        $permissions = 0;
        foreach ($shares as $share) {
            $permissions |= $share->getPermissions();
        }
        
        return $permissions;
    }
    
    /**
     * åº”ç”¨ç‰¹æ®Šæƒé™è§„åˆ™
     */
    private function applySpecialRules(File $file, IUser $user, int $permissions): int {
        // 1. æ–‡ä»¶æ‰€æœ‰è€…å§‹ç»ˆæœ‰å®Œå…¨æƒé™
        if ($file->getOwner()->getUID() === $user->getUID()) {
            return Constants::PERMISSION_ALL;
        }
        
        // 2. ç®¡ç†å‘˜æƒé™æ£€æŸ¥
        if ($this->groupManager->isAdmin($user->getUID())) {
            $adminCanAccess = $this->config->getSystemValue('admin_can_access_all_files', false);
            if ($adminCanAccess) {
                return Constants::PERMISSION_ALL;
            }
        }
        
        // 3. åªè¯»æ–‡ä»¶ç³»ç»Ÿæ£€æŸ¥
        if ($this->isReadOnlyStorage($file)) {
            $permissions &= ~(Constants::PERMISSION_UPDATE | Constants::PERMISSION_DELETE | Constants::PERMISSION_CREATE);
        }
        
        // 4. æ–‡ä»¶é”å®šæ£€æŸ¥
        if ($this->isFileLocked($file)) {
            $permissions &= ~(Constants::PERMISSION_UPDATE | Constants::PERMISSION_DELETE);
        }
        
        return $permissions;
    }
    
    /**
     * æƒé™æ£€æŸ¥ä¸­é—´ä»¶
     */
    public function checkPermission(File $file, IUser $user, int $requiredPermission): bool {
        $userPermissions = $this->calculatePermissions($file, $user);
        
        // æ£€æŸ¥æ˜¯å¦å…·æœ‰æ‰€éœ€æƒé™
        $hasPermission = ($userPermissions & $requiredPermission) === $requiredPermission;
        
        // è®°å½•æƒé™æ£€æŸ¥æ—¥å¿—
        $this->auditLogger->logPermissionCheck($user, $file, $requiredPermission, $hasPermission);
        
        return $hasPermission;
    }
}
```

## ğŸ¤ 3. åä½œå…±äº«ä¸šåŠ¡è§„åˆ™å®ç°

### 3.1 æ–‡ä»¶å…±äº«å®ç°

#### 3.1.1 å…±äº«åˆ›å»ºé€»è¾‘
```php
<?php
class ShareCreationManager {
    
    /**
     * åˆ›å»ºæ–‡ä»¶å…±äº«
     */
    public function createShare(IShare $share): IShare {
        // 1. å‰ç½®éªŒè¯
        $this->validateShareCreation($share);
        
        // 2. æƒé™è®¡ç®—å’ŒéªŒè¯
        $this->validateSharePermissions($share);
        
        // 3. è·¯å¾„æ£€æŸ¥
        $this->validateSharePath($share);
        
        // 4. åˆ›å»ºå…±äº«è®°å½•
        $createdShare = $this->doCreateShare($share);
        
        // 5. å‘é€é€šçŸ¥
        $this->sendShareNotification($createdShare);
        
        // 6. è§¦å‘äº‹ä»¶
        $this->eventDispatcher->dispatchTyped(new ShareCreatedEvent($createdShare));
        
        return $createdShare;
    }
    
    /**
     * éªŒè¯å…±äº«åˆ›å»ºæƒé™
     */
    private function validateShareCreation(IShare $share): void {
        // 1. æ£€æŸ¥ç³»ç»Ÿå…±äº«åŠŸèƒ½æ˜¯å¦å¯ç”¨
        if (!$this->config->getAppValue('core', 'shareapi_enabled', 'yes') === 'yes') {
            throw new ShareNotAllowedException('Sharing is disabled');
        }
        
        // 2. æ£€æŸ¥ç”¨æˆ·å…±äº«æƒé™
        $sharedBy = $share->getSharedBy();
        if ($this->isUserSharingDisabled($sharedBy)) {
            throw new ShareNotAllowedException('Sharing is disabled for user: ' . $sharedBy);
        }
        
        // 3. æ£€æŸ¥å…±äº«ç±»å‹æ˜¯å¦å…è®¸
        $shareType = $share->getShareType();
        if (!$this->isShareTypeAllowed($shareType)) {
            throw new ShareNotAllowedException('Share type not allowed: ' . $shareType);
        }
    }
    
    /**
     * éªŒè¯å…±äº«æƒé™
     */
    private function validateSharePermissions(IShare $share): void {
        $node = $share->getNode();
        $sharedBy = $share->getSharedBy();
        $requestedPermissions = $share->getPermissions();
        
        // è·å–ç”¨æˆ·å¯¹æ–‡ä»¶çš„æƒé™
        $userPermissions = $this->permissionManager->calculatePermissions($node, $sharedBy);
        
        // æ£€æŸ¥æ˜¯å¦æœ‰SHAREæƒé™
        if (($userPermissions & Constants::PERMISSION_SHARE) === 0) {
            throw new ShareNotAllowedException('No share permission for file');
        }
        
        // æ£€æŸ¥è¯·æ±‚çš„æƒé™æ˜¯å¦è¶…è¿‡ç”¨æˆ·æ‹¥æœ‰çš„æƒé™
        if (($requestedPermissions & ~$userPermissions) !== 0) {
            throw new ShareNotAllowedException('Cannot share with more permissions than owned');
        }
        
        // è®¾ç½®éªŒè¯åçš„æƒé™
        $share->setPermissions($requestedPermissions & $userPermissions);
    }
    
    /**
     * éªŒè¯å…±äº«è·¯å¾„
     */
    private function validateSharePath(IShare $share): void {
        $node = $share->getNode();
        
        // 1. æ£€æŸ¥æ˜¯å¦å…±äº«åŒ…å«å…¶ä»–å…±äº«çš„çˆ¶æ–‡ä»¶å¤¹
        if ($node instanceof Folder) {
            $mounts = $this->mountManager->findIn($node->getPath());
            foreach ($mounts as $mount) {
                if ($mount->getStorage()->instanceOfStorage(ISharedStorage::class)) {
                    throw new ShareNotAllowedException('Cannot share folder containing other shares');
                }
            }
        }
        
        // 2. æ£€æŸ¥å¾ªç¯å…±äº«
        if ($this->wouldCreateCircularShare($share)) {
            throw new ShareNotAllowedException('Would create circular share');
        }
        
        // 3. æ£€æŸ¥è·¯å¾„è®¿é—®æƒé™
        if (!$this->hasPathAccess($node, $share->getSharedBy())) {
            throw new ShareNotAllowedException('No access to shared path');
        }
    }
}
```

#### 3.1.2 å…±äº«æƒé™ç»§æ‰¿å®ç°
```php
<?php
class SharePermissionInheritance {
    
    /**
     * è®¡ç®—ç»§æ‰¿æƒé™
     */
    public function calculateInheritedPermissions(Node $node, IUser $user): int {
        $permissions = Constants::PERMISSION_ALL;
        $currentNode = $node;
        
        // å‘ä¸Šéå†ç›®å½•æ ‘ï¼Œè®¡ç®—ç»§æ‰¿æƒé™
        while ($currentNode !== null) {
            $nodePermissions = $this->getNodePermissions($currentNode, $user);
            $permissions &= $nodePermissions;
            
            // å¦‚æœåˆ°è¾¾æ ¹ç›®å½•æˆ–æŒ‚è½½ç‚¹ï¼Œåœæ­¢éå†
            if ($this->isRootOrMountPoint($currentNode)) {
                break;
            }
            
            $currentNode = $currentNode->getParent();
        }
        
        return $permissions;
    }
    
    /**
     * è·å–èŠ‚ç‚¹æƒé™
     */
    private function getNodePermissions(Node $node, IUser $user): int {
        // 1. è·å–ç›´æ¥æƒé™
        $directPermissions = $this->getDirectPermissions($node, $user);
        
        // 2. è·å–å…±äº«æƒé™
        $sharePermissions = $this->getSharePermissions($node, $user);
        
        // 3. è·å–ACLæƒé™
        $aclPermissions = $this->getAclPermissions($node, $user);
        
        // 4. è®¡ç®—æœ€ç»ˆæƒé™ï¼ˆå–äº¤é›†ï¼‰
        return $directPermissions & $sharePermissions & $aclPermissions;
    }
    
    /**
     * æƒé™å˜æ›´ä¼ æ’­
     */
    public function propagatePermissionChange(Node $node, int $oldPermissions, int $newPermissions): void {
        // 1. è®¡ç®—æƒé™å˜åŒ–
        $addedPermissions = $newPermissions & ~$oldPermissions;
        $removedPermissions = $oldPermissions & ~$newPermissions;
        
        // 2. å‘ä¸‹ä¼ æ’­æƒé™å˜æ›´
        if ($node instanceof Folder) {
            $this->propagateToChildren($node, $addedPermissions, $removedPermissions);
        }
        
        // 3. æ›´æ–°ç›¸å…³å…±äº«
        $this->updateRelatedShares($node, $newPermissions);
        
        // 4. è§¦å‘æƒé™å˜æ›´äº‹ä»¶
        $this->eventDispatcher->dispatchTyped(
            new PermissionChangedEvent($node, $oldPermissions, $newPermissions)
        );
    }
    
    /**
     * å‘å­èŠ‚ç‚¹ä¼ æ’­æƒé™
     */
    private function propagateToChildren(Folder $folder, int $addedPermissions, int $removedPermissions): void {
        $children = $folder->getDirectoryListing();
        
        foreach ($children as $child) {
            $currentPermissions = $this->getNodePermissions($child, $this->currentUser);
            
            // æ·»åŠ æ–°æƒé™
            $newPermissions = $currentPermissions | $addedPermissions;
            
            // ç§»é™¤æƒé™
            $newPermissions = $newPermissions & ~$removedPermissions;
            
            // é€’å½’å¤„ç†å­æ–‡ä»¶å¤¹
            if ($child instanceof Folder) {
                $this->propagateToChildren($child, $addedPermissions, $removedPermissions);
            }
            
            // æ›´æ–°æƒé™
            $this->updateNodePermissions($child, $newPermissions);
        }
    }
}
```

---

*æœ¬å®ç°æŒ‡å—æä¾›äº†Nextcloudæ ¸å¿ƒä¸šåŠ¡è§„åˆ™çš„å…·ä½“ä»£ç å®ç°ç¤ºä¾‹ï¼Œå¸®åŠ©å¼€å‘å›¢é˜Ÿç†è§£å’Œå®ç°å¤æ‚çš„ä¸šåŠ¡é€»è¾‘ã€‚*
