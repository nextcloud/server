# Nextcloud 业务规则实现指南

## 📋 文档概述

本文档基于Nextcloud源代码分析和业务规则详解，提供具体的代码实现示例和最佳实践，帮助开发团队准确实现各项业务功能。

## 🗂️ 1. 文件管理业务规则实现

### 1.1 文件上传权限验证实现

#### 1.1.1 权限检查代码示例
```php
<?php
// lib/private/Files/View.php 实现参考
class FileUploadValidator {
    
    /**
     * 验证文件上传权限
     */
    public function validateUploadPermissions(string $path, IUser $user): bool {
        // 1. 检查用户是否有CREATE权限
        if (!$this->hasCreatePermission($path, $user)) {
            throw new ForbiddenException('No create permission for path: ' . $path);
        }
        
        // 2. 检查存储配额
        if (!$this->checkStorageQuota($user, $fileSize)) {
            throw new InsufficientStorageException('Storage quota exceeded');
        }
        
        // 3. 验证文件名合规性
        if (!$this->validateFileName($fileName)) {
            throw new InvalidPathException('Invalid file name: ' . $fileName);
        }
        
        return true;
    }
    
    /**
     * 检查CREATE权限
     */
    private function hasCreatePermission(string $path, IUser $user): bool {
        $permissions = $this->getPermissions($path, $user);
        return ($permissions & Constants::PERMISSION_CREATE) !== 0;
    }
    
    /**
     * 检查存储配额
     */
    private function checkStorageQuota(IUser $user, int $fileSize): bool {
        $quota = $this->getUserQuota($user);
        $usedSpace = $this->getUsedSpace($user);
        
        return ($quota === -1) || (($usedSpace + $fileSize) <= $quota);
    }
    
    /**
     * 验证文件名
     */
    private function validateFileName(string $fileName): bool {
        // 检查文件名长度
        if (strlen($fileName) > 255) {
            return false;
        }
        
        // 检查禁用字符
        $forbiddenChars = ['/', '\\', ':', '*', '?', '"', '<', '>', '|'];
        foreach ($forbiddenChars as $char) {
            if (strpos($fileName, $char) !== false) {
                return false;
            }
        }
        
        // 检查系统保留名称
        $reservedNames = ['CON', 'PRN', 'AUX', 'NUL', 'COM1', 'LPT1'];
        if (in_array(strtoupper($fileName), $reservedNames)) {
            return false;
        }
        
        return true;
    }
}
```

#### 1.1.2 文件安全检查实现
```php
<?php
class FileSecurityChecker {
    
    /**
     * 文件安全检查
     */
    public function performSecurityCheck(string $filePath, string $mimeType): bool {
        // 1. MIME类型验证
        if (!$this->validateMimeType($mimeType)) {
            throw new UnsupportedMediaTypeException('Unsupported file type: ' . $mimeType);
        }
        
        // 2. 文件大小检查
        if (!$this->validateFileSize($filePath)) {
            throw new FileTooLargeException('File size exceeds limit');
        }
        
        // 3. 病毒扫描（如果启用）
        if ($this->isVirusScanEnabled() && !$this->scanForVirus($filePath)) {
            throw new VirusDetectedException('Virus detected in file');
        }
        
        return true;
    }
    
    /**
     * MIME类型白名单验证
     */
    private function validateMimeType(string $mimeType): bool {
        $allowedTypes = $this->config->getSystemValue('allowed_mime_types', []);
        $blockedTypes = $this->config->getSystemValue('blocked_mime_types', [
            'application/x-executable',
            'application/x-msdownload',
            'application/x-msdos-program'
        ]);
        
        // 检查黑名单
        if (in_array($mimeType, $blockedTypes)) {
            return false;
        }
        
        // 检查白名单（如果配置了）
        if (!empty($allowedTypes) && !in_array($mimeType, $allowedTypes)) {
            return false;
        }
        
        return true;
    }
    
    /**
     * 文件大小验证
     */
    private function validateFileSize(string $filePath): bool {
        $maxFileSize = $this->config->getSystemValue('max_file_size', 512 * 1024 * 1024); // 512MB
        $fileSize = filesize($filePath);
        
        return $fileSize <= $maxFileSize;
    }
}
```

### 1.2 文件版本控制实现

#### 1.2.1 版本创建逻辑
```php
<?php
class FileVersionManager {
    
    /**
     * 创建文件版本
     */
    public function createVersion(File $file, IUser $user): ?IVersion {
        // 1. 检查是否需要创建版本
        if (!$this->shouldCreateVersion($file)) {
            return null;
        }
        
        // 2. 检查版本创建权限
        if (!$this->hasVersionPermission($file, $user)) {
            throw new ForbiddenException('No permission to create version');
        }
        
        // 3. 创建版本记录
        $version = $this->doCreateVersion($file, $user);
        
        // 4. 触发版本创建事件
        $this->eventDispatcher->dispatchTyped(new VersionCreatedEvent($file, $version));
        
        // 5. 清理旧版本（如果需要）
        $this->cleanupOldVersions($file);
        
        return $version;
    }
    
    /**
     * 判断是否需要创建版本
     */
    private function shouldCreateVersion(File $file): bool {
        $lastVersion = $this->getLatestVersion($file);
        
        // 如果没有版本，创建第一个版本
        if ($lastVersion === null) {
            return true;
        }
        
        // 检查时间间隔（最小5分钟）
        $minInterval = 5 * 60; // 5分钟
        if ((time() - $lastVersion->getTimestamp()) < $minInterval) {
            return false;
        }
        
        // 检查文件大小变化（超过1%才创建版本）
        $sizeChangeThreshold = 0.01; // 1%
        $oldSize = $lastVersion->getSize();
        $newSize = $file->getSize();
        $sizeChange = abs($newSize - $oldSize) / max($oldSize, 1);
        
        return $sizeChange > $sizeChangeThreshold;
    }
    
    /**
     * 版本清理策略
     */
    private function cleanupOldVersions(File $file): void {
        $versions = $this->getAllVersions($file);
        $maxVersions = $this->config->getAppValue('files_versions', 'max_versions', 50);
        
        if (count($versions) <= $maxVersions) {
            return;
        }
        
        // 按时间排序，保留最新的版本
        usort($versions, function($a, $b) {
            return $b->getTimestamp() - $a->getTimestamp();
        });
        
        // 删除超出限制的版本
        $versionsToDelete = array_slice($versions, $maxVersions);
        foreach ($versionsToDelete as $version) {
            if (!$version->isImportant()) { // 重要版本不删除
                $this->deleteVersion($version);
            }
        }
    }
}
```

## 👥 2. 用户管理业务规则实现

### 2.1 用户认证实现

#### 2.1.1 多重认证机制实现
```php
<?php
class AuthenticationManager {
    
    /**
     * 执行用户认证
     */
    public function authenticate(IRequest $request): ?IUser {
        // 1. Apache认证检查
        if ($user = $this->tryApacheAuth($request)) {
            return $user;
        }
        
        // 2. Token认证检查
        if ($user = $this->tryTokenAuth($request)) {
            return $user;
        }
        
        // 3. Cookie认证检查
        if ($user = $this->tryCookieAuth($request)) {
            return $user;
        }
        
        // 4. Basic认证检查
        if ($user = $this->tryBasicAuth($request)) {
            return $user;
        }
        
        return null;
    }
    
    /**
     * Token认证实现
     */
    private function tryTokenAuth(IRequest $request): ?IUser {
        $authHeader = $request->getHeader('Authorization');
        
        if (!$authHeader || !str_starts_with($authHeader, 'Bearer ')) {
            return null;
        }
        
        $token = substr($authHeader, 7); // 移除 "Bearer " 前缀
        
        try {
            $tokenObject = $this->tokenProvider->getToken($token);
            
            // 检查Token有效性
            if ($this->isTokenExpired($tokenObject)) {
                throw new InvalidTokenException('Token expired');
            }
            
            // 检查Token权限范围
            if (!$this->hasRequiredScope($tokenObject, $request)) {
                throw new InsufficientScopeException('Insufficient token scope');
            }
            
            // 更新Token最后使用时间
            $this->tokenProvider->updateTokenActivity($tokenObject);
            
            return $this->userManager->get($tokenObject->getUID());
            
        } catch (InvalidTokenException $e) {
            $this->logger->warning('Invalid token used', ['token' => substr($token, 0, 8) . '...']);
            return null;
        }
    }
    
    /**
     * 密码验证实现
     */
    public function validatePassword(string $uid, string $password): bool {
        // 1. 检查暴力破解保护
        if ($this->isBruteForceProtected($uid)) {
            throw new TooManyRequestsException('Too many failed login attempts');
        }
        
        // 2. 遍历用户后端进行验证
        foreach ($this->userBackends as $backend) {
            if ($backend->checkPassword($uid, $password)) {
                // 验证成功，重置失败计数
                $this->resetFailedAttempts($uid);
                return true;
            }
        }
        
        // 3. 验证失败，记录失败尝试
        $this->recordFailedAttempt($uid);
        return false;
    }
    
    /**
     * 暴力破解保护
     */
    private function isBruteForceProtected(string $uid): bool {
        $attempts = $this->getFailedAttempts($uid);
        $maxAttempts = $this->config->getSystemValue('auth.bruteforce.max_attempts', 5);
        $lockoutTime = $this->config->getSystemValue('auth.bruteforce.lockout_time', 300); // 5分钟
        
        if ($attempts['count'] >= $maxAttempts) {
            $timeSinceLastAttempt = time() - $attempts['last_attempt'];
            return $timeSinceLastAttempt < $lockoutTime;
        }
        
        return false;
    }
}
```

### 2.2 权限控制实现

#### 2.2.1 权限计算逻辑
```php
<?php
class PermissionManager {
    
    /**
     * 计算用户对文件的有效权限
     */
    public function calculatePermissions(File $file, IUser $user): int {
        // 1. 获取基础权限
        $basePermissions = $this->getBasePermissions($file, $user);
        
        // 2. 获取共享权限
        $sharePermissions = $this->getSharePermissions($file, $user);
        
        // 3. 获取组权限
        $groupPermissions = $this->getGroupPermissions($file, $user);
        
        // 4. 计算最终权限（取交集）
        $finalPermissions = $basePermissions & $sharePermissions & $groupPermissions;
        
        // 5. 应用特殊规则
        $finalPermissions = $this->applySpecialRules($file, $user, $finalPermissions);
        
        return $finalPermissions;
    }
    
    /**
     * 获取共享权限
     */
    private function getSharePermissions(File $file, IUser $user): int {
        $shares = $this->shareManager->getSharesBy($user->getUID(), IShare::TYPE_USER, $file);
        
        if (empty($shares)) {
            return Constants::PERMISSION_ALL; // 没有共享限制
        }
        
        $permissions = 0;
        foreach ($shares as $share) {
            $permissions |= $share->getPermissions();
        }
        
        return $permissions;
    }
    
    /**
     * 应用特殊权限规则
     */
    private function applySpecialRules(File $file, IUser $user, int $permissions): int {
        // 1. 文件所有者始终有完全权限
        if ($file->getOwner()->getUID() === $user->getUID()) {
            return Constants::PERMISSION_ALL;
        }
        
        // 2. 管理员权限检查
        if ($this->groupManager->isAdmin($user->getUID())) {
            $adminCanAccess = $this->config->getSystemValue('admin_can_access_all_files', false);
            if ($adminCanAccess) {
                return Constants::PERMISSION_ALL;
            }
        }
        
        // 3. 只读文件系统检查
        if ($this->isReadOnlyStorage($file)) {
            $permissions &= ~(Constants::PERMISSION_UPDATE | Constants::PERMISSION_DELETE | Constants::PERMISSION_CREATE);
        }
        
        // 4. 文件锁定检查
        if ($this->isFileLocked($file)) {
            $permissions &= ~(Constants::PERMISSION_UPDATE | Constants::PERMISSION_DELETE);
        }
        
        return $permissions;
    }
    
    /**
     * 权限检查中间件
     */
    public function checkPermission(File $file, IUser $user, int $requiredPermission): bool {
        $userPermissions = $this->calculatePermissions($file, $user);
        
        // 检查是否具有所需权限
        $hasPermission = ($userPermissions & $requiredPermission) === $requiredPermission;
        
        // 记录权限检查日志
        $this->auditLogger->logPermissionCheck($user, $file, $requiredPermission, $hasPermission);
        
        return $hasPermission;
    }
}
```

## 🤝 3. 协作共享业务规则实现

### 3.1 文件共享实现

#### 3.1.1 共享创建逻辑
```php
<?php
class ShareCreationManager {
    
    /**
     * 创建文件共享
     */
    public function createShare(IShare $share): IShare {
        // 1. 前置验证
        $this->validateShareCreation($share);
        
        // 2. 权限计算和验证
        $this->validateSharePermissions($share);
        
        // 3. 路径检查
        $this->validateSharePath($share);
        
        // 4. 创建共享记录
        $createdShare = $this->doCreateShare($share);
        
        // 5. 发送通知
        $this->sendShareNotification($createdShare);
        
        // 6. 触发事件
        $this->eventDispatcher->dispatchTyped(new ShareCreatedEvent($createdShare));
        
        return $createdShare;
    }
    
    /**
     * 验证共享创建权限
     */
    private function validateShareCreation(IShare $share): void {
        // 1. 检查系统共享功能是否启用
        if (!$this->config->getAppValue('core', 'shareapi_enabled', 'yes') === 'yes') {
            throw new ShareNotAllowedException('Sharing is disabled');
        }
        
        // 2. 检查用户共享权限
        $sharedBy = $share->getSharedBy();
        if ($this->isUserSharingDisabled($sharedBy)) {
            throw new ShareNotAllowedException('Sharing is disabled for user: ' . $sharedBy);
        }
        
        // 3. 检查共享类型是否允许
        $shareType = $share->getShareType();
        if (!$this->isShareTypeAllowed($shareType)) {
            throw new ShareNotAllowedException('Share type not allowed: ' . $shareType);
        }
    }
    
    /**
     * 验证共享权限
     */
    private function validateSharePermissions(IShare $share): void {
        $node = $share->getNode();
        $sharedBy = $share->getSharedBy();
        $requestedPermissions = $share->getPermissions();
        
        // 获取用户对文件的权限
        $userPermissions = $this->permissionManager->calculatePermissions($node, $sharedBy);
        
        // 检查是否有SHARE权限
        if (($userPermissions & Constants::PERMISSION_SHARE) === 0) {
            throw new ShareNotAllowedException('No share permission for file');
        }
        
        // 检查请求的权限是否超过用户拥有的权限
        if (($requestedPermissions & ~$userPermissions) !== 0) {
            throw new ShareNotAllowedException('Cannot share with more permissions than owned');
        }
        
        // 设置验证后的权限
        $share->setPermissions($requestedPermissions & $userPermissions);
    }
    
    /**
     * 验证共享路径
     */
    private function validateSharePath(IShare $share): void {
        $node = $share->getNode();
        
        // 1. 检查是否共享包含其他共享的父文件夹
        if ($node instanceof Folder) {
            $mounts = $this->mountManager->findIn($node->getPath());
            foreach ($mounts as $mount) {
                if ($mount->getStorage()->instanceOfStorage(ISharedStorage::class)) {
                    throw new ShareNotAllowedException('Cannot share folder containing other shares');
                }
            }
        }
        
        // 2. 检查循环共享
        if ($this->wouldCreateCircularShare($share)) {
            throw new ShareNotAllowedException('Would create circular share');
        }
        
        // 3. 检查路径访问权限
        if (!$this->hasPathAccess($node, $share->getSharedBy())) {
            throw new ShareNotAllowedException('No access to shared path');
        }
    }
}
```

#### 3.1.2 共享权限继承实现
```php
<?php
class SharePermissionInheritance {
    
    /**
     * 计算继承权限
     */
    public function calculateInheritedPermissions(Node $node, IUser $user): int {
        $permissions = Constants::PERMISSION_ALL;
        $currentNode = $node;
        
        // 向上遍历目录树，计算继承权限
        while ($currentNode !== null) {
            $nodePermissions = $this->getNodePermissions($currentNode, $user);
            $permissions &= $nodePermissions;
            
            // 如果到达根目录或挂载点，停止遍历
            if ($this->isRootOrMountPoint($currentNode)) {
                break;
            }
            
            $currentNode = $currentNode->getParent();
        }
        
        return $permissions;
    }
    
    /**
     * 获取节点权限
     */
    private function getNodePermissions(Node $node, IUser $user): int {
        // 1. 获取直接权限
        $directPermissions = $this->getDirectPermissions($node, $user);
        
        // 2. 获取共享权限
        $sharePermissions = $this->getSharePermissions($node, $user);
        
        // 3. 获取ACL权限
        $aclPermissions = $this->getAclPermissions($node, $user);
        
        // 4. 计算最终权限（取交集）
        return $directPermissions & $sharePermissions & $aclPermissions;
    }
    
    /**
     * 权限变更传播
     */
    public function propagatePermissionChange(Node $node, int $oldPermissions, int $newPermissions): void {
        // 1. 计算权限变化
        $addedPermissions = $newPermissions & ~$oldPermissions;
        $removedPermissions = $oldPermissions & ~$newPermissions;
        
        // 2. 向下传播权限变更
        if ($node instanceof Folder) {
            $this->propagateToChildren($node, $addedPermissions, $removedPermissions);
        }
        
        // 3. 更新相关共享
        $this->updateRelatedShares($node, $newPermissions);
        
        // 4. 触发权限变更事件
        $this->eventDispatcher->dispatchTyped(
            new PermissionChangedEvent($node, $oldPermissions, $newPermissions)
        );
    }
    
    /**
     * 向子节点传播权限
     */
    private function propagateToChildren(Folder $folder, int $addedPermissions, int $removedPermissions): void {
        $children = $folder->getDirectoryListing();
        
        foreach ($children as $child) {
            $currentPermissions = $this->getNodePermissions($child, $this->currentUser);
            
            // 添加新权限
            $newPermissions = $currentPermissions | $addedPermissions;
            
            // 移除权限
            $newPermissions = $newPermissions & ~$removedPermissions;
            
            // 递归处理子文件夹
            if ($child instanceof Folder) {
                $this->propagateToChildren($child, $addedPermissions, $removedPermissions);
            }
            
            // 更新权限
            $this->updateNodePermissions($child, $newPermissions);
        }
    }
}
```

---

*本实现指南提供了Nextcloud核心业务规则的具体代码实现示例，帮助开发团队理解和实现复杂的业务逻辑。*
