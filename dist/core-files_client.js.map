{"version":3,"file":"core-files_client.js?v=8fc762a5eff1a69affdf","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACr1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClDA;;;;;AEAA;AACA;AACA;AACA;AACA","sources":["webpack:///nextcloud/core/src/files/client.js","webpack:///nextcloud/webpack/bootstrap","webpack:///nextcloud/webpack/runtime/chunk loaded","webpack:///nextcloud/webpack/runtime/compat get default export","webpack:///nextcloud/webpack/runtime/define property getters","webpack:///nextcloud/webpack/runtime/ensure chunk","webpack:///nextcloud/webpack/runtime/global","webpack:///nextcloud/webpack/runtime/hasOwnProperty shorthand","webpack:///nextcloud/webpack/runtime/make namespace object","webpack:///nextcloud/webpack/runtime/node module decorator","webpack:///nextcloud/webpack/runtime/jsonp chunk loading","webpack:///nextcloud/webpack/runtime/nonce","webpack:///nextcloud/webpack/before-startup","webpack:///nextcloud/webpack/startup","webpack:///nextcloud/webpack/after-startup"],"sourcesContent":["/**\n * SPDX-FileCopyrightText: 2016-2024 Nextcloud GmbH and Nextcloud contributors\n * SPDX-FileCopyrightText: 2016 ownCloud, Inc.\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\n/* eslint-disable */\nimport escapeHTML from 'escape-html';\n\n/* global dav */\n\n(function (OC, FileInfo) {\n  /**\n   * @class OC.Files.Client\n   * @classdesc Client to access files on the server\n   *\n   * @param {Object} options\n   * @param {String} options.host host name\n   * @param {number} [options.port] port\n   * @param {boolean} [options.useHTTPS] whether to use https\n   * @param {String} [options.root] root path\n   * @param {String} [options.userName] user name\n   * @param {String} [options.password] password\n   *\n   * @since 8.2\n   */\n  var Client = function (options) {\n    this._root = options.root;\n    if (this._root.charAt(this._root.length - 1) === '/') {\n      this._root = this._root.substr(0, this._root.length - 1);\n    }\n    let url = Client.PROTOCOL_HTTP + '://';\n    if (options.useHTTPS) {\n      url = Client.PROTOCOL_HTTPS + '://';\n    }\n    url += options.host + this._root;\n    this._host = options.host;\n    this._defaultHeaders = options.defaultHeaders || {\n      'X-Requested-With': 'XMLHttpRequest',\n      'requesttoken': OC.requestToken\n    };\n    this._baseUrl = url;\n    const clientOptions = {\n      baseUrl: this._baseUrl,\n      xmlNamespaces: {\n        'DAV:': 'd',\n        'http://owncloud.org/ns': 'oc',\n        'http://nextcloud.org/ns': 'nc',\n        'http://open-collaboration-services.org/ns': 'ocs'\n      }\n    };\n    if (options.userName) {\n      clientOptions.userName = options.userName;\n    }\n    if (options.password) {\n      clientOptions.password = options.password;\n    }\n    this._client = new dav.Client(clientOptions);\n    this._client.xhrProvider = _.bind(this._xhrProvider, this);\n    this._fileInfoParsers = [];\n  };\n  Client.NS_OWNCLOUD = 'http://owncloud.org/ns';\n  Client.NS_NEXTCLOUD = 'http://nextcloud.org/ns';\n  Client.NS_DAV = 'DAV:';\n  Client.NS_OCS = 'http://open-collaboration-services.org/ns';\n  Client.PROPERTY_GETLASTMODIFIED = '{' + Client.NS_DAV + '}getlastmodified';\n  Client.PROPERTY_GETETAG = '{' + Client.NS_DAV + '}getetag';\n  Client.PROPERTY_GETCONTENTTYPE = '{' + Client.NS_DAV + '}getcontenttype';\n  Client.PROPERTY_RESOURCETYPE = '{' + Client.NS_DAV + '}resourcetype';\n  Client.PROPERTY_INTERNAL_FILEID = '{' + Client.NS_OWNCLOUD + '}fileid';\n  Client.PROPERTY_PERMISSIONS = '{' + Client.NS_OWNCLOUD + '}permissions';\n  Client.PROPERTY_SIZE = '{' + Client.NS_OWNCLOUD + '}size';\n  Client.PROPERTY_GETCONTENTLENGTH = '{' + Client.NS_DAV + '}getcontentlength';\n  Client.PROPERTY_ISENCRYPTED = '{' + Client.NS_DAV + '}is-encrypted';\n  Client.PROPERTY_SHARE_PERMISSIONS = '{' + Client.NS_OCS + '}share-permissions';\n  Client.PROPERTY_SHARE_ATTRIBUTES = '{' + Client.NS_NEXTCLOUD + '}share-attributes';\n  Client.PROPERTY_QUOTA_AVAILABLE_BYTES = '{' + Client.NS_DAV + '}quota-available-bytes';\n  Client.PROTOCOL_HTTP = 'http';\n  Client.PROTOCOL_HTTPS = 'https';\n  Client._PROPFIND_PROPERTIES = [\n  /**\n   * Modified time\n   */\n  [Client.NS_DAV, 'getlastmodified'],\n  /**\n   * Etag\n   */\n  [Client.NS_DAV, 'getetag'],\n  /**\n   * Mime type\n   */\n  [Client.NS_DAV, 'getcontenttype'],\n  /**\n   * Resource type \"collection\" for folders, empty otherwise\n   */\n  [Client.NS_DAV, 'resourcetype'],\n  /**\n   * File id\n   */\n  [Client.NS_OWNCLOUD, 'fileid'],\n  /**\n   * Letter-coded permissions\n   */\n  [Client.NS_OWNCLOUD, 'permissions'],\n  // [Client.NS_OWNCLOUD, 'downloadURL'],\n  /**\n   * Folder sizes\n   */\n  [Client.NS_OWNCLOUD, 'size'],\n  /**\n   * File sizes\n   */\n  [Client.NS_DAV, 'getcontentlength'], [Client.NS_DAV, 'quota-available-bytes'],\n  /**\n   * Preview availability\n   */\n  [Client.NS_NEXTCLOUD, 'has-preview'],\n  /**\n   * Mount type\n   */\n  [Client.NS_NEXTCLOUD, 'mount-type'],\n  /**\n   * Encryption state\n   */\n  [Client.NS_NEXTCLOUD, 'is-encrypted'],\n  /**\n   * Share permissions\n   */\n  [Client.NS_OCS, 'share-permissions'],\n  /**\n   * Share attributes\n   */\n  [Client.NS_NEXTCLOUD, 'share-attributes']];\n\n  /**\n   * @memberof OC.Files\n   */\n  Client.prototype = {\n    /**\n     * Root path of the Webdav endpoint\n     *\n     * @type string\n     */\n    _root: null,\n    /**\n     * Client from the library\n     *\n     * @type dav.Client\n     */\n    _client: null,\n    /**\n     * Array of file info parsing functions.\n     *\n     * @type Array<OC.Files.Client~parseFileInfo>\n     */\n    _fileInfoParsers: [],\n    /**\n     * Returns the configured XHR provider for davclient\n     * @returns {XMLHttpRequest}\n     */\n    _xhrProvider: function () {\n      const headers = this._defaultHeaders;\n      const xhr = new XMLHttpRequest();\n      const oldOpen = xhr.open;\n      // override open() method to add headers\n      xhr.open = function () {\n        const result = oldOpen.apply(this, arguments);\n        _.each(headers, function (value, key) {\n          xhr.setRequestHeader(key, value);\n        });\n        return result;\n      };\n      OC.registerXHRForErrorProcessing(xhr);\n      return xhr;\n    },\n    /**\n     * Prepends the base url to the given path sections\n     *\n     * @param {...String} path sections\n     *\n     * @returns {String} base url + joined path, any leading or trailing slash\n     * will be kept\n     */\n    _buildUrl: function () {\n      let path = this._buildPath.apply(this, arguments);\n      if (path.charAt([path.length - 1]) === '/') {\n        path = path.substr(0, path.length - 1);\n      }\n      if (path.charAt(0) === '/') {\n        path = path.substr(1);\n      }\n      return this._baseUrl + '/' + path;\n    },\n    /**\n     * Append the path to the root and also encode path\n     * sections\n     *\n     * @param {...String} path sections\n     *\n     * @returns {String} joined path, any leading or trailing slash\n     * will be kept\n     */\n    _buildPath: function () {\n      let path = OC.joinPaths.apply(this, arguments);\n      const sections = path.split('/');\n      let i;\n      for (i = 0; i < sections.length; i++) {\n        sections[i] = encodeURIComponent(sections[i]);\n      }\n      path = sections.join('/');\n      return path;\n    },\n    /**\n     * Parse headers string into a map\n     *\n     * @param {string} headersString headers list as string\n     *\n     * @returns {Object.<String,Array>} map of header name to header contents\n     */\n    _parseHeaders: function (headersString) {\n      const headerRows = headersString.split('\\n');\n      const headers = {};\n      for (let i = 0; i < headerRows.length; i++) {\n        const sepPos = headerRows[i].indexOf(':');\n        if (sepPos < 0) {\n          continue;\n        }\n        const headerName = headerRows[i].substr(0, sepPos);\n        const headerValue = headerRows[i].substr(sepPos + 2);\n        if (!headers[headerName]) {\n          // make it an array\n          headers[headerName] = [];\n        }\n        headers[headerName].push(headerValue);\n      }\n      return headers;\n    },\n    /**\n     * Parses the etag response which is in double quotes.\n     *\n     * @param {string} etag etag value in double quotes\n     *\n     * @returns {string} etag without double quotes\n     */\n    _parseEtag: function (etag) {\n      if (etag.charAt(0) === '\"') {\n        return etag.split('\"')[1];\n      }\n      return etag;\n    },\n    /**\n     * Parse Webdav result\n     *\n     * @param {Object} response XML object\n     *\n     * @returns {Array.<FileInfo>} array of file info\n     */\n    _parseFileInfo: function (response) {\n      let path = decodeURIComponent(response.href);\n      if (path.substr(0, this._root.length) === this._root) {\n        path = path.substr(this._root.length);\n      }\n      if (path.charAt(path.length - 1) === '/') {\n        path = path.substr(0, path.length - 1);\n      }\n      if (response.propStat.length === 0 || response.propStat[0].status !== 'HTTP/1.1 200 OK') {\n        return null;\n      }\n      const props = response.propStat[0].properties;\n      const data = {\n        id: props[Client.PROPERTY_INTERNAL_FILEID],\n        path: OC.dirname(path) || '/',\n        name: OC.basename(path),\n        mtime: new Date(props[Client.PROPERTY_GETLASTMODIFIED]).getTime()\n      };\n      const etagProp = props[Client.PROPERTY_GETETAG];\n      if (!_.isUndefined(etagProp)) {\n        data.etag = this._parseEtag(etagProp);\n      }\n      let sizeProp = props[Client.PROPERTY_GETCONTENTLENGTH];\n      if (!_.isUndefined(sizeProp)) {\n        data.size = parseInt(sizeProp, 10);\n      }\n      sizeProp = props[Client.PROPERTY_SIZE];\n      if (!_.isUndefined(sizeProp)) {\n        data.size = parseInt(sizeProp, 10);\n      }\n      const hasPreviewProp = props['{' + Client.NS_NEXTCLOUD + '}has-preview'];\n      if (!_.isUndefined(hasPreviewProp)) {\n        data.hasPreview = hasPreviewProp === 'true';\n      } else {\n        data.hasPreview = true;\n      }\n      const isEncryptedProp = props['{' + Client.NS_NEXTCLOUD + '}is-encrypted'];\n      if (!_.isUndefined(isEncryptedProp)) {\n        data.isEncrypted = isEncryptedProp === '1';\n      } else {\n        data.isEncrypted = false;\n      }\n      const isFavouritedProp = props['{' + Client.NS_OWNCLOUD + '}favorite'];\n      if (!_.isUndefined(isFavouritedProp)) {\n        data.isFavourited = isFavouritedProp === '1';\n      } else {\n        data.isFavourited = false;\n      }\n      const contentType = props[Client.PROPERTY_GETCONTENTTYPE];\n      if (!_.isUndefined(contentType)) {\n        data.mimetype = contentType;\n      }\n      const resType = props[Client.PROPERTY_RESOURCETYPE];\n      if (!data.mimetype && resType) {\n        const xmlvalue = resType[0];\n        if (xmlvalue.namespaceURI === Client.NS_DAV && xmlvalue.nodeName.split(':')[1] === 'collection') {\n          data.mimetype = 'httpd/unix-directory';\n        }\n      }\n      data.permissions = OC.PERMISSION_NONE;\n      const permissionProp = props[Client.PROPERTY_PERMISSIONS];\n      if (!_.isUndefined(permissionProp)) {\n        const permString = permissionProp || '';\n        data.mountType = null;\n        for (let i = 0; i < permString.length; i++) {\n          const c = permString.charAt(i);\n          switch (c) {\n            // FIXME: twisted permissions\n            case 'C':\n            case 'K':\n              data.permissions |= OC.PERMISSION_CREATE;\n              break;\n            case 'G':\n              data.permissions |= OC.PERMISSION_READ;\n              break;\n            case 'W':\n            case 'N':\n            case 'V':\n              data.permissions |= OC.PERMISSION_UPDATE;\n              break;\n            case 'D':\n              data.permissions |= OC.PERMISSION_DELETE;\n              break;\n            case 'R':\n              data.permissions |= OC.PERMISSION_SHARE;\n              break;\n            case 'M':\n              if (!data.mountType) {\n                // TODO: how to identify external-root ?\n                data.mountType = 'external';\n              }\n              break;\n            case 'S':\n              // TODO: how to identify shared-root ?\n              data.mountType = 'shared';\n              break;\n          }\n        }\n      }\n      const sharePermissionsProp = props[Client.PROPERTY_SHARE_PERMISSIONS];\n      if (!_.isUndefined(sharePermissionsProp)) {\n        data.sharePermissions = parseInt(sharePermissionsProp);\n      }\n      const shareAttributesProp = props[Client.PROPERTY_SHARE_ATTRIBUTES];\n      if (!_.isUndefined(shareAttributesProp)) {\n        try {\n          data.shareAttributes = JSON.parse(shareAttributesProp);\n        } catch (e) {\n          console.warn('Could not parse share attributes returned by server: \"' + shareAttributesProp + '\"');\n          data.shareAttributes = [];\n        }\n      } else {\n        data.shareAttributes = [];\n      }\n      const mounTypeProp = props['{' + Client.NS_NEXTCLOUD + '}mount-type'];\n      if (!_.isUndefined(mounTypeProp)) {\n        data.mountType = mounTypeProp;\n      }\n      const quotaAvailableBytes = props['{' + Client.NS_DAV + '}quota-available-bytes'];\n      if (!_.isUndefined(quotaAvailableBytes)) {\n        data.quotaAvailableBytes = quotaAvailableBytes;\n      }\n\n      // extend the parsed data using the custom parsers\n      _.each(this._fileInfoParsers, function (parserFunction) {\n        _.extend(data, parserFunction(response, data) || {});\n      });\n      return new FileInfo(data);\n    },\n    /**\n     * Parse Webdav multistatus\n     *\n     * @param {Array} responses\n     */\n    _parseResult: function (responses) {\n      const self = this;\n      return _.map(responses, function (response) {\n        return self._parseFileInfo(response);\n      });\n    },\n    /**\n     * Returns whether the given status code means success\n     *\n     * @param {number} status status code\n     *\n     * @returns true if status code is between 200 and 299 included\n     */\n    _isSuccessStatus: function (status) {\n      return status >= 200 && status <= 299;\n    },\n    /**\n     * Parse the Sabre exception out of the given response, if any\n     *\n     * @param {Object} response object\n     * @returns {Object} array of parsed message and exception (only the first one)\n     */\n    _getSabreException: function (response) {\n      const result = {};\n      const xml = response.xhr.responseXML;\n      if (xml === null) {\n        return result;\n      }\n      const messages = xml.getElementsByTagNameNS('http://sabredav.org/ns', 'message');\n      const exceptions = xml.getElementsByTagNameNS('http://sabredav.org/ns', 'exception');\n      if (messages.length) {\n        result.message = messages[0].textContent;\n      }\n      if (exceptions.length) {\n        result.exception = exceptions[0].textContent;\n      }\n      return result;\n    },\n    /**\n     * Returns the default PROPFIND properties to use during a call.\n     *\n     * @returns {Array.<Object>} array of properties\n     */\n    getPropfindProperties: function () {\n      if (!this._propfindProperties) {\n        this._propfindProperties = _.map(Client._PROPFIND_PROPERTIES, function (propDef) {\n          return '{' + propDef[0] + '}' + propDef[1];\n        });\n      }\n      return this._propfindProperties;\n    },\n    /**\n     * Lists the contents of a directory\n     *\n     * @param {String} path path to retrieve\n     * @param {Object} [options] options\n     * @param {boolean} [options.includeParent=false] set to true to keep\n     * the parent folder in the result list\n     * @param {Array} [options.properties] list of Webdav properties to retrieve\n     *\n     * @returns {Promise} promise\n     */\n    getFolderContents: function (path, options) {\n      if (!path) {\n        path = '';\n      }\n      options = options || {};\n      const self = this;\n      const deferred = $.Deferred();\n      const promise = deferred.promise();\n      let properties;\n      if (_.isUndefined(options.properties)) {\n        properties = this.getPropfindProperties();\n      } else {\n        properties = options.properties;\n      }\n      this._client.propFind(this._buildUrl(path), properties, 1).then(function (result) {\n        if (self._isSuccessStatus(result.status)) {\n          const results = self._parseResult(result.body);\n          if (!options || !options.includeParent) {\n            // remove root dir, the first entry\n            results.shift();\n          }\n          deferred.resolve(result.status, results);\n        } else {\n          result = _.extend(result, self._getSabreException(result));\n          deferred.reject(result.status, result);\n        }\n      });\n      return promise;\n    },\n    /**\n     * Fetches a flat list of files filtered by a given filter criteria.\n     * (currently system tags and circles are supported)\n     *\n     * @param {Object} filter filter criteria\n     * @param {Object} [filter.systemTagIds] list of system tag ids to filter by\n     * @param {boolean} [filter.favorite] set it to filter by favorites\n     * @param {Object} [options] options\n     * @param {Array} [options.properties] list of Webdav properties to retrieve\n     *\n     * @returns {Promise} promise\n     */\n    getFilteredFiles: function (filter, options) {\n      options = options || {};\n      const self = this;\n      const deferred = $.Deferred();\n      const promise = deferred.promise();\n      let properties;\n      if (_.isUndefined(options.properties)) {\n        properties = this.getPropfindProperties();\n      } else {\n        properties = options.properties;\n      }\n      if (!filter || !filter.systemTagIds && _.isUndefined(filter.favorite) && !filter.circlesIds) {\n        throw 'Missing filter argument';\n      }\n\n      // root element with namespaces\n      let body = '<oc:filter-files ';\n      let namespace;\n      for (namespace in this._client.xmlNamespaces) {\n        body += ' xmlns:' + this._client.xmlNamespaces[namespace] + '=\"' + namespace + '\"';\n      }\n      body += '>\\n';\n\n      // properties query\n      body += '    <' + this._client.xmlNamespaces['DAV:'] + ':prop>\\n';\n      _.each(properties, function (prop) {\n        const property = self._client.parseClarkNotation(prop);\n        body += '        <' + self._client.xmlNamespaces[property.namespace] + ':' + property.name + ' />\\n';\n      });\n      body += '    </' + this._client.xmlNamespaces['DAV:'] + ':prop>\\n';\n\n      // rules block\n      body += '    <oc:filter-rules>\\n';\n      _.each(filter.systemTagIds, function (systemTagIds) {\n        body += '        <oc:systemtag>' + escapeHTML(systemTagIds) + '</oc:systemtag>\\n';\n      });\n      _.each(filter.circlesIds, function (circlesIds) {\n        body += '        <oc:circle>' + escapeHTML(circlesIds) + '</oc:circle>\\n';\n      });\n      if (filter.favorite) {\n        body += '        <oc:favorite>' + (filter.favorite ? '1' : '0') + '</oc:favorite>\\n';\n      }\n      body += '    </oc:filter-rules>\\n';\n\n      // end of root\n      body += '</oc:filter-files>\\n';\n      this._client.request('REPORT', this._buildUrl(), {}, body).then(function (result) {\n        if (self._isSuccessStatus(result.status)) {\n          const results = self._parseResult(result.body);\n          deferred.resolve(result.status, results);\n        } else {\n          result = _.extend(result, self._getSabreException(result));\n          deferred.reject(result.status, result);\n        }\n      });\n      return promise;\n    },\n    /**\n     * Returns the file info of a given path.\n     *\n     * @param {String} path path\n     * @param {Array} [options.properties] list of Webdav properties to retrieve\n     *\n     * @returns {Promise} promise\n     */\n    getFileInfo: function (path, options) {\n      if (!path) {\n        path = '';\n      }\n      options = options || {};\n      const self = this;\n      const deferred = $.Deferred();\n      const promise = deferred.promise();\n      let properties;\n      if (_.isUndefined(options.properties)) {\n        properties = this.getPropfindProperties();\n      } else {\n        properties = options.properties;\n      }\n\n      // TODO: headers\n      this._client.propFind(this._buildUrl(path), properties, 0).then(function (result) {\n        if (self._isSuccessStatus(result.status)) {\n          deferred.resolve(result.status, self._parseResult([result.body])[0]);\n        } else {\n          result = _.extend(result, self._getSabreException(result));\n          deferred.reject(result.status, result);\n        }\n      });\n      return promise;\n    },\n    /**\n     * Returns the contents of the given file.\n     *\n     * @param {String} path path to file\n     *\n     * @returns {Promise}\n     */\n    getFileContents: function (path) {\n      if (!path) {\n        throw 'Missing argument \"path\"';\n      }\n      const self = this;\n      const deferred = $.Deferred();\n      const promise = deferred.promise();\n      this._client.request('GET', this._buildUrl(path)).then(function (result) {\n        if (self._isSuccessStatus(result.status)) {\n          deferred.resolve(result.status, result.body);\n        } else {\n          result = _.extend(result, self._getSabreException(result));\n          deferred.reject(result.status, result);\n        }\n      });\n      return promise;\n    },\n    /**\n     * Puts the given data into the given file.\n     *\n     * @param {String} path path to file\n     * @param {String} body file body\n     * @param {Object} [options]\n     * @param {String} [options.contentType='text/plain'] content type\n     * @param {boolean} [options.overwrite=true] whether to overwrite an existing file\n     *\n     * @returns {Promise}\n     */\n    putFileContents: function (path, body, options) {\n      if (!path) {\n        throw 'Missing argument \"path\"';\n      }\n      const self = this;\n      const deferred = $.Deferred();\n      const promise = deferred.promise();\n      options = options || {};\n      const headers = {};\n      let contentType = 'text/plain;charset=utf-8';\n      if (options.contentType) {\n        contentType = options.contentType;\n      }\n      headers['Content-Type'] = contentType;\n      if (_.isUndefined(options.overwrite) || options.overwrite) {\n        // will trigger 412 precondition failed if a file already exists\n        headers['If-None-Match'] = '*';\n      }\n      this._client.request('PUT', this._buildUrl(path), headers, body || '').then(function (result) {\n        if (self._isSuccessStatus(result.status)) {\n          deferred.resolve(result.status);\n        } else {\n          result = _.extend(result, self._getSabreException(result));\n          deferred.reject(result.status, result);\n        }\n      });\n      return promise;\n    },\n    _simpleCall: function (method, path, headers) {\n      if (!path) {\n        throw 'Missing argument \"path\"';\n      }\n      const self = this;\n      const deferred = $.Deferred();\n      const promise = deferred.promise();\n      this._client.request(method, this._buildUrl(path), headers ? headers : {}).then(function (result) {\n        if (self._isSuccessStatus(result.status)) {\n          deferred.resolve(result.status);\n        } else {\n          result = _.extend(result, self._getSabreException(result));\n          deferred.reject(result.status, result);\n        }\n      });\n      return promise;\n    },\n    /**\n     * Creates a directory\n     *\n     * @param {String} path path to create\n     *\n     * @returns {Promise}\n     */\n    createDirectory: function (path, headers) {\n      return this._simpleCall('MKCOL', path, headers);\n    },\n    /**\n     * Deletes a file or directory\n     *\n     * @param {String} path path to delete\n     *\n     * @returns {Promise}\n     */\n    remove: function (path) {\n      return this._simpleCall('DELETE', path);\n    },\n    /**\n     * Moves path to another path\n     *\n     * @param {String} path path to move\n     * @param {String} destinationPath destination path\n     * @param {boolean} [allowOverwrite=false] true to allow overwriting,\n     * false otherwise\n     * @param {Object} [headers=null] additional headers\n     *\n     * @returns {Promise} promise\n     */\n    move: function (path, destinationPath, allowOverwrite, headers) {\n      if (!path) {\n        throw 'Missing argument \"path\"';\n      }\n      if (!destinationPath) {\n        throw 'Missing argument \"destinationPath\"';\n      }\n      const self = this;\n      const deferred = $.Deferred();\n      const promise = deferred.promise();\n      headers = _.extend({}, headers, {\n        'Destination': this._buildUrl(destinationPath)\n      });\n      if (!allowOverwrite) {\n        headers.Overwrite = 'F';\n      }\n      this._client.request('MOVE', this._buildUrl(path), headers).then(function (result) {\n        if (self._isSuccessStatus(result.status)) {\n          deferred.resolve(result.status);\n        } else {\n          result = _.extend(result, self._getSabreException(result));\n          deferred.reject(result.status, result);\n        }\n      });\n      return promise;\n    },\n    /**\n     * Copies path to another path\n     *\n     * @param {String} path path to copy\n     * @param {String} destinationPath destination path\n     * @param {boolean} [allowOverwrite=false] true to allow overwriting,\n     * false otherwise\n     *\n     * @returns {Promise} promise\n     */\n    copy: function (path, destinationPath, allowOverwrite) {\n      if (!path) {\n        throw 'Missing argument \"path\"';\n      }\n      if (!destinationPath) {\n        throw 'Missing argument \"destinationPath\"';\n      }\n      const self = this;\n      const deferred = $.Deferred();\n      const promise = deferred.promise();\n      const headers = {\n        'Destination': this._buildUrl(destinationPath)\n      };\n      if (!allowOverwrite) {\n        headers.Overwrite = 'F';\n      }\n      this._client.request('COPY', this._buildUrl(path), headers).then(function (response) {\n        if (self._isSuccessStatus(response.status)) {\n          deferred.resolve(response.status);\n        } else {\n          deferred.reject(response.status);\n        }\n      });\n      return promise;\n    },\n    /**\n     * Add a file info parser function\n     *\n     * @param {OC.Files.Client~parseFileInfo} parserFunction\n     */\n    addFileInfoParser: function (parserFunction) {\n      this._fileInfoParsers.push(parserFunction);\n    },\n    /**\n     * Returns the dav.Client instance used internally\n     *\n     * @since 11.0.0\n     * @returns {dav.Client}\n     */\n    getClient: function () {\n      return this._client;\n    },\n    /**\n     * Returns the user name\n     *\n     * @since 11.0.0\n     * @returns {String} userName\n     */\n    getUserName: function () {\n      return this._client.userName;\n    },\n    /**\n     * Returns the password\n     *\n     * @since 11.0.0\n     * @returns {String} password\n     */\n    getPassword: function () {\n      return this._client.password;\n    },\n    /**\n     * Returns the base URL\n     *\n     * @since 11.0.0\n     * @returns {String} base URL\n     */\n    getBaseUrl: function () {\n      return this._client.baseUrl;\n    },\n    /**\n     * Returns the host\n     *\n     * @since 13.0.0\n     * @returns {String} base URL\n     */\n    getHost: function () {\n      return this._host;\n    }\n  };\n\n  /**\n   * File info parser function\n   *\n   * This function receives a list of Webdav properties as input and\n   * should return a hash array of parsed properties, if applicable.\n   *\n   * @callback OC.Files.Client~parseFileInfo\n   * @param {Object} XML Webdav properties\n      * @return {Array} array of parsed property values\n   */\n\n  if (!OC.Files) {\n    /**\n     * @namespace OC.Files\n     *\n     * @since 8.2\n     */\n    OC.Files = {};\n  }\n\n  /**\n   * Returns the default instance of the files client\n   *\n   * @returns {OC.Files.Client} default client\n   *\n   * @since 8.2\n   */\n  OC.Files.getClient = function () {\n    if (OC.Files._defaultClient) {\n      return OC.Files._defaultClient;\n    }\n    const client = new OC.Files.Client({\n      host: OC.getHost(),\n      port: OC.getPort(),\n      root: OC.linkToRemoteBase('dav') + '/files/' + OC.getCurrentUser().uid,\n      useHTTPS: OC.getProtocol() === 'https'\n    });\n    OC.Files._defaultClient = client;\n    return client;\n  };\n  OC.Files.Client = Client;\n})(OC, OC.Files.FileInfo);","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// The chunk loading function for additional chunks\n// Since all referenced chunks are already included\n// in this file, this function is empty here.\n__webpack_require__.e = () => (Promise.resolve());","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"core-files_client\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunknextcloud\"] = self[\"webpackChunknextcloud\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","__webpack_require__.nc = undefined;","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"core-common\"], () => (__webpack_require__(\"./core/src/files/client.js\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}