{"version":3,"file":"api-9VLobucH.chunk.mjs","sources":["../build/frontend/apps/systemtags/src/logger.ts","../build/frontend/apps/systemtags/src/utils.ts","../build/frontend/apps/systemtags/src/services/davClient.ts","../build/frontend/apps/systemtags/src/services/api.ts"],"sourcesContent":["/**\n * SPDX-FileCopyrightText: 2023 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport { getLoggerBuilder } from '@nextcloud/logger'\n\nexport default getLoggerBuilder()\n\t.setApp('systemtags')\n\t.detectUser()\n\t.build()\n","/**\n * SPDX-FileCopyrightText: 2023 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport type { INode } from '@nextcloud/files'\nimport type { DAVResultResponseProps } from 'webdav'\nimport type { BaseTag, ServerTag, Tag, TagWithId } from './types.ts'\n\nimport { emit } from '@nextcloud/event-bus'\n\nexport const defaultBaseTag: BaseTag = {\n\tuserVisible: true,\n\tuserAssignable: true,\n\tcanAssign: true,\n}\n\nconst propertyMappings = Object.freeze({\n\t'display-name': 'displayName',\n\t'user-visible': 'userVisible',\n\t'user-assignable': 'userAssignable',\n\t'can-assign': 'canAssign',\n})\n\n/**\n * Parse tags from WebDAV response\n *\n * @param tags - Array of tags from WebDAV response\n */\nexport function parseTags(tags: { props: DAVResultResponseProps }[]): TagWithId[] {\n\treturn tags.map(({ props }) => Object.fromEntries(Object.entries(props)\n\t\t.map(([key, value]) => {\n\t\t\tkey = propertyMappings[key] ?? key\n\t\t\tvalue = key === 'displayName' ? String(value) : value\n\t\t\treturn [key, value]\n\t\t})) as unknown as TagWithId)\n}\n\n/**\n * Parse id from `Content-Location` header\n *\n * @param url URL to parse\n */\nexport function parseIdFromLocation(url: string): number {\n\tconst queryPos = url.indexOf('?')\n\tif (queryPos > 0) {\n\t\turl = url.substring(0, queryPos)\n\t}\n\n\tconst parts = url.split('/')\n\tlet result\n\tdo {\n\t\tresult = parts[parts.length - 1]\n\t\tparts.pop()\n\t\t// note: first result can be empty when there is a trailing slash,\n\t\t// so we take the part before that\n\t} while (!result && parts.length > 0)\n\n\treturn Number(result)\n}\n\n/**\n * Format a tag for WebDAV operations\n *\n * @param initialTag - Tag to format\n */\nexport function formatTag(initialTag: Tag | ServerTag): ServerTag {\n\tif ('name' in initialTag && !('displayName' in initialTag)) {\n\t\treturn { ...initialTag }\n\t}\n\n\tconst tag: Record<string, unknown> = { ...initialTag }\n\ttag.name = tag.displayName\n\tdelete tag.displayName\n\n\treturn tag as unknown as ServerTag\n}\n\n/**\n * Get system tags from a node\n *\n * @param node - The node to get tags from\n */\nexport function getNodeSystemTags(node: INode): string[] {\n\tconst attribute = node.attributes?.['system-tags']?.['system-tag']\n\tif (attribute === undefined) {\n\t\treturn []\n\t}\n\n\t// if there is only one tag it is a single string or prop object\n\t// if there are multiple then its an array - so we flatten it to be always an array of string or prop objects\n\treturn [attribute]\n\t\t.flat()\n\t\t.map((tag: string | { text: string }) => (\n\t\t\ttypeof tag === 'string'\n\t\t\t\t// its a plain text prop (the tag name) without prop attributes\n\t\t\t\t? tag\n\t\t\t\t// its a prop object with attributes, the tag name is in the 'text' attribute\n\t\t\t\t: tag.text\n\t\t))\n}\n\n/**\n * Set system tags on a node\n *\n * @param node - The node to set tags on\n * @param tags - The tags to set\n */\nexport function setNodeSystemTags(node: INode, tags: string[]): void {\n\tnode.attributes['system-tags'] = {\n\t\t'system-tag': tags,\n\t}\n\temit('files:node:updated', node)\n}\n","/*!\n * SPDX-FileCopyrightText: 2023 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport type { Node } from '@nextcloud/files'\nimport type { FileStat, ResponseDataDetailed } from 'webdav'\n\nimport { getClient, getDefaultPropfind, getRootPath, resultToNode } from '@nextcloud/files/dav'\n\nexport const davClient = getClient()\n\n/**\n * Fetches a node from the given path\n *\n * @param path - The path to fetch the node from\n */\nexport async function fetchNode(path: string): Promise<Node> {\n\tconst propfindPayload = getDefaultPropfind()\n\tconst result = await davClient.stat(`${getRootPath()}${path}`, {\n\t\tdetails: true,\n\t\tdata: propfindPayload,\n\t}) as ResponseDataDetailed<FileStat>\n\treturn resultToNode(result.data)\n}\n","/**\n * SPDX-FileCopyrightText: 2023 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport type { OCSResponse } from '@nextcloud/typings/ocs'\nimport type { FileStat, ResponseDataDetailed, WebDAVClientError } from 'webdav'\nimport type { ServerTag, Tag, TagWithId } from '../types.ts'\n\nimport axios from '@nextcloud/axios'\nimport { emit } from '@nextcloud/event-bus'\nimport { t } from '@nextcloud/l10n'\nimport { confirmPassword } from '@nextcloud/password-confirmation'\nimport { generateOcsUrl, generateUrl } from '@nextcloud/router'\nimport logger from '../logger.ts'\nimport { formatTag, parseIdFromLocation, parseTags } from '../utils.ts'\nimport { davClient } from './davClient.ts'\n\nexport const fetchTagsPayload = `<?xml version=\"1.0\"?>\n<d:propfind xmlns:d=\"DAV:\" xmlns:oc=\"http://owncloud.org/ns\" xmlns:nc=\"http://nextcloud.org/ns\">\n\t<d:prop>\n\t\t<oc:id />\n\t\t<oc:display-name />\n\t\t<oc:user-visible />\n\t\t<oc:user-assignable />\n\t\t<oc:can-assign />\n\t\t<d:getetag />\n\t\t<nc:color />\n\t</d:prop>\n</d:propfind>`\n\n/**\n * Fetch all tags.\n */\nexport async function fetchTags(): Promise<TagWithId[]> {\n\tconst path = '/systemtags'\n\ttry {\n\t\tconst { data: tags } = await davClient.getDirectoryContents(path, {\n\t\t\tdata: fetchTagsPayload,\n\t\t\tdetails: true,\n\t\t\tglob: '/systemtags/*', // Filter out first empty tag\n\t\t}) as ResponseDataDetailed<Required<FileStat>[]>\n\t\treturn parseTags(tags)\n\t} catch (error) {\n\t\tlogger.error(t('systemtags', 'Failed to load tags'), { error })\n\t\tthrow new Error(t('systemtags', 'Failed to load tags'))\n\t}\n}\n\n/**\n * Fetch a single tag by its ID.\n *\n * @param tagId - The ID of the tag to fetch\n */\nexport async function fetchTag(tagId: number): Promise<TagWithId> {\n\tconst path = '/systemtags/' + tagId\n\ttry {\n\t\tconst { data: tag } = await davClient.stat(path, {\n\t\t\tdata: fetchTagsPayload,\n\t\t\tdetails: true,\n\t\t}) as ResponseDataDetailed<Required<FileStat>>\n\t\treturn parseTags([tag])[0]!\n\t} catch (error) {\n\t\tlogger.error(t('systemtags', 'Failed to load tag'), { error })\n\t\tthrow new Error(t('systemtags', 'Failed to load tag'))\n\t}\n}\n\n/**\n * Get the last used tag IDs.\n */\nexport async function fetchLastUsedTagIds(): Promise<number[]> {\n\tconst url = generateUrl('/apps/systemtags/lastused')\n\ttry {\n\t\tconst { data: lastUsedTagIds } = await axios.get<string[]>(url)\n\t\treturn lastUsedTagIds.map(Number)\n\t} catch (error) {\n\t\tlogger.error(t('systemtags', 'Failed to load last used tags'), { error })\n\t\tthrow new Error(t('systemtags', 'Failed to load last used tags'))\n\t}\n}\n\n/**\n * Create a tag and return the Id of the newly created tag.\n *\n * @param tag The tag to create\n */\nexport async function createTag(tag: Tag | ServerTag): Promise<number> {\n\tconst path = '/systemtags'\n\tconst tagToPost = formatTag(tag)\n\ttry {\n\t\tconst { headers } = await davClient.customRequest(path, {\n\t\t\tmethod: 'POST',\n\t\t\tdata: tagToPost,\n\t\t})\n\t\tconst contentLocation = headers.get('content-location')\n\t\tif (contentLocation) {\n\t\t\temit('systemtags:tag:created', tag)\n\t\t\treturn parseIdFromLocation(contentLocation)\n\t\t}\n\t\tlogger.error(t('systemtags', 'Missing \"Content-Location\" header'))\n\t\tthrow new Error(t('systemtags', 'Missing \"Content-Location\" header'))\n\t} catch (error) {\n\t\tif ((error as WebDAVClientError)?.response?.status === 409) {\n\t\t\tlogger.error(t('systemtags', 'A tag with the same name already exists'), { error })\n\t\t\tthrow new Error(t('systemtags', 'A tag with the same name already exists'))\n\t\t}\n\t\tlogger.error(t('systemtags', 'Failed to create tag'), { error })\n\t\tthrow new Error(t('systemtags', 'Failed to create tag'))\n\t}\n}\n\n/**\n * Update a tag on the server.\n *\n * @param tag - The tag to update\n */\nexport async function updateTag(tag: TagWithId): Promise<void> {\n\tconst path = '/systemtags/' + tag.id\n\tconst data = `<?xml version=\"1.0\"?>\n\t<d:propertyupdate xmlns:d=\"DAV:\" xmlns:oc=\"http://owncloud.org/ns\" xmlns:nc=\"http://nextcloud.org/ns\">\n\t\t<d:set>\n\t\t\t<d:prop>\n\t\t\t\t<oc:display-name>${tag.displayName}</oc:display-name>\n\t\t\t\t<oc:user-visible>${tag.userVisible}</oc:user-visible>\n\t\t\t\t<oc:user-assignable>${tag.userAssignable}</oc:user-assignable>\n\t\t\t\t<nc:color>${tag?.color || null}</nc:color>\n\t\t\t</d:prop>\n\t\t</d:set>\n\t</d:propertyupdate>`\n\n\ttry {\n\t\tawait davClient.customRequest(path, {\n\t\t\tmethod: 'PROPPATCH',\n\t\t\tdata,\n\t\t})\n\t\temit('systemtags:tag:updated', tag)\n\t} catch (error) {\n\t\tlogger.error(t('systemtags', 'Failed to update tag'), { error })\n\t\tthrow new Error(t('systemtags', 'Failed to update tag'))\n\t}\n}\n\n/**\n * Delete a tag.\n *\n * @param tag - The tag to delete\n */\nexport async function deleteTag(tag: TagWithId): Promise<void> {\n\tconst path = '/systemtags/' + tag.id\n\ttry {\n\t\tawait davClient.deleteFile(path)\n\t\temit('systemtags:tag:deleted', tag)\n\t} catch (error) {\n\t\tlogger.error(t('systemtags', 'Failed to delete tag'), { error })\n\t\tthrow new Error(t('systemtags', 'Failed to delete tag'))\n\t}\n}\n\ntype TagObject = {\n\tid: number\n\ttype: string\n}\n\ntype TagObjectResponse = {\n\tetag: string\n\tobjects: TagObject[]\n}\n\n/**\n * Get the objects for a tag.\n *\n * @param tag - The tag to get the objects for\n * @param type - The type of the objects\n */\nexport async function getTagObjects(tag: TagWithId, type: string): Promise<TagObjectResponse> {\n\tconst path = `/systemtags/${tag.id}/${type}`\n\tconst data = `<?xml version=\"1.0\"?>\n\t<d:propfind xmlns:d=\"DAV:\" xmlns:nc=\"http://nextcloud.org/ns\">\n\t\t<d:prop>\n\t\t\t<nc:object-ids />\n\t\t\t<d:getetag />\n\t\t</d:prop>\n\t</d:propfind>`\n\n\tconst response = await davClient.stat(path, { data, details: true }) as ResponseDataDetailed<FileStat>\n\tconst etag = response?.data?.props?.getetag || '\"\"'\n\tconst objects = Object.values(response?.data?.props?.['object-ids'] || []).flat() as TagObject[]\n\n\treturn {\n\t\tetag,\n\t\tobjects,\n\t}\n}\n\n/**\n * Set the objects for a tag.\n * Warning: This will overwrite the existing objects.\n *\n * @param tag The tag to set the objects for\n * @param type The type of the objects\n * @param objectIds The objects to set\n * @param etag Strongly recommended to avoid conflict and data loss.\n */\nexport async function setTagObjects(tag: TagWithId, type: string, objectIds: TagObject[], etag: string = ''): Promise<void> {\n\tconst path = `/systemtags/${tag.id}/${type}`\n\tlet data = `<?xml version=\"1.0\"?>\n\t<d:propertyupdate xmlns:d=\"DAV:\" xmlns:nc=\"http://nextcloud.org/ns\">\n\t\t<d:set>\n\t\t\t<d:prop>\n\t\t\t\t<nc:object-ids>${objectIds.map(({ id, type }) => `<nc:object-id><nc:id>${id}</nc:id><nc:type>${type}</nc:type></nc:object-id>`).join('')}</nc:object-ids>\n\t\t\t</d:prop>\n\t\t</d:set>\n\t</d:propertyupdate>`\n\n\tif (objectIds.length === 0) {\n\t\tdata = `<?xml version=\"1.0\"?>\n\t\t<d:propertyupdate xmlns:d=\"DAV:\" xmlns:nc=\"http://nextcloud.org/ns\">\n\t\t\t<d:remove>\n\t\t\t\t<d:prop>\n\t\t\t\t\t<nc:object-ids />\n\t\t\t\t</d:prop>\n\t\t\t</d:remove>\n\t\t</d:propertyupdate>`\n\t}\n\n\tawait davClient.customRequest(path, {\n\t\tmethod: 'PROPPATCH',\n\t\tdata,\n\t\theaders: {\n\t\t\t'if-match': etag,\n\t\t},\n\t})\n}\n\n/**\n * Update the system tags admin restriction setting.\n *\n * @param isAllowed - True if system tags creation is allowed for non-admins\n */\nexport async function updateSystemTagsAdminRestriction(isAllowed: boolean): Promise<OCSResponse> {\n\t// Convert to string for compatibility\n\tconst isAllowedString = isAllowed ? '1' : '0'\n\n\tconst url = generateOcsUrl('/apps/provisioning_api/api/v1/config/apps/{appId}/{key}', {\n\t\tappId: 'systemtags',\n\t\tkey: 'restrict_creation_to_admin',\n\t})\n\n\tawait confirmPassword()\n\n\tconst { data } = await axios.post(url, {\n\t\tvalue: isAllowedString,\n\t})\n\n\treturn data\n}\n"],"names":["logger","getLoggerBuilder","defaultBaseTag","propertyMappings","parseTags","tags","props","key","value","parseIdFromLocation","url","queryPos","parts","result","formatTag","initialTag","tag","getNodeSystemTags","node","attribute","setNodeSystemTags","emit","davClient","getClient","fetchTagsPayload","fetchTags","path","error","t","fetchTag","tagId","createTag","tagToPost","headers","contentLocation","updateTag","data","deleteTag","getTagObjects","type","response","etag","objects","setTagObjects","objectIds","id","updateSystemTagsAdminRestriction","isAllowed","isAllowedString","generateOcsUrl","confirmPassword","axios"],"mappings":"iUAOA,MAAAA,EAAeC,IACb,OAAO,YAAY,EACnB,WAAA,EACA,MAAA,ECCWC,EAA0B,CACtC,YAAa,GACb,eAAgB,GAChB,UAAW,EACZ,EAEMC,EAAmB,OAAO,OAAO,CACtC,eAAgB,cAChB,eAAgB,cAChB,kBAAmB,iBACnB,aAAc,WACf,CAAC,EAOM,SAASC,EAAUC,EAAwD,CACjF,OAAOA,EAAK,IAAI,CAAC,CAAE,MAAAC,CAAA,IAAY,OAAO,YAAY,OAAO,QAAQA,CAAK,EACpE,IAAI,CAAC,CAACC,EAAKC,CAAK,KAChBD,EAAMJ,EAAiBI,CAAG,GAAKA,EAC/BC,EAAQD,IAAQ,cAAgB,OAAOC,CAAK,EAAIA,EACzC,CAACD,EAAKC,CAAK,EAClB,CAAC,CAAyB,CAC7B,CAOO,SAASC,EAAoBC,EAAqB,CACxD,MAAMC,EAAWD,EAAI,QAAQ,GAAG,EAC5BC,EAAW,IACdD,EAAMA,EAAI,UAAU,EAAGC,CAAQ,GAGhC,MAAMC,EAAQF,EAAI,MAAM,GAAG,EAC3B,IAAIG,EACJ,GACCA,EAASD,EAAMA,EAAM,OAAS,CAAC,EAC/BA,EAAM,IAAA,QAGE,CAACC,GAAUD,EAAM,OAAS,GAEnC,OAAO,OAAOC,CAAM,CACrB,CAOO,SAASC,EAAUC,EAAwC,CACjE,GAAI,SAAUA,GAAc,EAAE,gBAAiBA,GAC9C,MAAO,CAAE,GAAGA,CAAA,EAGb,MAAMC,EAA+B,CAAE,GAAGD,CAAA,EAC1C,OAAAC,EAAI,KAAOA,EAAI,YACf,OAAOA,EAAI,YAEJA,CACR,CAOO,SAASC,EAAkBC,EAAuB,CACxD,MAAMC,EAAYD,EAAK,aAAa,aAAa,IAAI,YAAY,EACjE,OAAIC,IAAc,OACV,CAAA,EAKD,CAACA,CAAS,EACf,KAAA,EACA,IAAKH,GACL,OAAOA,GAAQ,SAEZA,EAEAA,EAAI,IACP,CACH,CAQO,SAASI,EAAkBF,EAAab,EAAsB,CACpEa,EAAK,WAAW,aAAa,EAAI,CAChC,aAAcb,CAAA,EAEfgB,EAAK,qBAAsBH,CAAI,CAChC,CCvGO,MAAMI,EAAYC,EAAA,ECQZC,EAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAgBhC,eAAsBC,GAAkC,CACvD,MAAMC,EAAO,cACb,GAAI,CACH,KAAM,CAAE,KAAMrB,CAAA,EAAS,MAAMiB,EAAU,qBAAqBI,EAAM,CACjE,KAAMF,EACN,QAAS,GACT,KAAM,eAAA,CACN,EACD,OAAOpB,EAAUC,CAAI,CACtB,OAASsB,EAAO,CACf,MAAA3B,EAAO,MAAM4B,EAAE,aAAc,qBAAqB,EAAG,CAAE,MAAAD,EAAO,EACxD,IAAI,MAAMC,EAAE,aAAc,qBAAqB,CAAC,CACvD,CACD,CAOA,eAAsBC,EAASC,EAAmC,CACjE,MAAMJ,EAAO,eAAiBI,EAC9B,GAAI,CACH,KAAM,CAAE,KAAMd,CAAA,EAAQ,MAAMM,EAAU,KAAKI,EAAM,CAChD,KAAMF,EACN,QAAS,EAAA,CACT,EACD,OAAOpB,EAAU,CAACY,CAAG,CAAC,EAAE,CAAC,CAC1B,OAASW,EAAO,CACf,MAAA3B,EAAO,MAAM4B,EAAE,aAAc,oBAAoB,EAAG,CAAE,MAAAD,EAAO,EACvD,IAAI,MAAMC,EAAE,aAAc,oBAAoB,CAAC,CACtD,CACD,CAqBA,eAAsBG,EAAUf,EAAuC,CACtE,MAAMU,EAAO,cACPM,EAAYlB,EAAUE,CAAG,EAC/B,GAAI,CACH,KAAM,CAAE,QAAAiB,CAAA,EAAY,MAAMX,EAAU,cAAcI,EAAM,CACvD,OAAQ,OACR,KAAMM,CAAA,CACN,EACKE,EAAkBD,EAAQ,IAAI,kBAAkB,EACtD,GAAIC,EACH,OAAAb,EAAK,yBAA0BL,CAAG,EAC3BP,EAAoByB,CAAe,EAE3C,MAAAlC,EAAO,MAAM4B,EAAE,aAAc,mCAAmC,CAAC,EAC3D,IAAI,MAAMA,EAAE,aAAc,mCAAmC,CAAC,CACrE,OAASD,EAAO,CACf,MAAKA,GAA6B,UAAU,SAAW,KACtD3B,EAAO,MAAM4B,EAAE,aAAc,yCAAyC,EAAG,CAAE,MAAAD,EAAO,EAC5E,IAAI,MAAMC,EAAE,aAAc,yCAAyC,CAAC,IAE3E5B,EAAO,MAAM4B,EAAE,aAAc,sBAAsB,EAAG,CAAE,MAAAD,EAAO,EACzD,IAAI,MAAMC,EAAE,aAAc,sBAAsB,CAAC,EACxD,CACD,CAOA,eAAsBO,EAAUnB,EAA+B,CAC9D,MAAMU,EAAO,eAAiBV,EAAI,GAC5BoB,EAAO;AAAA;AAAA;AAAA;AAAA,uBAISpB,EAAI,WAAW;AAAA,uBACfA,EAAI,WAAW;AAAA,0BACZA,EAAI,cAAc;AAAA,gBAC5BA,GAAK,OAAS,IAAI;AAAA;AAAA;AAAA,sBAKjC,GAAI,CACH,MAAMM,EAAU,cAAcI,EAAM,CACnC,OAAQ,YACR,KAAAU,CAAA,CACA,EACDf,EAAK,yBAA0BL,CAAG,CACnC,OAASW,EAAO,CACf,MAAA3B,EAAO,MAAM4B,EAAE,aAAc,sBAAsB,EAAG,CAAE,MAAAD,EAAO,EACzD,IAAI,MAAMC,EAAE,aAAc,sBAAsB,CAAC,CACxD,CACD,CAOA,eAAsBS,EAAUrB,EAA+B,CAC9D,MAAMU,EAAO,eAAiBV,EAAI,GAClC,GAAI,CACH,MAAMM,EAAU,WAAWI,CAAI,EAC/BL,EAAK,yBAA0BL,CAAG,CACnC,OAASW,EAAO,CACf,MAAA3B,EAAO,MAAM4B,EAAE,aAAc,sBAAsB,EAAG,CAAE,MAAAD,EAAO,EACzD,IAAI,MAAMC,EAAE,aAAc,sBAAsB,CAAC,CACxD,CACD,CAkBA,eAAsBU,EAActB,EAAgBuB,EAA0C,CAC7F,MAAMb,EAAO,eAAeV,EAAI,EAAE,IAAIuB,CAAI,GASpCC,EAAW,MAAMlB,EAAU,KAAKI,EAAM,CAAE,KARjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAQuC,QAAS,GAAM,EAC7De,EAAOD,GAAU,MAAM,OAAO,SAAW,KACzCE,EAAU,OAAO,OAAOF,GAAU,MAAM,QAAQ,YAAY,GAAK,EAAE,EAAE,KAAA,EAE3E,MAAO,CACN,KAAAC,EACA,QAAAC,CAAA,CAEF,CAWA,eAAsBC,EAAc3B,EAAgBuB,EAAcK,EAAwBH,EAAe,GAAmB,CAC3H,MAAMf,EAAO,eAAeV,EAAI,EAAE,IAAIuB,CAAI,GAC1C,IAAIH,EAAO;AAAA;AAAA;AAAA;AAAA,qBAISQ,EAAU,IAAI,CAAC,CAAE,GAAAC,EAAI,KAAAN,KAAW,wBAAwBM,CAAE,oBAAoBN,CAAI,2BAA2B,EAAE,KAAK,EAAE,CAAC;AAAA;AAAA;AAAA,sBAKvIK,EAAU,SAAW,IACxBR,EAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBAUR,MAAMd,EAAU,cAAcI,EAAM,CACnC,OAAQ,YACR,KAAAU,EACA,QAAS,CACR,WAAYK,CAAA,CACb,CACA,CACF,CAOA,eAAsBK,EAAiCC,EAA0C,CAEhG,MAAMC,EAAkBD,EAAY,IAAM,IAEpCrC,EAAMuC,EAAe,0DAA2D,CACrF,MAAO,aACP,IAAK,4BAAA,CACL,EAED,MAAMC,EAAA,EAEN,KAAM,CAAE,KAAAd,CAAA,EAAS,MAAMe,EAAM,KAAKzC,EAAK,CACtC,MAAOsC,CAAA,CACP,EAED,OAAOZ,CACR"}