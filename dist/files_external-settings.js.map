{"version":3,"file":"files_external-settings.js?v=d33d4b324d9b286442de","mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACn7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACRA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACvFA;;;;;AEAA;AACA;AACA;AACA;AACA","sources":["webpack:///nextcloud/apps/files_external/src/settings.js","webpack:///nextcloud/webpack/bootstrap","webpack:///nextcloud/webpack/runtime/chunk loaded","webpack:///nextcloud/webpack/runtime/compat get default export","webpack:///nextcloud/webpack/runtime/define property getters","webpack:///nextcloud/webpack/runtime/ensure chunk","webpack:///nextcloud/webpack/runtime/get javascript chunk filename","webpack:///nextcloud/webpack/runtime/global","webpack:///nextcloud/webpack/runtime/hasOwnProperty shorthand","webpack:///nextcloud/webpack/runtime/load script","webpack:///nextcloud/webpack/runtime/make namespace object","webpack:///nextcloud/webpack/runtime/node module decorator","webpack:///nextcloud/webpack/runtime/publicPath","webpack:///nextcloud/webpack/runtime/jsonp chunk loading","webpack:///nextcloud/webpack/runtime/nonce","webpack:///nextcloud/webpack/before-startup","webpack:///nextcloud/webpack/startup","webpack:///nextcloud/webpack/after-startup"],"sourcesContent":["/**\n * SPDX-FileCopyrightText: 2016-2024 Nextcloud GmbH and Nextcloud contributors\n * SPDX-FileCopyrightText: 2012-2016 ownCloud, Inc.\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport { addPasswordConfirmationInterceptors, PwdConfirmationMode } from '@nextcloud/password-confirmation';\nimport { generateUrl } from '@nextcloud/router';\nimport { showError } from '@nextcloud/dialogs';\nimport { t } from '@nextcloud/l10n';\nimport axios, { isAxiosError } from '@nextcloud/axios';\nimport jQuery from 'jquery';\naddPasswordConfirmationInterceptors(axios);\n\n/**\n * Returns the selection of applicable users in the given configuration row\n *\n * @param $row configuration row\n * @return array array of user names\n */\nfunction getSelection($row) {\n  let values = $row.find('.applicableUsers').select2('val');\n  if (!values || values.length === 0) {\n    values = [];\n  }\n  return values;\n}\n\n/**\n *\n * @param $row\n */\nfunction getSelectedApplicable($row) {\n  const users = [];\n  const groups = [];\n  const multiselect = getSelection($row);\n  $.each(multiselect, function (index, value) {\n    // FIXME: don't rely on string parts to detect groups...\n    const pos = value.indexOf ? value.indexOf('(group)') : -1;\n    if (pos !== -1) {\n      groups.push(value.substr(0, pos));\n    } else {\n      users.push(value);\n    }\n  });\n\n  // FIXME: this should be done in the multiselect change event instead\n  $row.find('.applicable').data('applicable-groups', groups).data('applicable-users', users);\n  return {\n    users,\n    groups\n  };\n}\n\n/**\n *\n * @param $element\n * @param highlight\n */\nfunction highlightBorder($element, highlight) {\n  $element.toggleClass('warning-input', highlight);\n  return highlight;\n}\n\n/**\n *\n * @param $input\n */\nfunction isInputValid($input) {\n  const optional = $input.hasClass('optional');\n  switch ($input.attr('type')) {\n    case 'text':\n    case 'password':\n      if ($input.val() === '' && !optional) {\n        return false;\n      }\n      break;\n  }\n  return true;\n}\n\n/**\n *\n * @param $input\n */\nfunction highlightInput($input) {\n  switch ($input.attr('type')) {\n    case 'text':\n    case 'password':\n      return highlightBorder($input, !isInputValid($input));\n  }\n}\n\n/**\n * Initialize select2 plugin on the given elements\n *\n * @param {Array<object>} array of jQuery elements\n * @param $elements\n * @param {number} userListLimit page size for result list\n */\nfunction initApplicableUsersMultiselect($elements, userListLimit) {\n  const escapeHTML = function (text) {\n    return text.toString().split('&').join('&amp;').split('<').join('&lt;').split('>').join('&gt;').split('\"').join('&quot;').split('\\'').join('&#039;');\n  };\n  if (!$elements.length) {\n    return;\n  }\n  return $elements.select2({\n    placeholder: t('files_external', 'Type to select account or group.'),\n    allowClear: true,\n    multiple: true,\n    toggleSelect: true,\n    dropdownCssClass: 'files-external-select2',\n    // minimumInputLength: 1,\n    ajax: {\n      url: OC.generateUrl('apps/files_external/applicable'),\n      dataType: 'json',\n      quietMillis: 100,\n      data(term, page) {\n        // page is the one-based page number tracked by Select2\n        return {\n          pattern: term,\n          // search term\n          limit: userListLimit,\n          // page size\n          offset: userListLimit * (page - 1) // page number starts with 0\n        };\n      },\n      results(data) {\n        if (data.status === 'success') {\n          const results = [];\n          let userCount = 0; // users is an object\n\n          // add groups\n          $.each(data.groups, function (gid, group) {\n            results.push({\n              name: gid + '(group)',\n              displayname: group,\n              type: 'group'\n            });\n          });\n          // add users\n          $.each(data.users, function (id, user) {\n            userCount++;\n            results.push({\n              name: id,\n              displayname: user,\n              type: 'user'\n            });\n          });\n          const more = userCount >= userListLimit || data.groups.length >= userListLimit;\n          return {\n            results,\n            more\n          };\n        } else {\n          // FIXME add error handling\n        }\n      }\n    },\n    initSelection(element, callback) {\n      const users = {};\n      users.users = [];\n      const toSplit = element.val().split(',');\n      for (let i = 0; i < toSplit.length; i++) {\n        users.users.push(toSplit[i]);\n      }\n      $.ajax(OC.generateUrl('displaynames'), {\n        type: 'POST',\n        contentType: 'application/json',\n        data: JSON.stringify(users),\n        dataType: 'json'\n      }).done(function (data) {\n        const results = [];\n        if (data.status === 'success') {\n          $.each(data.users, function (user, displayname) {\n            if (displayname !== false) {\n              results.push({\n                name: user,\n                displayname,\n                type: 'user'\n              });\n            }\n          });\n          callback(results);\n        } else {\n          // FIXME add error handling\n        }\n      });\n    },\n    id(element) {\n      return element.name;\n    },\n    formatResult(element) {\n      const $result = $('<span><div class=\"avatardiv\"></div><span>' + escapeHTML(element.displayname) + '</span></span>');\n      const $div = $result.find('.avatardiv').attr('data-type', element.type).attr('data-name', element.name).attr('data-displayname', element.displayname);\n      if (element.type === 'group') {\n        const url = OC.imagePath('core', 'actions/group');\n        $div.html('<img width=\"32\" height=\"32\" src=\"' + url + '\">');\n      }\n      return $result.get(0).outerHTML;\n    },\n    formatSelection(element) {\n      if (element.type === 'group') {\n        return '<span title=\"' + escapeHTML(element.name) + '\" class=\"group\">' + escapeHTML(element.displayname + ' ' + t('files_external', '(Group)')) + '</span>';\n      } else {\n        return '<span title=\"' + escapeHTML(element.name) + '\" class=\"user\">' + escapeHTML(element.displayname) + '</span>';\n      }\n    },\n    escapeMarkup(m) {\n      return m;\n    } // we escape the markup in formatResult and formatSelection\n  }).on('select2-loaded', function () {\n    $.each($('.avatardiv'), function (i, div) {\n      const $div = $(div);\n      if ($div.data('type') === 'user') {\n        $div.avatar($div.data('name'), 32);\n      }\n    });\n  }).on('change', function (event) {\n    highlightBorder($(event.target).closest('.applicableUsersContainer').find('.select2-choices'), !event.val.length);\n  });\n}\n\n/**\n * @param id\n * @class OCA.Files_External.Settings.StorageConfig\n *\n * @classdesc External storage config\n */\nconst StorageConfig = function (id) {\n  this.id = id;\n  this.backendOptions = {};\n};\n// Keep this in sync with \\OCA\\Files_External\\MountConfig::STATUS_*\nStorageConfig.Status = {\n  IN_PROGRESS: -1,\n  SUCCESS: 0,\n  ERROR: 1,\n  INDETERMINATE: 2\n};\nStorageConfig.Visibility = {\n  NONE: 0,\n  PERSONAL: 1,\n  ADMIN: 2,\n  DEFAULT: 3\n};\n/**\n * @memberof OCA.Files_External.Settings\n */\nStorageConfig.prototype = {\n  _url: null,\n  /**\n   * Storage id\n   *\n   * @type int\n   */\n  id: null,\n  /**\n   * Mount point\n   *\n   * @type string\n   */\n  mountPoint: '',\n  /**\n   * Backend\n   *\n   * @type string\n   */\n  backend: null,\n  /**\n   * Authentication mechanism\n   *\n   * @type string\n   */\n  authMechanism: null,\n  /**\n   * Backend-specific configuration\n   *\n   * @type Object.<string,object>\n   */\n  backendOptions: null,\n  /**\n   * Mount-specific options\n   *\n   * @type Object.<string,object>\n   */\n  mountOptions: null,\n  /**\n   * Creates or saves the storage.\n   *\n   * @param {Function} [options.success] success callback, receives result as argument\n   * @param {Function} [options.error] error callback\n   * @param options\n   */\n  save(options) {\n    let url = OC.generateUrl(this._url);\n    let method = 'POST';\n    if (_.isNumber(this.id)) {\n      method = 'PUT';\n      url = OC.generateUrl(this._url + '/{id}', {\n        id: this.id\n      });\n    }\n    this._save(method, url, options);\n  },\n  /**\n   * Private implementation of the save function (called after potential password confirmation)\n   * @param {string} method\n   * @param {string} url\n   * @param {{success: Function, error: Function}} options\n   */\n  async _save(method, url, options) {\n    try {\n      const response = await axios.request({\n        confirmPassword: PwdConfirmationMode.Strict,\n        method,\n        url,\n        data: this.getData()\n      });\n      const result = response.data;\n      this.id = result.id;\n      options.success(result);\n    } catch (error) {\n      options.error(error);\n    }\n  },\n  /**\n   * Returns the data from this object\n   *\n   * @return {Array} JSON array of the data\n   */\n  getData() {\n    const data = {\n      mountPoint: this.mountPoint,\n      backend: this.backend,\n      authMechanism: this.authMechanism,\n      backendOptions: this.backendOptions,\n      testOnly: true\n    };\n    if (this.id) {\n      data.id = this.id;\n    }\n    if (this.mountOptions) {\n      data.mountOptions = this.mountOptions;\n    }\n    return data;\n  },\n  /**\n   * Recheck the storage\n   *\n   * @param {Function} [options.success] success callback, receives result as argument\n   * @param {Function} [options.error] error callback\n   * @param options\n   */\n  recheck(options) {\n    if (!_.isNumber(this.id)) {\n      if (_.isFunction(options.error)) {\n        options.error();\n      }\n      return;\n    }\n    $.ajax({\n      type: 'GET',\n      url: OC.generateUrl(this._url + '/{id}', {\n        id: this.id\n      }),\n      data: {\n        testOnly: true\n      },\n      success: options.success,\n      error: options.error\n    });\n  },\n  /**\n   * Deletes the storage\n   *\n   * @param {Function} [options.success] success callback\n   * @param {Function} [options.error] error callback\n   * @param options\n   */\n  async destroy(options) {\n    if (!_.isNumber(this.id)) {\n      // the storage hasn't even been created => success\n      if (_.isFunction(options.success)) {\n        options.success();\n      }\n      return;\n    }\n    try {\n      await axios.request({\n        method: 'DELETE',\n        url: OC.generateUrl(this._url + '/{id}', {\n          id: this.id\n        }),\n        confirmPassword: PwdConfirmationMode.Strict\n      });\n      options.success();\n    } catch (e) {\n      options.error(e);\n    }\n  },\n  /**\n   * Validate this model\n   *\n   * @return {boolean} false if errors exist, true otherwise\n   */\n  validate() {\n    if (this.mountPoint === '') {\n      return false;\n    }\n    if (!this.backend) {\n      return false;\n    }\n    if (this.errors) {\n      return false;\n    }\n    return true;\n  }\n};\n\n/**\n * @param id\n * @class OCA.Files_External.Settings.GlobalStorageConfig\n * @augments OCA.Files_External.Settings.StorageConfig\n *\n * @classdesc Global external storage config\n */\nconst GlobalStorageConfig = function (id) {\n  this.id = id;\n  this.applicableUsers = [];\n  this.applicableGroups = [];\n};\n/**\n * @memberOf OCA.Files_External.Settings\n */\nGlobalStorageConfig.prototype = _.extend({}, StorageConfig.prototype, /** @lends OCA.Files_External.Settings.GlobalStorageConfig.prototype */{\n  _url: 'apps/files_external/globalstorages',\n  /**\n   * Applicable users\n   *\n   * @type Array.<string>\n   */\n  applicableUsers: null,\n  /**\n   * Applicable groups\n   *\n   * @type Array.<string>\n   */\n  applicableGroups: null,\n  /**\n   * Storage priority\n   *\n   * @type int\n   */\n  priority: null,\n  /**\n   * Returns the data from this object\n   *\n   * @return {Array} JSON array of the data\n   */\n  getData() {\n    const data = StorageConfig.prototype.getData.apply(this, arguments);\n    return _.extend(data, {\n      applicableUsers: this.applicableUsers,\n      applicableGroups: this.applicableGroups,\n      priority: this.priority\n    });\n  }\n});\n\n/**\n * @param id\n * @class OCA.Files_External.Settings.UserStorageConfig\n * @augments OCA.Files_External.Settings.StorageConfig\n *\n * @classdesc User external storage config\n */\nconst UserStorageConfig = function (id) {\n  this.id = id;\n};\nUserStorageConfig.prototype = _.extend({}, StorageConfig.prototype, /** @lends OCA.Files_External.Settings.UserStorageConfig.prototype */{\n  _url: 'apps/files_external/userstorages'\n});\n\n/**\n * @param id\n * @class OCA.Files_External.Settings.UserGlobalStorageConfig\n * @augments OCA.Files_External.Settings.StorageConfig\n *\n * @classdesc User external storage config\n */\nconst UserGlobalStorageConfig = function (id) {\n  this.id = id;\n};\nUserGlobalStorageConfig.prototype = _.extend({}, StorageConfig.prototype, /** @lends OCA.Files_External.Settings.UserStorageConfig.prototype */{\n  _url: 'apps/files_external/userglobalstorages'\n});\n\n/**\n * @class OCA.Files_External.Settings.MountOptionsDropdown\n *\n * @classdesc Dropdown for mount options\n *\n * @param {object} $container container DOM object\n */\nconst MountOptionsDropdown = function () {};\n/**\n * @memberof OCA.Files_External.Settings\n */\nMountOptionsDropdown.prototype = {\n  /**\n   * Dropdown element\n   *\n   * @member Object\n   */\n  $el: null,\n  /**\n   * Show dropdown\n   *\n   * @param {object} $container container\n   * @param {object} mountOptions mount options\n   * @param {Array} visibleOptions enabled mount options\n   */\n  show($container, mountOptions, visibleOptions) {\n    if (MountOptionsDropdown._last) {\n      MountOptionsDropdown._last.hide();\n    }\n    const $el = $(OCA.Files_External.Templates.mountOptionsDropDown({\n      mountOptionsEncodingLabel: t('files_external', 'Compatibility with Mac NFD encoding (slow)'),\n      mountOptionsEncryptLabel: t('files_external', 'Enable encryption'),\n      mountOptionsPreviewsLabel: t('files_external', 'Enable previews'),\n      mountOptionsSharingLabel: t('files_external', 'Enable sharing'),\n      mountOptionsFilesystemCheckLabel: t('files_external', 'Check for changes'),\n      mountOptionsFilesystemCheckOnce: t('files_external', 'Never'),\n      mountOptionsFilesystemCheckDA: t('files_external', 'Once every direct access'),\n      mountOptionsReadOnlyLabel: t('files_external', 'Read only'),\n      deleteLabel: t('files_external', 'Disconnect')\n    }));\n    this.$el = $el;\n    const storage = $container[0].parentNode.className;\n    this.setOptions(mountOptions, visibleOptions, storage);\n    this.$el.appendTo($container);\n    MountOptionsDropdown._last = this;\n    this.$el.trigger('show');\n  },\n  hide() {\n    if (this.$el) {\n      this.$el.trigger('hide');\n      this.$el.remove();\n      this.$el = null;\n      MountOptionsDropdown._last = null;\n    }\n  },\n  /**\n   * Returns the mount options from the dropdown controls\n   *\n   * @return {object} options mount options\n   */\n  getOptions() {\n    const options = {};\n    this.$el.find('input, select').each(function () {\n      const $this = $(this);\n      const key = $this.attr('name');\n      let value = null;\n      if ($this.attr('type') === 'checkbox') {\n        value = $this.prop('checked');\n      } else {\n        value = $this.val();\n      }\n      if ($this.attr('data-type') === 'int') {\n        value = parseInt(value, 10);\n      }\n      options[key] = value;\n    });\n    return options;\n  },\n  /**\n   * Sets the mount options to the dropdown controls\n   *\n   * @param {object} options mount options\n   * @param {Array} visibleOptions enabled mount options\n   * @param storage\n   */\n  setOptions(options, visibleOptions, storage) {\n    if (storage === 'owncloud') {\n      const ind = visibleOptions.indexOf('encrypt');\n      if (ind > 0) {\n        visibleOptions.splice(ind, 1);\n      }\n    }\n    const $el = this.$el;\n    _.each(options, function (value, key) {\n      const $optionEl = $el.find('input, select').filterAttr('name', key);\n      if ($optionEl.attr('type') === 'checkbox') {\n        if (_.isString(value)) {\n          value = value === 'true';\n        }\n        $optionEl.prop('checked', !!value);\n      } else {\n        $optionEl.val(value);\n      }\n    });\n    $el.find('.optionRow').each(function (i, row) {\n      const $row = $(row);\n      const optionId = $row.find('input, select').attr('name');\n      if (visibleOptions.indexOf(optionId) === -1 && !$row.hasClass('persistent')) {\n        $row.hide();\n      } else {\n        $row.show();\n      }\n    });\n  }\n};\n\n/**\n * @class OCA.Files_External.Settings.MountConfigListView\n *\n * @classdesc Mount configuration list view\n *\n * @param {object} $el DOM object containing the list\n * @param {object} [options]\n * @param {number} [options.userListLimit] page size in applicable users dropdown\n */\nconst MountConfigListView = function ($el, options) {\n  this.initialize($el, options);\n};\nMountConfigListView.ParameterFlags = {\n  OPTIONAL: 1,\n  USER_PROVIDED: 2,\n  HIDDEN: 4\n};\nMountConfigListView.ParameterTypes = {\n  TEXT: 0,\n  BOOLEAN: 1,\n  PASSWORD: 2\n};\n\n/**\n * @memberOf OCA.Files_External.Settings\n */\nMountConfigListView.prototype = _.extend({\n  /**\n   * jQuery element containing the config list\n   *\n   * @type Object\n   */\n  $el: null,\n  /**\n   * Storage config class\n   *\n   * @type Class\n   */\n  _storageConfigClass: null,\n  /**\n   * Flag whether the list is about user storage configs (true)\n   * or global storage configs (false)\n   *\n   * @type bool\n   */\n  _isPersonal: false,\n  /**\n   * Page size in applicable users dropdown\n   *\n   * @type int\n   */\n  _userListLimit: 30,\n  /**\n   * List of supported backends\n   *\n   * @type Object.<string,Object>\n   */\n  _allBackends: null,\n  /**\n   * List of all supported authentication mechanisms\n   *\n   * @type Object.<string,Object>\n   */\n  _allAuthMechanisms: null,\n  _encryptionEnabled: false,\n  /**\n   * @param {object} $el DOM object containing the list\n   * @param {object} [options]\n   * @param {number} [options.userListLimit] page size in applicable users dropdown\n   */\n  initialize($el, options) {\n    this.$el = $el;\n    this._isPersonal = $el.data('admin') !== true;\n    if (this._isPersonal) {\n      this._storageConfigClass = OCA.Files_External.Settings.UserStorageConfig;\n    } else {\n      this._storageConfigClass = OCA.Files_External.Settings.GlobalStorageConfig;\n    }\n    if (options && !_.isUndefined(options.userListLimit)) {\n      this._userListLimit = options.userListLimit;\n    }\n    this._encryptionEnabled = options.encryptionEnabled;\n    this._canCreateLocal = options.canCreateLocal;\n\n    // read the backend config that was carefully crammed\n    // into the data-configurations attribute of the select\n    this._allBackends = this.$el.find('.selectBackend').data('configurations');\n    this._allAuthMechanisms = this.$el.find('#addMountPoint .authentication').data('mechanisms');\n    this._initEvents();\n  },\n  /**\n   * Custom JS event handlers\n   * Trigger callback for all existing configurations\n   * @param callback\n   */\n  whenSelectBackend(callback) {\n    this.$el.find('tbody tr:not(#addMountPoint):not(.externalStorageLoading)').each(function (i, tr) {\n      const backend = $(tr).find('.backend').data('identifier');\n      callback($(tr), backend);\n    });\n    this.on('selectBackend', callback);\n  },\n  whenSelectAuthMechanism(callback) {\n    const self = this;\n    this.$el.find('tbody tr:not(#addMountPoint):not(.externalStorageLoading)').each(function (i, tr) {\n      const authMechanism = $(tr).find('.selectAuthMechanism').val();\n      callback($(tr), authMechanism, self._allAuthMechanisms[authMechanism].scheme);\n    });\n    this.on('selectAuthMechanism', callback);\n  },\n  /**\n   * Initialize DOM event handlers\n   */\n  _initEvents() {\n    const self = this;\n    const onChangeHandler = _.bind(this._onChange, this);\n    // this.$el.on('input', 'td input', onChangeHandler);\n    this.$el.on('keyup', 'td input', onChangeHandler);\n    this.$el.on('paste', 'td input', onChangeHandler);\n    this.$el.on('change', 'td input:checkbox', onChangeHandler);\n    this.$el.on('change', '.applicable', onChangeHandler);\n    this.$el.on('click', '.status>span', function () {\n      self.recheckStorageConfig($(this).closest('tr'));\n    });\n    this.$el.on('click', 'td.mountOptionsToggle .icon-delete', function () {\n      self.deleteStorageConfig($(this).closest('tr'));\n    });\n    this.$el.on('click', 'td.save>.icon-checkmark', function () {\n      self.saveStorageConfig($(this).closest('tr'));\n    });\n    this.$el.on('click', 'td.mountOptionsToggle>.icon-more', function () {\n      $(this).attr('aria-expanded', 'true');\n      self._showMountOptionsDropdown($(this).closest('tr'));\n    });\n    this.$el.on('change', '.selectBackend', _.bind(this._onSelectBackend, this));\n    this.$el.on('change', '.selectAuthMechanism', _.bind(this._onSelectAuthMechanism, this));\n    this.$el.on('change', '.applicableToAllUsers', _.bind(this._onChangeApplicableToAllUsers, this));\n  },\n  _onChange(event) {\n    const $target = $(event.target);\n    if ($target.closest('.dropdown').length) {\n      // ignore dropdown events\n      return;\n    }\n    highlightInput($target);\n    const $tr = $target.closest('tr');\n    this.updateStatus($tr, null);\n  },\n  _onSelectBackend(event) {\n    const $target = $(event.target);\n    let $tr = $target.closest('tr');\n    const storageConfig = new this._storageConfigClass();\n    storageConfig.mountPoint = $tr.find('.mountPoint input').val();\n    storageConfig.backend = $target.val();\n    $tr.find('.mountPoint input').val('');\n    $tr.find('.selectBackend').prop('selectedIndex', 0);\n    const onCompletion = jQuery.Deferred();\n    $tr = this.newStorage(storageConfig, onCompletion);\n    $tr.find('.applicableToAllUsers').prop('checked', false).trigger('change');\n    onCompletion.resolve();\n    $tr.find('td.configuration').children().not('[type=hidden]').first().focus();\n    this.saveStorageConfig($tr);\n  },\n  _onSelectAuthMechanism(event) {\n    const $target = $(event.target);\n    const $tr = $target.closest('tr');\n    const authMechanism = $target.val();\n    const onCompletion = jQuery.Deferred();\n    this.configureAuthMechanism($tr, authMechanism, onCompletion);\n    onCompletion.resolve();\n    this.saveStorageConfig($tr);\n  },\n  _onChangeApplicableToAllUsers(event) {\n    const $target = $(event.target);\n    const $tr = $target.closest('tr');\n    const checked = $target.is(':checked');\n    $tr.find('.applicableUsersContainer').toggleClass('hidden', checked);\n    if (!checked) {\n      $tr.find('.applicableUsers').select2('val', '', true);\n    }\n    this.saveStorageConfig($tr);\n  },\n  /**\n   * Configure the storage config with a new authentication mechanism\n   *\n   * @param {jQuery} $tr config row\n   * @param {string} authMechanism\n   * @param {jQuery.Deferred} onCompletion\n   */\n  configureAuthMechanism($tr, authMechanism, onCompletion) {\n    const authMechanismConfiguration = this._allAuthMechanisms[authMechanism];\n    const $td = $tr.find('td.configuration');\n    $td.find('.auth-param').remove();\n    $.each(authMechanismConfiguration.configuration, _.partial(this.writeParameterInput, $td, _, _, ['auth-param']).bind(this));\n    this.trigger('selectAuthMechanism', $tr, authMechanism, authMechanismConfiguration.scheme, onCompletion);\n  },\n  /**\n   * Create a config row for a new storage\n   *\n   * @param {StorageConfig} storageConfig storage config to pull values from\n   * @param {jQuery.Deferred} onCompletion\n   * @param {boolean} deferAppend\n   * @return {jQuery} created row\n   */\n  newStorage(storageConfig, onCompletion, deferAppend) {\n    let mountPoint = storageConfig.mountPoint;\n    let backend = this._allBackends[storageConfig.backend];\n    if (!backend) {\n      backend = {\n        name: 'Unknown: ' + storageConfig.backend,\n        invalid: true\n      };\n    }\n\n    // FIXME: Replace with a proper Handlebar template\n    const $template = this.$el.find('tr#addMountPoint');\n    const $tr = $template.clone();\n    if (!deferAppend) {\n      $tr.insertBefore($template);\n    }\n    $tr.data('storageConfig', storageConfig);\n    $tr.show();\n    $tr.find('td.mountOptionsToggle, td.save, td.remove').removeClass('hidden');\n    $tr.find('td').last().removeAttr('style');\n    $tr.removeAttr('id');\n    $tr.find('select#selectBackend');\n    if (!deferAppend) {\n      initApplicableUsersMultiselect($tr.find('.applicableUsers'), this._userListLimit);\n    }\n    if (storageConfig.id) {\n      $tr.data('id', storageConfig.id);\n    }\n    $tr.find('.backend').text(backend.name);\n    if (mountPoint === '') {\n      mountPoint = this._suggestMountPoint(backend.name);\n    }\n    $tr.find('.mountPoint input').val(mountPoint);\n    $tr.addClass(backend.identifier);\n    $tr.find('.backend').data('identifier', backend.identifier);\n    if (backend.invalid || backend.identifier === 'local' && !this._canCreateLocal) {\n      $tr.find('[name=mountPoint]').prop('disabled', true);\n      $tr.find('.applicable,.mountOptionsToggle').empty();\n      $tr.find('.save').empty();\n      if (backend.invalid) {\n        this.updateStatus($tr, false, t('files_external', 'Unknown backend: {backendName}', {\n          backendName: backend.name\n        }));\n      }\n      return $tr;\n    }\n    const selectAuthMechanism = $('<select class=\"selectAuthMechanism\"></select>');\n    const neededVisibility = this._isPersonal ? StorageConfig.Visibility.PERSONAL : StorageConfig.Visibility.ADMIN;\n    $.each(this._allAuthMechanisms, function (authIdentifier, authMechanism) {\n      if (backend.authSchemes[authMechanism.scheme] && authMechanism.visibility & neededVisibility) {\n        selectAuthMechanism.append($('<option value=\"' + authMechanism.identifier + '\" data-scheme=\"' + authMechanism.scheme + '\">' + authMechanism.name + '</option>'));\n      }\n    });\n    if (storageConfig.authMechanism) {\n      selectAuthMechanism.val(storageConfig.authMechanism);\n    } else {\n      storageConfig.authMechanism = selectAuthMechanism.val();\n    }\n    $tr.find('td.authentication').append(selectAuthMechanism);\n    const $td = $tr.find('td.configuration');\n    $.each(backend.configuration, _.partial(this.writeParameterInput, $td).bind(this));\n    this.trigger('selectBackend', $tr, backend.identifier, onCompletion);\n    this.configureAuthMechanism($tr, storageConfig.authMechanism, onCompletion);\n    if (storageConfig.backendOptions) {\n      $td.find('input, select').each(function () {\n        const input = $(this);\n        const val = storageConfig.backendOptions[input.data('parameter')];\n        if (val !== undefined) {\n          if (input.is('input:checkbox')) {\n            input.prop('checked', val);\n          }\n          input.val(storageConfig.backendOptions[input.data('parameter')]);\n          highlightInput(input);\n        }\n      });\n    }\n    let applicable = [];\n    if (storageConfig.applicableUsers) {\n      applicable = applicable.concat(storageConfig.applicableUsers);\n    }\n    if (storageConfig.applicableGroups) {\n      applicable = applicable.concat(_.map(storageConfig.applicableGroups, function (group) {\n        return group + '(group)';\n      }));\n    }\n    if (applicable.length) {\n      $tr.find('.applicableUsers').val(applicable).trigger('change');\n      $tr.find('.applicableUsersContainer').removeClass('hidden');\n    } else {\n      // applicable to all\n      $tr.find('.applicableUsersContainer').addClass('hidden');\n    }\n    $tr.find('.applicableToAllUsers').prop('checked', !applicable.length);\n    const priorityEl = $('<input type=\"hidden\" class=\"priority\" value=\"' + backend.priority + '\" />');\n    $tr.append(priorityEl);\n    if (storageConfig.mountOptions) {\n      $tr.find('input.mountOptions').val(JSON.stringify(storageConfig.mountOptions));\n    } else {\n      // FIXME default backend mount options\n      $tr.find('input.mountOptions').val(JSON.stringify({\n        encrypt: true,\n        previews: true,\n        enable_sharing: false,\n        filesystem_check_changes: 1,\n        encoding_compatibility: false,\n        readonly: false\n      }));\n    }\n    return $tr;\n  },\n  /**\n   * Load storages into config rows\n   */\n  loadStorages() {\n    const self = this;\n    const onLoaded1 = $.Deferred();\n    const onLoaded2 = $.Deferred();\n    this.$el.find('.externalStorageLoading').removeClass('hidden');\n    $.when(onLoaded1, onLoaded2).always(() => {\n      self.$el.find('.externalStorageLoading').addClass('hidden');\n    });\n    if (this._isPersonal) {\n      // load userglobal storages\n      $.ajax({\n        type: 'GET',\n        url: OC.generateUrl('apps/files_external/userglobalstorages'),\n        data: {\n          testOnly: true\n        },\n        contentType: 'application/json',\n        success(result) {\n          result = Object.values(result);\n          const onCompletion = jQuery.Deferred();\n          let $rows = $();\n          result.forEach(function (storageParams) {\n            let storageConfig;\n            const isUserGlobal = storageParams.type === 'system' && self._isPersonal;\n            storageParams.mountPoint = storageParams.mountPoint.substr(1); // trim leading slash\n            if (isUserGlobal) {\n              storageConfig = new UserGlobalStorageConfig();\n            } else {\n              storageConfig = new self._storageConfigClass();\n            }\n            _.extend(storageConfig, storageParams);\n            const $tr = self.newStorage(storageConfig, onCompletion, true);\n\n            // userglobal storages must be at the top of the list\n            $tr.detach();\n            self.$el.prepend($tr);\n            const $authentication = $tr.find('.authentication');\n            $authentication.text($authentication.find('select option:selected').text());\n\n            // disable any other inputs\n            $tr.find('.mountOptionsToggle, .remove').empty();\n            $tr.find('input:not(.user_provided), select:not(.user_provided)').attr('disabled', 'disabled');\n            if (isUserGlobal) {\n              $tr.find('.configuration').find(':not(.user_provided)').remove();\n            } else {\n              // userglobal storages do not expose configuration data\n              $tr.find('.configuration').text(t('files_external', 'Admin defined'));\n            }\n\n            // don't recheck config automatically when there are a large number of storages\n            if (result.length < 20) {\n              self.recheckStorageConfig($tr);\n            } else {\n              self.updateStatus($tr, StorageConfig.Status.INDETERMINATE, t('files_external', 'Automatic status checking is disabled due to the large number of configured storages, click to check status'));\n            }\n            $rows = $rows.add($tr);\n          });\n          initApplicableUsersMultiselect(self.$el.find('.applicableUsers'), this._userListLimit);\n          self.$el.find('tr#addMountPoint').before($rows);\n          const mainForm = $('#files_external');\n          if (result.length === 0 && mainForm.attr('data-can-create') === 'false') {\n            mainForm.hide();\n            $('a[href=\"#external-storage\"]').parent().hide();\n            $('.emptycontent').show();\n          }\n          onCompletion.resolve();\n          onLoaded1.resolve();\n        }\n      });\n    } else {\n      onLoaded1.resolve();\n    }\n    const url = this._storageConfigClass.prototype._url;\n    $.ajax({\n      type: 'GET',\n      url: OC.generateUrl(url),\n      contentType: 'application/json',\n      success(result) {\n        result = Object.values(result);\n        const onCompletion = jQuery.Deferred();\n        let $rows = $();\n        result.forEach(function (storageParams) {\n          storageParams.mountPoint = storageParams.mountPoint === '/' ? '/' : storageParams.mountPoint.substr(1); // trim leading slash\n          const storageConfig = new self._storageConfigClass();\n          _.extend(storageConfig, storageParams);\n          const $tr = self.newStorage(storageConfig, onCompletion, true);\n\n          // don't recheck config automatically when there are a large number of storages\n          if (result.length < 20) {\n            self.recheckStorageConfig($tr);\n          } else {\n            self.updateStatus($tr, StorageConfig.Status.INDETERMINATE, t('files_external', 'Automatic status checking is disabled due to the large number of configured storages, click to check status'));\n          }\n          $rows = $rows.add($tr);\n        });\n        initApplicableUsersMultiselect($rows.find('.applicableUsers'), this._userListLimit);\n        self.$el.find('tr#addMountPoint').before($rows);\n        onCompletion.resolve();\n        onLoaded2.resolve();\n      }\n    });\n  },\n  /**\n   * @param {jQuery} $td\n   * @param {string} parameter\n   * @param {string} placeholder\n   * @param {Array} classes\n   * @return {jQuery} newly created input\n   */\n  writeParameterInput($td, parameter, placeholder, classes) {\n    const hasFlag = function (flag) {\n      return (placeholder.flags & flag) === flag;\n    };\n    classes = $.isArray(classes) ? classes : [];\n    classes.push('added');\n    if (hasFlag(MountConfigListView.ParameterFlags.OPTIONAL)) {\n      classes.push('optional');\n    }\n    if (hasFlag(MountConfigListView.ParameterFlags.USER_PROVIDED)) {\n      if (this._isPersonal) {\n        classes.push('user_provided');\n      } else {\n        return;\n      }\n    }\n    let newElement;\n    const trimmedPlaceholder = placeholder.value;\n    if (hasFlag(MountConfigListView.ParameterFlags.HIDDEN)) {\n      newElement = $('<input type=\"hidden\" class=\"' + classes.join(' ') + '\" data-parameter=\"' + parameter + '\" />');\n    } else if (placeholder.type === MountConfigListView.ParameterTypes.PASSWORD) {\n      newElement = $('<input type=\"password\" class=\"' + classes.join(' ') + '\" data-parameter=\"' + parameter + '\" placeholder=\"' + trimmedPlaceholder + '\" />');\n    } else if (placeholder.type === MountConfigListView.ParameterTypes.BOOLEAN) {\n      const checkboxId = _.uniqueId('checkbox_');\n      newElement = $('<div><label><input type=\"checkbox\" id=\"' + checkboxId + '\" class=\"' + classes.join(' ') + '\" data-parameter=\"' + parameter + '\" />' + trimmedPlaceholder + '</label></div>');\n    } else {\n      newElement = $('<input type=\"text\" class=\"' + classes.join(' ') + '\" data-parameter=\"' + parameter + '\" placeholder=\"' + trimmedPlaceholder + '\" />');\n    }\n    if (placeholder.defaultValue) {\n      if (placeholder.type === MountConfigListView.ParameterTypes.BOOLEAN) {\n        newElement.find('input').prop('checked', placeholder.defaultValue);\n      } else {\n        newElement.val(placeholder.defaultValue);\n      }\n    }\n    if (placeholder.tooltip) {\n      newElement.attr('title', placeholder.tooltip);\n    }\n    highlightInput(newElement);\n    $td.append(newElement);\n    return newElement;\n  },\n  /**\n   * Gets the storage model from the given row\n   *\n   * @param $tr row element\n   * @return {OCA.Files_External.StorageConfig} storage model instance\n   */\n  getStorageConfig($tr) {\n    let storageId = $tr.data('id');\n    if (!storageId) {\n      // new entry\n      storageId = null;\n    }\n    let storage = $tr.data('storageConfig');\n    if (!storage) {\n      storage = new this._storageConfigClass(storageId);\n    }\n    storage.errors = null;\n    storage.mountPoint = $tr.find('.mountPoint input').val();\n    storage.backend = $tr.find('.backend').data('identifier');\n    storage.authMechanism = $tr.find('.selectAuthMechanism').val();\n    const classOptions = {};\n    const configuration = $tr.find('.configuration input');\n    const missingOptions = [];\n    $.each(configuration, function (index, input) {\n      const $input = $(input);\n      const parameter = $input.data('parameter');\n      if ($input.attr('type') === 'button') {\n        return;\n      }\n      if (!isInputValid($input) && !$input.hasClass('optional')) {\n        missingOptions.push(parameter);\n        return;\n      }\n      if ($(input).is(':checkbox')) {\n        if ($(input).is(':checked')) {\n          classOptions[parameter] = true;\n        } else {\n          classOptions[parameter] = false;\n        }\n      } else {\n        classOptions[parameter] = $(input).val();\n      }\n    });\n    storage.backendOptions = classOptions;\n    if (missingOptions.length) {\n      storage.errors = {\n        backendOptions: missingOptions\n      };\n    }\n\n    // gather selected users and groups\n    if (!this._isPersonal) {\n      const multiselect = getSelectedApplicable($tr);\n      const users = multiselect.users || [];\n      const groups = multiselect.groups || [];\n      const isApplicableToAllUsers = $tr.find('.applicableToAllUsers').is(':checked');\n      if (isApplicableToAllUsers) {\n        storage.applicableUsers = [];\n        storage.applicableGroups = [];\n      } else {\n        storage.applicableUsers = users;\n        storage.applicableGroups = groups;\n        if (!storage.applicableUsers.length && !storage.applicableGroups.length) {\n          if (!storage.errors) {\n            storage.errors = {};\n          }\n          storage.errors.requiredApplicable = true;\n        }\n      }\n      storage.priority = parseInt($tr.find('input.priority').val() || '100', 10);\n    }\n    const mountOptions = $tr.find('input.mountOptions').val();\n    if (mountOptions) {\n      storage.mountOptions = JSON.parse(mountOptions);\n    }\n    return storage;\n  },\n  /**\n   * Deletes the storage from the given tr\n   *\n   * @param $tr storage row\n   * @param Function callback callback to call after save\n   */\n  deleteStorageConfig($tr) {\n    const self = this;\n    const configId = $tr.data('id');\n    if (!_.isNumber(configId)) {\n      // deleting unsaved storage\n      $tr.remove();\n      return;\n    }\n    const storage = new this._storageConfigClass(configId);\n    OC.dialogs.confirm(t('files_external', 'Are you sure you want to disconnect this external storage? It will make the storage unavailable in Nextcloud and will lead to a deletion of these files and folders on any sync client that is currently connected but will not delete any files and folders on the external storage itself.', {\n      storage: this.mountPoint\n    }), t('files_external', 'Delete storage?'), function (confirm) {\n      if (confirm) {\n        self.updateStatus($tr, StorageConfig.Status.IN_PROGRESS);\n        storage.destroy({\n          success() {\n            $tr.remove();\n          },\n          error(result) {\n            const statusMessage = result && result.responseJSON ? result.responseJSON.message : undefined;\n            self.updateStatus($tr, StorageConfig.Status.ERROR, statusMessage);\n          }\n        });\n      }\n    });\n  },\n  /**\n   * Saves the storage from the given tr\n   *\n   * @param $tr storage row\n   * @param Function callback callback to call after save\n   * @param callback\n   * @param concurrentTimer only update if the timer matches this\n   */\n  saveStorageConfig($tr, callback, concurrentTimer) {\n    const self = this;\n    const storage = this.getStorageConfig($tr);\n    if (!storage || !storage.validate()) {\n      return false;\n    }\n    this.updateStatus($tr, StorageConfig.Status.IN_PROGRESS);\n    storage.save({\n      success(result) {\n        if (concurrentTimer === undefined || $tr.data('save-timer') === concurrentTimer) {\n          self.updateStatus($tr, result.status, result.statusMessage);\n          $tr.data('id', result.id);\n          if (_.isFunction(callback)) {\n            callback(storage);\n          }\n        }\n      },\n      error(result) {\n        if (concurrentTimer === undefined || $tr.data('save-timer') === concurrentTimer) {\n          const statusMessage = result && result.responseJSON ? result.responseJSON.message : undefined;\n          self.updateStatus($tr, StorageConfig.Status.ERROR, statusMessage);\n        }\n      }\n    });\n  },\n  /**\n   * Recheck storage availability\n   *\n   * @param {jQuery} $tr storage row\n   * @return {boolean} success\n   */\n  recheckStorageConfig($tr) {\n    const self = this;\n    const storage = this.getStorageConfig($tr);\n    if (!storage.validate()) {\n      return false;\n    }\n    this.updateStatus($tr, StorageConfig.Status.IN_PROGRESS);\n    storage.recheck({\n      success(result) {\n        self.updateStatus($tr, result.status, result.statusMessage);\n      },\n      error(result) {\n        const statusMessage = result && result.responseJSON ? result.responseJSON.message : undefined;\n        self.updateStatus($tr, StorageConfig.Status.ERROR, statusMessage);\n      }\n    });\n  },\n  /**\n   * Update status display\n   *\n   * @param {jQuery} $tr\n   * @param {number} status\n   * @param {string} message\n   */\n  updateStatus($tr, status, message) {\n    const $statusSpan = $tr.find('.status span');\n    switch (status) {\n      case null:\n        // remove status\n        $statusSpan.hide();\n        break;\n      case StorageConfig.Status.IN_PROGRESS:\n        $statusSpan.attr('class', 'icon-loading-small');\n        break;\n      case StorageConfig.Status.SUCCESS:\n        $statusSpan.attr('class', 'success icon-checkmark-white');\n        break;\n      case StorageConfig.Status.INDETERMINATE:\n        $statusSpan.attr('class', 'indeterminate icon-info-white');\n        break;\n      default:\n        $statusSpan.attr('class', 'error icon-error-white');\n    }\n    if (status !== null) {\n      $statusSpan.show();\n    }\n    if (typeof message !== 'string') {\n      message = t('files_external', 'Click to recheck the configuration');\n    }\n    $statusSpan.attr('title', message);\n  },\n  /**\n   * Suggest mount point name that doesn't conflict with the existing names in the list\n   *\n   * @param {string} defaultMountPoint default name\n   */\n  _suggestMountPoint(defaultMountPoint) {\n    const $el = this.$el;\n    const pos = defaultMountPoint.indexOf('/');\n    if (pos !== -1) {\n      defaultMountPoint = defaultMountPoint.substring(0, pos);\n    }\n    defaultMountPoint = defaultMountPoint.replace(/\\s+/g, '');\n    let i = 1;\n    let append = '';\n    let match = true;\n    while (match && i < 20) {\n      match = false;\n      $el.find('tbody td.mountPoint input').each(function (index, mountPoint) {\n        if ($(mountPoint).val() === defaultMountPoint + append) {\n          match = true;\n          return false;\n        }\n      });\n      if (match) {\n        append = i;\n        i++;\n      } else {\n        break;\n      }\n    }\n    return defaultMountPoint + append;\n  },\n  /**\n   * Toggles the mount options dropdown\n   *\n   * @param {object} $tr configuration row\n   */\n  _showMountOptionsDropdown($tr) {\n    const self = this;\n    const storage = this.getStorageConfig($tr);\n    const $toggle = $tr.find('.mountOptionsToggle');\n    const dropDown = new MountOptionsDropdown();\n    const visibleOptions = ['previews', 'filesystem_check_changes', 'enable_sharing', 'encoding_compatibility', 'readonly', 'delete'];\n    if (this._encryptionEnabled) {\n      visibleOptions.push('encrypt');\n    }\n    dropDown.show($toggle, storage.mountOptions || [], visibleOptions);\n    $('body').on('mouseup.mountOptionsDropdown', function (event) {\n      const $target = $(event.target);\n      if ($target.closest('.popovermenu').length) {\n        return;\n      }\n      dropDown.hide();\n    });\n    dropDown.$el.on('hide', function () {\n      const mountOptions = dropDown.getOptions();\n      $('body').off('mouseup.mountOptionsDropdown');\n      $tr.find('input.mountOptions').val(JSON.stringify(mountOptions));\n      $tr.find('td.mountOptionsToggle>.icon-more').attr('aria-expanded', 'false');\n      self.saveStorageConfig($tr);\n    });\n  }\n}, OC.Backbone.Events);\nwindow.addEventListener('DOMContentLoaded', function () {\n  const enabled = $('#files_external').attr('data-encryption-enabled');\n  const canCreateLocal = $('#files_external').attr('data-can-create-local');\n  const encryptionEnabled = enabled === 'true';\n  const mountConfigListView = new MountConfigListView($('#externalStorage'), {\n    encryptionEnabled,\n    canCreateLocal: canCreateLocal === 'true'\n  });\n  mountConfigListView.loadStorages();\n\n  // TODO: move this into its own View class\n  const $allowUserMounting = $('#allowUserMounting');\n  $allowUserMounting.bind('change', function () {\n    OC.msg.startSaving('#userMountingMsg');\n    if (this.checked) {\n      OCP.AppConfig.setValue('files_external', 'allow_user_mounting', 'yes');\n      $('input[name=\"allowUserMountingBackends\\\\[\\\\]\"]').prop('checked', true);\n      $('#userMountingBackends').removeClass('hidden');\n      $('input[name=\"allowUserMountingBackends\\\\[\\\\]\"]').eq(0).trigger('change');\n    } else {\n      OCP.AppConfig.setValue('files_external', 'allow_user_mounting', 'no');\n      $('#userMountingBackends').addClass('hidden');\n    }\n    OC.msg.finishedSaving('#userMountingMsg', {\n      status: 'success',\n      data: {\n        message: t('files_external', 'Saved')\n      }\n    });\n  });\n  $('input[name=\"allowUserMountingBackends\\\\[\\\\]\"]').bind('change', function () {\n    OC.msg.startSaving('#userMountingMsg');\n    let userMountingBackends = $('input[name=\"allowUserMountingBackends\\\\[\\\\]\"]:checked').map(function () {\n      return $(this).val();\n    }).get();\n    const deprecatedBackends = $('input[name=\"allowUserMountingBackends\\\\[\\\\]\"][data-deprecate-to]').map(function () {\n      if ($.inArray($(this).data('deprecate-to'), userMountingBackends) !== -1) {\n        return $(this).val();\n      }\n      return null;\n    }).get();\n    userMountingBackends = userMountingBackends.concat(deprecatedBackends);\n    OCP.AppConfig.setValue('files_external', 'user_mounting_backends', userMountingBackends.join());\n    OC.msg.finishedSaving('#userMountingMsg', {\n      status: 'success',\n      data: {\n        message: t('files_external', 'Saved')\n      }\n    });\n\n    // disable allowUserMounting\n    if (userMountingBackends.length === 0) {\n      $allowUserMounting.prop('checked', false);\n      $allowUserMounting.trigger('change');\n    }\n  });\n  $('#global_credentials').on('submit', async function (event) {\n    event.preventDefault();\n    const $form = $(this);\n    const $submit = $form.find('[type=submit]');\n    $submit.val(t('files_external', 'Saving …'));\n    const uid = $form.find('[name=uid]').val();\n    const user = $form.find('[name=username]').val();\n    const password = $form.find('[name=password]').val();\n    try {\n      await axios.request({\n        method: 'POST',\n        data: {\n          uid,\n          user,\n          password\n        },\n        url: generateUrl('apps/files_external/globalcredentials'),\n        confirmPassword: PwdConfirmationMode.Strict\n      });\n      $submit.val(t('files_external', 'Saved'));\n      setTimeout(function () {\n        $submit.val(t('files_external', 'Save'));\n      }, 2500);\n    } catch (error) {\n      $submit.val(t('files_external', 'Save'));\n      if (isAxiosError(error)) {\n        const message = error.response?.data?.message || t('files_external', 'Failed to save global credentials');\n        showError(t('files_external', 'Failed to save global credentials: {message}', {\n          message\n        }));\n      }\n    }\n    return false;\n  });\n\n  // global instance\n  OCA.Files_External.Settings.mountConfig = mountConfigListView;\n\n  /**\n   * Legacy\n   *\n   * @namespace\n   * @deprecated use OCA.Files_External.Settings.mountConfig instead\n   */\n  OC.MountConfig = {\n    saveStorage: _.bind(mountConfigListView.saveStorageConfig, mountConfigListView)\n  };\n});\n\n// export\n\nOCA.Files_External = OCA.Files_External || {};\n/**\n * @namespace\n */\nOCA.Files_External.Settings = OCA.Files_External.Settings || {};\nOCA.Files_External.Settings.GlobalStorageConfig = GlobalStorageConfig;\nOCA.Files_External.Settings.UserStorageConfig = UserStorageConfig;\nOCA.Files_External.Settings.MountConfigListView = MountConfigListView;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \"-\" + chunkId + \".js?v=\" + {\"node_modules_nextcloud_dialogs_dist_chunks_index-BC-7VPxC_mjs\":\"0a21f85fb5edb886fad0\",\"node_modules_nextcloud_dialogs_dist_chunks_PublicAuthPrompt-BSFsDqYB_mjs\":\"5414d4143400c9b713c3\",\"data_image_svg_xml_3c_21--_20-_20SPDX-FileCopyrightText_202020_20Google_20Inc_20-_20SPDX-Lice-391a6e\":\"87f84948225387ac2eec\"}[chunkId] + \"\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"nextcloud:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/^blob:/, \"\").replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"files_external-settings\": 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunknextcloud\"] = self[\"webpackChunknextcloud\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","__webpack_require__.nc = undefined;","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"core-common\"], () => (__webpack_require__(\"./apps/files_external/src/settings.js\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}