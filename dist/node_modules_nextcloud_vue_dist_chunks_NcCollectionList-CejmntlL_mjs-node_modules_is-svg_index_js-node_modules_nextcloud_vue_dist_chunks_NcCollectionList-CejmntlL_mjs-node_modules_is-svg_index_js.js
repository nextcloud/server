(globalThis["webpackChunknextcloud_ui_legacy"] = globalThis["webpackChunknextcloud_ui_legacy"] || []).push([["node_modules_nextcloud_vue_dist_chunks_NcCollectionList-CejmntlL_mjs-node_modules_is-svg_index_js"],{

/***/ "./node_modules/@file-type/xml/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@file-type/xml/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   XmlTextDetector: () => (/* binding */ XmlTextDetector),
/* harmony export */   detectXml: () => (/* binding */ detectXml),
/* harmony export */   isXml: () => (/* binding */ isXml)
/* harmony export */ });
/* harmony import */ var sax__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sax */ "./node_modules/sax/lib/sax.js");

function startsWith(array, prefix) {
    if (prefix.length > array.length) {
        return false;
    }
    for (let i = 0; i < prefix.length; i++) {
        if (array[i] !== prefix[i]) {
            return false;
        }
    }
    return true;
}
function hasXmlTag(xmlString) {
    return /^<\s*\w+(?=\s+[^<>]*=|>)/.test(xmlString);
}
function hasArrayXmlTag(array, encoding) {
    const textDecoder = new TextDecoder(encoding);
    return hasXmlTag(textDecoder.decode(array));
}
function isXml(array) {
    if (startsWith(array, [60, 63, 120, 109, 108, 32])) {
        return { xml: true, encoding: 'utf-8', offset: 0 };
    }
    if (startsWith(array, [0xEF, 0xBB, 0xBF])) { // UTF-8 BOM
        const encoding = 'utf-8';
        if (startsWith(array.subarray(3), [60, 63, 120, 109, 108, 32]) || hasArrayXmlTag(array, encoding)) {
            return { xml: true, encoding, offset: 3 };
        }
    }
    if (startsWith(array, [0xFE, 0xFF])) {
        const encoding = 'utf-16be';
        if (startsWith(array.subarray(2), [0, 60, 0, 63, 0, 120, 0, 109, 0, 108, 0, 32]) || hasArrayXmlTag(array, encoding)) {
            return { xml: true, encoding, offset: 2 };
        }
    }
    if (startsWith(array, [0xFF, 0xFE])) {
        const encoding = 'utf-16le';
        if (startsWith(array.subarray(2), [60, 0, 63, 0, 120, 0, 109, 0, 108, 0, 32, 0]) || hasArrayXmlTag(array, encoding)) {
            return { xml: true, encoding, offset: 2 };
        }
        return { xml: true, encoding: 'utf-16le', offset: 2 };
    }
    if (startsWith(array, [0, 60, 0, 63, 0, 120, 0, 109, 0, 108, 0, 32])) {
        return { xml: true, encoding: 'utf-16be', offset: 0 };
    }
    if (startsWith(array, [60, 0, 63, 0, 120, 0, 109, 0, 108, 0, 32, 0])) {
        return { xml: true, encoding: 'utf-16le', offset: 0 };
    }
    if (hasArrayXmlTag(array, 'utf-8')) {
        return { xml: true, encoding: 'utf-8', offset: 0 };
    }
    return { xml: false };
}
/**
 * Maps the root element namespace to corresponding file-type
 */
const namespaceMapping = {
    'http://www.w3.org/2000/svg': {
        ext: 'svg',
        mime: 'image/svg+xml'
    },
    'http://www.w3.org/1999/xhtml': {
        ext: 'xhtml',
        mime: 'application/xhtml+xml'
    },
    'http://www.opengis.net/kml/2.2': {
        ext: 'kml',
        mime: 'application/vnd.google-earth.kml+xml'
    },
    'http://www.opengis.net/gml': {
        ext: 'gml',
        mime: 'application/gml+xml'
    }
};
/**
 * Maps the root element name to corresponding file-type.
 * Used for Non-namespaced XML
 * @type {{rss: {ext: string, mime: string}}}
 */
const rootNameMapping = {
    rss: {
        ext: 'rss',
        mime: 'application/rss+xml'
    },
    'score-partwise': {
        ext: 'musicxml',
        mime: 'application/vnd.recordare.musicxml+xml'
    },
    svg: {
        ext: 'svg',
        mime: 'image/svg+xml'
    }
};
class XmlTextDetector {
    constructor(options) {
        this.options = options ?? {};
        this.firstTag = true;
        this.onEnd = false;
        this.parser = sax__WEBPACK_IMPORTED_MODULE_0__.parser(true, { xmlns: true });
        this.nesting = 0;
        this.parser.onerror = e => {
            if (e.message.startsWith('Invalid character entity')) { // Allow entity reference
                return;
            }
            this.fileType = undefined;
            this.onEnd = true;
        };
        this.parser.onopentag = node => {
            ++this.nesting;
            if (!this.firstTag || this.onEnd) {
                return;
            }
            this.firstTag = false;
            if (node.uri) {
                // Resolve file-type boot root element namespace
                this.fileType = namespaceMapping[node.uri];
            }
            else if (node.name) {
                // Fall back on element name if there is no namespace
                this.fileType = rootNameMapping[node.name.toLowerCase()];
            }
            if (this.fileType && !this.options.fullScan) {
                this.onEnd = true;
            }
        };
        this.parser.onclosetag = () => {
            --this.nesting;
        };
    }
    write(text) {
        this.parser.write(text);
    }
    close() {
        this.parser.close();
        this.onEnd = true;
    }
    isValid() {
        return this.nesting === 0;
    }
}
const detectXml = {
    id: 'xml',
    detect: async (tokenizer) => {
        const buffer = new Uint8Array(512);
        // Increase sample size from 12 to 256.
        await tokenizer.peekBuffer(buffer, { length: 128, mayBeLess: true });
        const xmlDetection = isXml(buffer);
        if (xmlDetection.xml) {
            await tokenizer.ignore(xmlDetection.offset);
            const xmlTextDetector = new XmlTextDetector();
            const textDecoder = new TextDecoder(xmlDetection.encoding);
            do {
                const len = await tokenizer.readBuffer(buffer, { mayBeLess: true });
                const portion = buffer.subarray(0, len);
                const text = textDecoder.decode(portion);
                xmlTextDetector.write(text);
                if (len < buffer.length) {
                    xmlTextDetector.close();
                }
            } while (!xmlTextDetector.onEnd);
            return xmlTextDetector.fileType ?? {
                ext: 'xml',
                mime: 'application/xml'
            };
        }
    }
};


/***/ }),

/***/ "./node_modules/@nextcloud/vue/dist/assets/NcCollectionList-hRgvNUMR.css":
/*!*******************************************************************************!*\
  !*** ./node_modules/@nextcloud/vue/dist/assets/NcCollectionList-hRgvNUMR.css ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../../style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../../style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../../style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_NcCollectionList_hRgvNUMR_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../../css-loader/dist/cjs.js!./NcCollectionList-hRgvNUMR.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/@nextcloud/vue/dist/assets/NcCollectionList-hRgvNUMR.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_NcCollectionList_hRgvNUMR_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_NcCollectionList_hRgvNUMR_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_NcCollectionList_hRgvNUMR_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_NcCollectionList_hRgvNUMR_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/@nextcloud/vue/dist/chunks/NcCollectionList-CejmntlL.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@nextcloud/vue/dist/chunks/NcCollectionList-CejmntlL.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   N: () => (/* binding */ NcCollectionList)
/* harmony export */ });
/* harmony import */ var _assets_NcCollectionList_hRgvNUMR_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assets/NcCollectionList-hRgvNUMR.css */ "./node_modules/@nextcloud/vue/dist/assets/NcCollectionList-hRgvNUMR.css");
/* harmony import */ var debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debounce */ "./node_modules/@nextcloud/vue/node_modules/debounce/index.js");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");
/* harmony import */ var _l10n_D3tJt_gL_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_l10n-D3tJt_gL.mjs */ "./node_modules/@nextcloud/vue/dist/chunks/_l10n-D3tJt_gL.mjs");
/* harmony import */ var _NcActionButton_CECxOkhK_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NcActionButton-CECxOkhK.mjs */ "./node_modules/@nextcloud/vue/dist/chunks/NcActionButton-CECxOkhK.mjs");
/* harmony import */ var _NcActions_C_CwY6XQ_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./NcActions-C-CwY6XQ.mjs */ "./node_modules/@nextcloud/vue/dist/chunks/NcActions-C-CwY6XQ.mjs");
/* harmony import */ var _NcAvatar_4h0wo9uv_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./NcAvatar-4h0wo9uv.mjs */ "./node_modules/@nextcloud/vue/dist/chunks/NcAvatar-4h0wo9uv.mjs");
/* harmony import */ var _autolink_D2pIbi92_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./autolink-D2pIbi92.mjs */ "./node_modules/@nextcloud/vue/dist/chunks/autolink-D2pIbi92.mjs");
/* harmony import */ var _plugin_vue2_normalizer_DU4iP6Vu_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_plugin-vue2_normalizer-DU4iP6Vu.mjs */ "./node_modules/@nextcloud/vue/dist/chunks/_plugin-vue2_normalizer-DU4iP6Vu.mjs");
/* harmony import */ var _logger_D3RVzcfQ_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./logger-D3RVzcfQ.mjs */ "./node_modules/@nextcloud/vue/dist/chunks/logger-D3RVzcfQ.mjs");
/* harmony import */ var _NcSelect_CkB50N9T_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./NcSelect-CkB50N9T.mjs */ "./node_modules/@nextcloud/vue/dist/chunks/NcSelect-CkB50N9T.mjs");
/* harmony import */ var _nextcloud_axios__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @nextcloud/axios */ "./node_modules/@nextcloud/axios/dist/index.mjs");
/* harmony import */ var _nextcloud_router__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @nextcloud/router */ "./node_modules/@nextcloud/router/dist/index.mjs");













(0,_l10n_D3tJt_gL_mjs__WEBPACK_IMPORTED_MODULE_3__.r)(_l10n_D3tJt_gL_mjs__WEBPACK_IMPORTED_MODULE_3__.K);
const _sfc_main$1 = {
  name: "NcCollectionListItem",
  components: {
    NcAvatar: _NcAvatar_4h0wo9uv_mjs__WEBPACK_IMPORTED_MODULE_6__.N,
    NcActions: _NcActions_C_CwY6XQ_mjs__WEBPACK_IMPORTED_MODULE_5__.N,
    NcActionButton: _NcActionButton_CECxOkhK_mjs__WEBPACK_IMPORTED_MODULE_4__.N
  },
  props: {
    /**
     * The collection
     */
    collection: {
      type: Object,
      default: null
    },
    /**
     * Current error if any
     */
    error: {
      type: String,
      default: void 0
    }
  },
  emits: ["remove-resource", "rename-collection"],
  data() {
    return {
      detailsOpen: false,
      newName: null
    };
  },
  computed: {
    getIcon() {
      return (resource) => [resource.iconClass];
    },
    typeClass() {
      return (resource) => "resource-type-" + resource.type;
    },
    resources() {
      return this.collection.resources?.filter((resource) => !Array.isArray(resource)) ?? [];
    },
    getComponent() {
      return (resource) => {
        const route = (0,_autolink_D2pIbi92_mjs__WEBPACK_IMPORTED_MODULE_7__.g)(this.$router, resource.link);
        return route ? { component: "router-link", to: route, href: void 0 } : { component: "a", to: void 0, href: resource.link };
      };
    },
    iconUrl() {
      return (resource) => {
        if (resource.mimetype) {
          return OC.MimeType.getIconUrl(resource.mimetype);
        }
        if (resource.iconUrl) {
          return resource.iconUrl;
        }
        return "";
      };
    }
  },
  methods: {
    t: _l10n_D3tJt_gL_mjs__WEBPACK_IMPORTED_MODULE_3__.a,
    toggleDetails() {
      this.detailsOpen = !this.detailsOpen;
    },
    showDetails() {
      this.detailsOpen = true;
    },
    removeResource(collection, resource) {
      this.$emit("remove-resource", {
        collectionId: collection.id,
        resourceType: resource.type,
        resourceId: resource.id
      });
    },
    openRename() {
      this.newName = this.collection.name;
    },
    renameCollection() {
      if (this.newName) {
        this.$emit("rename-collection", {
          collectionId: this.collection.id,
          name: this.newName
        });
      }
      this.newName = null;
    }
  }
};
var _sfc_render$1 = function render() {
  var _vm = this, _c = _vm._self._c;
  return _c("li", { staticClass: "collection-list-item" }, [_c("NcAvatar", { staticClass: "collection-avatar", attrs: { "display-name": _vm.collection.name, "allow-placeholder": "" } }), _vm.newName === null ? _c("span", { staticClass: "collection-item-name", attrs: { "title": "" }, on: { "click": _vm.showDetails } }, [_vm._v(_vm._s(_vm.collection.name))]) : _c("form", { class: { "should-shake": _vm.error }, on: { "submit": function($event) {
    $event.preventDefault();
    return _vm.renameCollection.apply(null, arguments);
  } } }, [_c("input", { directives: [{ name: "model", rawName: "v-model", value: _vm.newName, expression: "newName" }], attrs: { "type": "text", "autocomplete": "off", "autocapitalize": "off" }, domProps: { "value": _vm.newName }, on: { "input": function($event) {
    if ($event.target.composing) return;
    _vm.newName = $event.target.value;
  } } }), _c("input", { staticClass: "icon-confirm", attrs: { "type": "submit", "value": "" } })]), !_vm.detailsOpen && _vm.newName === null ? _c("div", { staticClass: "linked-icons" }, _vm._l(_vm.resources.slice(0, 2), function(resource) {
    return _c(_vm.getComponent(resource).component, { key: resource.type + "|" + resource.id, tag: "component", class: _vm.typeClass(resource), attrs: { "title": resource.name, "to": _vm.getComponent(resource).to, "href": _vm.getComponent(resource).href } }, [_c("img", { attrs: { "src": _vm.iconUrl(resource), "alt": resource.name } })]);
  }), 1) : _vm._e(), _vm.newName === null ? _c("span", { staticClass: "sharingOptionsGroup" }, [_c("NcActions", [_c("NcActionButton", { attrs: { "icon": "icon-info" }, on: { "click": function($event) {
    $event.preventDefault();
    return _vm.toggleDetails.apply(null, arguments);
  } } }, [_vm._v(" " + _vm._s(_vm.detailsOpen ? _vm.t("Hide details") : _vm.t("Show details")) + " ")]), _c("NcActionButton", { attrs: { "icon": "icon-rename" }, on: { "click": function($event) {
    $event.preventDefault();
    return _vm.openRename.apply(null, arguments);
  } } }, [_vm._v(" " + _vm._s(_vm.t("Rename project")) + " ")])], 1)], 1) : _vm._e(), _c("transition", { attrs: { "name": "fade" } }, [_vm.error ? _c("div", { staticClass: "error" }, [_vm._v(" " + _vm._s(_vm.error) + " ")]) : _vm._e()]), _c("transition", { attrs: { "name": "fade" } }, [_vm.detailsOpen ? _c("ul", { staticClass: "resource-list-details" }, _vm._l(_vm.resources, function(resource) {
    return _c("li", { key: resource.type + "|" + resource.id, class: _vm.typeClass(resource) }, [_c(_vm.getComponent(resource).component, { tag: "component", attrs: { "to": _vm.getComponent(resource).to, "href": _vm.getComponent(resource).href } }, [_c("img", { attrs: { "src": _vm.iconUrl(resource), "alt": resource.name } }), _c("span", { staticClass: "resource-name" }, [_vm._v(_vm._s(resource.name || ""))])]), _c("span", { staticClass: "icon-close", on: { "click": function($event) {
      return _vm.removeResource(_vm.collection, resource);
    } } })], 1);
  }), 0) : _vm._e()])], 1);
};
var _sfc_staticRenderFns$1 = [];
var __component__$1 = /* @__PURE__ */ (0,_plugin_vue2_normalizer_DU4iP6Vu_mjs__WEBPACK_IMPORTED_MODULE_8__.n)(
  _sfc_main$1,
  _sfc_render$1,
  _sfc_staticRenderFns$1,
  false,
  null,
  "88468fab"
);
const NcCollectionListItem = __component__$1.exports;
(0,_l10n_D3tJt_gL_mjs__WEBPACK_IMPORTED_MODULE_3__.r)(_l10n_D3tJt_gL_mjs__WEBPACK_IMPORTED_MODULE_3__.L);
function extractOcsData(response) {
  return response.data.ocs.data;
}
function renameCollectionService(collectionId, collectionName) {
  return _nextcloud_axios__WEBPACK_IMPORTED_MODULE_11__["default"].put((0,_nextcloud_router__WEBPACK_IMPORTED_MODULE_12__.generateOcsUrl)("collaboration/resources/collections/{collectionId}", { collectionId }), { collectionName }).then(extractOcsData);
}
function getCollectionsByResourceService(resourceType, resourceId) {
  return _nextcloud_axios__WEBPACK_IMPORTED_MODULE_11__["default"].get((0,_nextcloud_router__WEBPACK_IMPORTED_MODULE_12__.generateOcsUrl)("collaboration/resources/{resourceType}/{resourceId}", { resourceType, resourceId })).then(extractOcsData);
}
function createCollectionService(resourceType, resourceId, name) {
  return _nextcloud_axios__WEBPACK_IMPORTED_MODULE_11__["default"].post((0,_nextcloud_router__WEBPACK_IMPORTED_MODULE_12__.generateOcsUrl)("collaboration/resources/{resourceType}/{resourceId}", { resourceType, resourceId }), { name }).then(extractOcsData);
}
function addResourceService(collectionId, resourceType, resourceId) {
  return _nextcloud_axios__WEBPACK_IMPORTED_MODULE_11__["default"].post((0,_nextcloud_router__WEBPACK_IMPORTED_MODULE_12__.generateOcsUrl)("collaboration/resources/collections/{collectionId}", { collectionId }), { resourceType, resourceId }).then(extractOcsData);
}
function removeResourceService(collectionId, resourceType, resourceId) {
  return _nextcloud_axios__WEBPACK_IMPORTED_MODULE_11__["default"].delete((0,_nextcloud_router__WEBPACK_IMPORTED_MODULE_12__.generateOcsUrl)("collaboration/resources/collections/{collectionId}", { collectionId }), { params: { resourceType, resourceId } }).then(extractOcsData);
}
function searchService(query) {
  return _nextcloud_axios__WEBPACK_IMPORTED_MODULE_11__["default"].get((0,_nextcloud_router__WEBPACK_IMPORTED_MODULE_12__.generateOcsUrl)("collaboration/resources/collections/search/{query}", { query })).then(extractOcsData);
}
function useCollections() {
  const storedCollections = (0,vue__WEBPACK_IMPORTED_MODULE_2__.ref)([]);
  const addCollections = (collections) => {
    (0,vue__WEBPACK_IMPORTED_MODULE_2__.set)(storedCollections, "value", collections);
  };
  const addCollection = (collection) => {
    (0,vue__WEBPACK_IMPORTED_MODULE_2__.set)(storedCollections, "value", [...storedCollections.value, collection]);
  };
  const removeCollection = (collectionId) => {
    (0,vue__WEBPACK_IMPORTED_MODULE_2__.set)(storedCollections, "value", storedCollections.value.filter((item) => item.id !== collectionId));
  };
  const updateCollection = (collection) => {
    const index = storedCollections.value.findIndex((item) => item.id === collection.id);
    if (index !== -1) {
      (0,vue__WEBPACK_IMPORTED_MODULE_2__.set)(storedCollections.value, index, collection);
    } else {
      addCollection(collection);
    }
  };
  const fetchCollectionsByResource = async ({ resourceType, resourceId }) => {
    const collections = await getCollectionsByResourceService(resourceType, resourceId);
    addCollections(collections);
  };
  const createCollection = async ({ baseResourceType, baseResourceId, resourceType, resourceId, name }) => {
    const collection = await createCollectionService(baseResourceType, baseResourceId, name);
    addCollection(collection);
    await addResourceToCollection({
      collectionId: collection.id,
      resourceType,
      resourceId
    });
  };
  const renameCollection = async ({ collectionId, name }) => {
    const collection = await renameCollectionService(collectionId, name);
    updateCollection(collection);
  };
  async function addResourceToCollection({ collectionId, resourceType, resourceId }) {
    const collection = await addResourceService(collectionId, resourceType, String(resourceId));
    updateCollection(collection);
  }
  const removeResourceFromCollection = async ({ collectionId, resourceType, resourceId }) => {
    const collection = await removeResourceService(collectionId, resourceType, String(resourceId));
    if (collection.resources.length > 0) {
      updateCollection(collection);
    } else {
      removeCollection(collectionId);
    }
  };
  return {
    storedCollections,
    fetchCollectionsByResource,
    createCollection,
    renameCollection,
    addResourceToCollection,
    removeResourceFromCollection
  };
}
const METHOD_CREATE_COLLECTION = 0;
const METHOD_ADD_TO_COLLECTION = 1;
const _sfc_main = {
  name: "NcCollectionList",
  components: {
    NcCollectionListItem,
    NcAvatar: _NcAvatar_4h0wo9uv_mjs__WEBPACK_IMPORTED_MODULE_6__.N,
    NcSelect: _NcSelect_CkB50N9T_mjs__WEBPACK_IMPORTED_MODULE_10__.N
  },
  props: {
    /**
     * Resource type identifier
     */
    type: {
      type: String,
      default: null
    },
    /**
     * Unique id of the resource
     */
    id: {
      type: String,
      default: null
    },
    /**
     * Name of the resource
     */
    name: {
      type: String,
      default: ""
    },
    /**
     * Whether the component is active (to start fetch resources)
     */
    isActive: {
      type: Boolean,
      // eslint-disable-next-line vue/no-boolean-default
      default: true
    }
  },
  setup() {
    const {
      storedCollections,
      fetchCollectionsByResource,
      createCollection,
      addResourceToCollection,
      removeResourceFromCollection,
      renameCollection
    } = useCollections();
    const searchCollections = (0,vue__WEBPACK_IMPORTED_MODULE_2__.ref)([]);
    const search = debounce__WEBPACK_IMPORTED_MODULE_1__(function(query, loading) {
      if (query !== "") {
        loading(true);
        searchService(query).then((collections) => {
          searchCollections.value = collections;
        }).catch((error) => {
          _logger_D3RVzcfQ_mjs__WEBPACK_IMPORTED_MODULE_9__.l.error("Failed to search for collections", { error });
        }).finally(() => {
          loading(false);
        });
      }
    }, 500);
    return {
      storedCollections,
      fetchCollectionsByResource,
      createCollection,
      addResourceToCollection,
      removeResourceFromCollection,
      renameCollection,
      searchCollections,
      search
    };
  },
  data() {
    return {
      selectIsOpen: false,
      generatingCodes: false,
      codes: void 0,
      value: null,
      model: {},
      collectionsError: {},
      error: null,
      isSelectOpen: false
    };
  },
  computed: {
    collections() {
      return this.storedCollections.filter((collection) => collection.resources.some((resource) => resource && resource.id === String(this.id) && resource.type === this.type));
    },
    placeholder() {
      return this.isSelectOpen ? (0,_l10n_D3tJt_gL_mjs__WEBPACK_IMPORTED_MODULE_3__.a)("Type to search for existing projects") : (0,_l10n_D3tJt_gL_mjs__WEBPACK_IMPORTED_MODULE_3__.a)("Add to a project");
    },
    options() {
      const options = [];
      window.OCP.Collaboration.getTypes().sort().forEach((type) => {
        options.push({
          method: METHOD_CREATE_COLLECTION,
          type,
          title: window.OCP.Collaboration.getLabel(type),
          class: window.OCP.Collaboration.getIcon(type),
          action: () => window.OCP.Collaboration.trigger(type)
        });
      });
      for (const index in this.searchCollections) {
        if (!this.collections.find((collection) => collection.id === this.searchCollections[index].id)) {
          options.push({
            method: METHOD_ADD_TO_COLLECTION,
            title: this.searchCollections[index].name,
            collectionId: this.searchCollections[index].id
          });
        }
      }
      return options;
    },
    resourceIdentifier() {
      return {
        resourceType: this.type,
        resourceId: this.id,
        isActive: this.isActive
      };
    }
  },
  watch: {
    resourceIdentifier: {
      deep: true,
      immediate: true,
      handler(resourceIdentifier) {
        if (!resourceIdentifier.isActive || !resourceIdentifier.resourceId || !resourceIdentifier.resourceType) {
          return;
        }
        this.fetchCollectionsByResource(resourceIdentifier);
      }
    }
  },
  methods: {
    t: _l10n_D3tJt_gL_mjs__WEBPACK_IMPORTED_MODULE_3__.a,
    select(selectedOption) {
      if (selectedOption.method === METHOD_CREATE_COLLECTION) {
        selectedOption.action().then((resourceId) => {
          this.createCollection({
            baseResourceType: this.type,
            baseResourceId: this.id,
            resourceType: selectedOption.type,
            resourceId,
            name: this.name
          }).catch((e) => {
            this.setError((0,_l10n_D3tJt_gL_mjs__WEBPACK_IMPORTED_MODULE_3__.a)("Failed to create a project"), e);
          });
        }).catch((error) => {
          _logger_D3RVzcfQ_mjs__WEBPACK_IMPORTED_MODULE_9__.l.error("No resource selected", { error });
        });
      }
      if (selectedOption.method === METHOD_ADD_TO_COLLECTION) {
        this.addResourceToCollection({
          collectionId: selectedOption.collectionId,
          resourceType: this.type,
          resourceId: this.id
        }).catch((e) => {
          this.setError((0,_l10n_D3tJt_gL_mjs__WEBPACK_IMPORTED_MODULE_3__.a)("Failed to add the item to the project"), e);
        });
      }
      this.value = null;
    },
    showSelect() {
      this.selectIsOpen = true;
      this.$refs.select.$el.focus();
    },
    setError(error, e) {
      _logger_D3RVzcfQ_mjs__WEBPACK_IMPORTED_MODULE_9__.l.error(error, { error: e });
      this.error = error;
      setTimeout(() => {
        this.error = null;
      }, 5e3);
    },
    renameCollectionFromItem({ collectionId, name }) {
      this.renameCollection({ collectionId, name }).catch((error) => {
        _logger_D3RVzcfQ_mjs__WEBPACK_IMPORTED_MODULE_9__.l.error((0,_l10n_D3tJt_gL_mjs__WEBPACK_IMPORTED_MODULE_3__.a)("Failed to rename the project"), { error });
        this.collectionsError[collectionId] = (0,_l10n_D3tJt_gL_mjs__WEBPACK_IMPORTED_MODULE_3__.a)("Failed to rename the project");
        setTimeout(() => {
          this.collectionsError[collectionId] = null;
        }, 5e3);
      });
    }
  }
};
var _sfc_render = function render2() {
  var _vm = this, _c = _vm._self._c;
  return _vm.collections && _vm.type && _vm.id ? _c("ul", { staticClass: "collection-list", attrs: { "id": "collection-list" } }, [_c("li", { on: { "click": _vm.showSelect } }, [_vm._m(0), _c("div", { attrs: { "id": "collection-select-container" } }, [_c("NcSelect", { ref: "select", attrs: { "aria-label-combobox": _vm.t("Add to a project"), "options": _vm.options, "placeholder": _vm.placeholder, "label": "title", "limit": 5 }, on: { "close": function($event) {
    _vm.isSelectOpen = false;
  }, "open": function($event) {
    _vm.isSelectOpen = true;
  }, "option:selected": _vm.select, "search": _vm.search }, scopedSlots: _vm._u([{ key: "selected-option", fn: function(option) {
    return [_c("span", { staticClass: "option__desc" }, [_c("span", { staticClass: "option__title" }, [_vm._v(_vm._s(option.title))])])];
  } }, { key: "option", fn: function(option) {
    return [_c("span", { staticClass: "option__wrapper" }, [option.class ? _c("span", { staticClass: "avatar", class: option.class }) : option.method !== 2 ? _c("NcAvatar", { attrs: { "allow-placeholder": "", "display-name": option.title } }) : _vm._e(), _c("span", { staticClass: "option__title" }, [_vm._v(_vm._s(option.title))])], 1)];
  } }], null, false, 2397208459), model: { value: _vm.value, callback: function($$v) {
    _vm.value = $$v;
  }, expression: "value" } }, [_c("p", { staticClass: "hint" }, [_vm._v(" " + _vm._s(_vm.t("Connect items to a project to make them easier to find")) + " ")])])], 1)]), _c("transition", { attrs: { "name": "fade" } }, [_vm.error ? _c("li", { staticClass: "error" }, [_vm._v(" " + _vm._s(_vm.error) + " ")]) : _vm._e()]), _vm._l(_vm.collections, function(collection) {
    return _c("NcCollectionListItem", { key: collection.id, attrs: { "collection": collection, "error": _vm.collectionsError[collection.id] }, on: { "rename-collection": _vm.renameCollectionFromItem, "remove-resource": _vm.removeResourceFromCollection } });
  })], 2) : _vm._e();
};
var _sfc_staticRenderFns = [function() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "avatar" }, [_c("span", { staticClass: "icon-projects" })]);
}];
var __component__ = /* @__PURE__ */ (0,_plugin_vue2_normalizer_DU4iP6Vu_mjs__WEBPACK_IMPORTED_MODULE_8__.n)(
  _sfc_main,
  _sfc_render,
  _sfc_staticRenderFns,
  false,
  null,
  "73e5825c"
);
const NcCollectionList = __component__.exports;

//# sourceMappingURL=NcCollectionList-CejmntlL.mjs.map


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/@nextcloud/vue/dist/assets/NcCollectionList-hRgvNUMR.css":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/@nextcloud/vue/dist/assets/NcCollectionList-hRgvNUMR.css ***!
  \*********************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../css-loader/dist/runtime/noSourceMaps.js */ "./node_modules/css-loader/dist/runtime/noSourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-88468fab] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.fade-enter-active[data-v-88468fab], .fade-leave-active[data-v-88468fab] {
  transition: opacity 0.3s ease;
}
.fade-enter[data-v-88468fab], .fade-leave-to[data-v-88468fab] {
  opacity: 0;
}
.linked-icons[data-v-88468fab] {
  display: flex;
}
.linked-icons img[data-v-88468fab] {
  padding: 12px;
  height: 44px;
  display: block;
  background-repeat: no-repeat;
  background-position: center;
  opacity: 0.7;
}
.linked-icons img[data-v-88468fab]:hover {
  opacity: 1;
}
.popovermenu[data-v-88468fab] {
  display: none;
}
.popovermenu.open[data-v-88468fab] {
  display: block;
}
li.collection-list-item[data-v-88468fab] {
  flex-wrap: wrap;
  height: auto;
  cursor: pointer;
  margin-bottom: 0 !important;
}
li.collection-list-item .collection-avatar[data-v-88468fab] {
  margin-top: 0;
}
li.collection-list-item form[data-v-88468fab], li.collection-list-item .collection-item-name[data-v-88468fab] {
  flex-basis: 10%;
  flex-grow: 1;
  display: flex;
}
li.collection-list-item .collection-item-name[data-v-88468fab] {
  padding: 12px 9px;
}
li.collection-list-item input[data-v-88468fab] {
  margin-top: 4px;
  border-color: var(--color-border-maxcontrast);
}
li.collection-list-item input[type=text][data-v-88468fab] {
  flex-grow: 1;
}
li.collection-list-item .error[data-v-88468fab] {
  flex-basis: 100%;
  width: 100%;
}
li.collection-list-item .resource-list-details[data-v-88468fab] {
  flex-basis: 100%;
  width: 100%;
}
li.collection-list-item .resource-list-details li[data-v-88468fab] {
  display: flex;
  margin-left: 44px;
  border-radius: 3px;
  cursor: pointer;
}
li.collection-list-item .resource-list-details li[data-v-88468fab]:hover {
  background-color: var(--color-background-dark);
}
li.collection-list-item .resource-list-details li a[data-v-88468fab] {
  flex-grow: 1;
  padding: 3px;
  max-width: calc(100% - 30px);
  display: flex;
}
li.collection-list-item .resource-list-details span[data-v-88468fab] {
  display: inline-block;
  vertical-align: top;
  margin-right: 10px;
}
li.collection-list-item .resource-list-details span.resource-name[data-v-88468fab] {
  text-overflow: ellipsis;
  overflow: hidden;
  position: relative;
  vertical-align: top;
  white-space: nowrap;
  flex-grow: 1;
  padding: 4px;
}
li.collection-list-item .resource-list-details img[data-v-88468fab] {
  width: 24px;
  height: 24px;
}
li.collection-list-item .resource-list-details .icon-close[data-v-88468fab] {
  opacity: 0.7;
}
li.collection-list-item .resource-list-details .icon-close[data-v-88468fab]:hover, li.collection-list-item .resource-list-details .icon-close[data-v-88468fab]:focus {
  opacity: 1;
}
.should-shake[data-v-88468fab] {
  animation: shake-88468fab 0.6s 1 linear;
}
@keyframes shake-88468fab {
0% {
    transform: translate(15px);
}
20% {
    transform: translate(-15px);
}
40% {
    transform: translate(7px);
}
60% {
    transform: translate(-7px);
}
80% {
    transform: translate(3px);
}
100% {
    transform: translate(0px);
}
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-73e5825c] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.collection-list *[data-v-73e5825c] {
  box-sizing: border-box;
}
.collection-list > li[data-v-73e5825c] {
  display: flex;
  align-items: center;
  gap: 12px;
}
.collection-list > li > .avatar[data-v-73e5825c] {
  margin-top: 0;
}
#collection-select-container[data-v-73e5825c] {
  display: flex;
  flex-direction: column;
}
.v-select span.avatar[data-v-73e5825c] {
  display: block;
  padding: 16px;
  opacity: 0.7;
  background-repeat: no-repeat;
  background-position: center;
}
.v-select span.avatar[data-v-73e5825c]:hover {
  opacity: 1;
}
p.hint[data-v-73e5825c] {
  z-index: 1;
  margin-top: -16px;
  padding: 8px 8px;
  color: var(--color-text-maxcontrast);
  line-height: normal;
}
div.avatar[data-v-73e5825c] {
  width: 32px;
  height: 32px;
  margin: 0;
  padding: 8px;
  background-color: var(--color-background-dark);
  margin-top: 30px;
}

/** TODO provide white icon in core */
.icon-projects[data-v-73e5825c] {
  display: block;
  padding: 8px;
  background-repeat: no-repeat;
  background-position: center;
}
.option__wrapper[data-v-73e5825c] {
  display: flex;
}
.option__wrapper .avatar[data-v-73e5825c] {
  display: block;
  width: 32px;
  height: 32px;
  background-color: var(--color-background-darker) !important;
}
.option__wrapper .option__title[data-v-73e5825c] {
  padding: 4px;
}
.fade-enter-active[data-v-73e5825c], .fade-leave-active[data-v-73e5825c] {
  transition: opacity 0.5s;
}
.fade-enter[data-v-73e5825c], .fade-leave-to[data-v-73e5825c] {
  opacity: 0;
}`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/is-svg/index.js":
/*!**************************************!*\
  !*** ./node_modules/is-svg/index.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isSvg)
/* harmony export */ });
/* harmony import */ var _file_type_xml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @file-type/xml */ "./node_modules/@file-type/xml/lib/index.js");


function isSvg(string, {validate = true} = {}) {
	if (typeof string !== 'string') {
		throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
	}

	string = string.trim();

	if (string.length === 0) {
		return false;
	}

	const xmlTextDetector = new _file_type_xml__WEBPACK_IMPORTED_MODULE_0__.XmlTextDetector({fullScan: validate});

	if (validate) {
		xmlTextDetector.write(string);

		if (!xmlTextDetector.isValid()) {
			return false;
		}
	} else {
		const chunkSize = 128;

		let offset = 0;
		while (string.length > offset && !xmlTextDetector.onEnd) {
			xmlTextDetector.write(string.slice(offset, Math.min(offset + chunkSize, string.length)));
			offset += chunkSize;
		}
	}

	return xmlTextDetector.fileType?.ext === 'svg';
}


/***/ }),

/***/ "./node_modules/sax/lib/sax.js":
/*!*************************************!*\
  !*** ./node_modules/sax/lib/sax.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! ./node_modules/node-polyfill-webpack-plugin/node_modules/buffer/index.js */ "./node_modules/node-polyfill-webpack-plugin/node_modules/buffer/index.js")["Buffer"];
;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // disallow unquoted attribute values if not otherwise configured
    // and strict mode is true
    if (parser.opt.unquotedAttributeValues === undefined) {
      parser.opt.unquotedAttributeValues = !strict;
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = (__webpack_require__(/*! stream */ "./node_modules/stream-browserify/index.js").Stream)
  } catch (ex) {
    Stream = function () {}
  }
  if (!Stream) Stream = function () {}

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = (__webpack_require__(/*! string_decoder */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder)
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace (c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote (c) {
    return c === '"' || c === '\''
  }

  function isAttribEnd (c) {
    return c === '>' || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
            continue;
          }

          if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
            parser.state = S.DOCTYPE_DTD
            parser.doctype += '<!' + parser.sgmlDecl + c
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          if (c === ']') {
            parser.doctype += c
            parser.state = S.DOCTYPE
          } else if (c === '<') {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else if (isQuote(c)) {
            parser.doctype += c
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          } else {
            parser.doctype += c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else if (parser.doctype && parser.doctype !== true) {
            parser.state = S.DOCTYPE_DTD
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            if (!parser.opt.unquotedAttributeValues) {
              error(parser, 'Unquoted attribute value')
            }
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            var parsedEntity = parseEntity(parser)
            if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
              parser.entity = ''
              parser.state = returnState
              parser.write(parsedEntity)
            } else {
              parser[buffer] += parsedEntity
              parser.entity = ''
              parser.state = returnState
            }
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default: /* istanbul ignore next */ {
          throw new Error(parser, 'Unknown state: ' + parser.state)
        }
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})( false ? 0 : exports)


/***/ })

}]);
//# sourceMappingURL=node_modules_nextcloud_vue_dist_chunks_NcCollectionList-CejmntlL_mjs-node_modules_is-svg_index_js-node_modules_nextcloud_vue_dist_chunks_NcCollectionList-CejmntlL_mjs-node_modules_is-svg_index_js.js.map?v=fd80f1bcfbbf9290b15a