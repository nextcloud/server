{"version":3,"file":"settings-vue-settings-apps-users-management.js?v=b2e71e92921058306f8d","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjhCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAkBA;AACA;;;;;;;;;;;;;;;;ACtCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACRA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACvFA;;;;;AEAA;AACA;AACA;AACA;AACA","sources":["webpack:///nextcloud/apps/settings/src/constants/GroupManagement.ts","webpack:///nextcloud/apps/settings/src/logger.ts","webpack:///nextcloud/apps/settings/src/main-apps-users-management.ts","webpack:///nextcloud/apps/settings/src/router/index.ts","webpack:///nextcloud/apps/settings/src/router/routes.ts","webpack:///nextcloud/apps/settings/src/store/api.js","webpack:///nextcloud/apps/settings/src/store/apps.js","webpack:///nextcloud/apps/settings/src/store/index.js","webpack:///nextcloud/apps/settings/src/store/oc.js","webpack:///nextcloud/apps/settings/src/store/users-settings.js","webpack:///nextcloud/apps/settings/src/store/users.js","webpack:///nextcloud/apps/settings/src/utils/sorting.ts","webpack:///nextcloud/apps/settings/src/views/SettingsApp.vue","webpack://nextcloud/./apps/settings/src/views/SettingsApp.vue?c324","webpack://nextcloud/./apps/settings/src/views/SettingsApp.vue?681b","webpack:///nextcloud/apps/settings/src/views/SettingsApp.vue?vue&type=script&setup=true&lang=ts","webpack:///nextcloud/apps/settings/src/views/SettingsApp.vue?vue&type=template&id=21177c05","webpack:///nextcloud/node_modules/vuex-router-sync/index.js","webpack:///nextcloud/webpack/bootstrap","webpack:///nextcloud/webpack/runtime/chunk loaded","webpack:///nextcloud/webpack/runtime/compat get default export","webpack:///nextcloud/webpack/runtime/define property getters","webpack:///nextcloud/webpack/runtime/ensure chunk","webpack:///nextcloud/webpack/runtime/get javascript chunk filename","webpack:///nextcloud/webpack/runtime/global","webpack:///nextcloud/webpack/runtime/hasOwnProperty shorthand","webpack:///nextcloud/webpack/runtime/load script","webpack:///nextcloud/webpack/runtime/make namespace object","webpack:///nextcloud/webpack/runtime/node module decorator","webpack:///nextcloud/webpack/runtime/publicPath","webpack:///nextcloud/webpack/runtime/jsonp chunk loading","webpack:///nextcloud/webpack/runtime/nonce","webpack:///nextcloud/webpack/before-startup","webpack:///nextcloud/webpack/startup","webpack:///nextcloud/webpack/after-startup"],"sourcesContent":["/**\n * SPDX-FileCopyrightText: 2024 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n/**\n * https://github.com/nextcloud/server/blob/208e38e84e1a07a49699aa90dc5b7272d24489f0/lib/private/Group/MetaData.php#L34\n */\nexport var GroupSorting;\n(function (GroupSorting) {\n  GroupSorting[GroupSorting[\"UserCount\"] = 1] = \"UserCount\";\n  GroupSorting[GroupSorting[\"GroupName\"] = 2] = \"GroupName\";\n})(GroupSorting || (GroupSorting = {}));","/**\n * SPDX-FileCopyrightText: 2020 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { getLoggerBuilder } from '@nextcloud/logger';\nexport default getLoggerBuilder().setApp('settings').detectUser().build();","/**\n * SPDX-FileCopyrightText: 2018 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport Vue from 'vue';\nimport Vuex from 'vuex';\nimport VTooltipPlugin from 'v-tooltip';\nimport { sync } from 'vuex-router-sync';\nimport { t, n } from '@nextcloud/l10n';\nimport SettingsApp from \"./views/SettingsApp.vue\";\nimport router from \"./router/index.ts\";\nimport { useStore } from \"./store/index.js\";\nimport { getCSPNonce } from '@nextcloud/auth';\nimport { PiniaVuePlugin, createPinia } from 'pinia';\n// CSP config for webpack dynamic chunk loading\n// eslint-disable-next-line camelcase\n__webpack_nonce__ = getCSPNonce();\n// bind to window\nVue.prototype.t = t;\nVue.prototype.n = n;\nVue.use(PiniaVuePlugin);\nVue.use(VTooltipPlugin, {\n  defaultHtml: false\n});\nVue.use(Vuex);\nconst store = useStore();\nsync(store, router);\nconst pinia = createPinia();\nexport default new Vue({\n  router,\n  store,\n  pinia,\n  render: h => h(SettingsApp),\n  el: '#content'\n});","/**\n * SPDX-FileCopyrightText: 2018 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport Vue from 'vue';\nimport Router from 'vue-router';\nimport { generateUrl } from '@nextcloud/router';\nimport routes from \"./routes.ts\";\nVue.use(Router);\nconst router = new Router({\n  mode: 'history',\n  // if index.php is in the url AND we got this far, then it's working:\n  // let's keep using index.php in the url\n  base: generateUrl(''),\n  linkActiveClass: 'active',\n  routes\n});\nexport default router;","import { loadState } from '@nextcloud/initial-state';\nconst appstoreEnabled = loadState('settings', 'appstoreEnabled', true);\n// Dynamic loading\nconst AppStore = () => import(/* webpackChunkName: 'settings-apps-view' */\"../views/AppStore.vue\");\nconst AppStoreNavigation = () => import(/* webpackChunkName: 'settings-apps-view' */\"../views/AppStoreNavigation.vue\");\nconst AppStoreSidebar = () => import(/* webpackChunkName: 'settings-apps-view' */\"../views/AppStoreSidebar.vue\");\nconst UserManagement = () => import(/* webpackChunkName: 'settings-users' */\"../views/UserManagement.vue\");\nconst UserManagementNavigation = () => import(/* webpackChunkName: 'settings-users' */\"../views/UserManagementNavigation.vue\");\nconst routes = [{\n  name: 'users',\n  path: '/:index(index.php/)?settings/users',\n  components: {\n    default: UserManagement,\n    navigation: UserManagementNavigation\n  },\n  props: true,\n  children: [{\n    path: ':selectedGroup',\n    name: 'group'\n  }]\n}, {\n  path: '/:index(index.php/)?settings/apps',\n  name: 'apps',\n  redirect: {\n    name: 'apps-category',\n    params: {\n      category: appstoreEnabled ? 'discover' : 'installed'\n    }\n  },\n  components: {\n    default: AppStore,\n    navigation: AppStoreNavigation,\n    sidebar: AppStoreSidebar\n  },\n  children: [{\n    path: ':category',\n    name: 'apps-category',\n    children: [{\n      path: ':id',\n      name: 'apps-details'\n    }]\n  }]\n}];\nexport default routes;","/**\n * SPDX-FileCopyrightText: 2018 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport axios from '@nextcloud/axios';\nimport { confirmPassword } from '@nextcloud/password-confirmation';\nimport '@nextcloud/password-confirmation/dist/style.css';\nconst sanitize = function (url) {\n  return url.replace(/\\/$/, ''); // Remove last url slash\n};\nexport default {\n  /**\n   * This Promise is used to chain a request that require an admin password confirmation\n   * Since chaining Promise have a very precise behavior concerning catch and then,\n   * you'll need to be careful when using it.\n   * e.g\n   * // store\n   * action(context) {\n   *   return api.requireAdmin().then((response) => {\n   *     return api.get('url')\n   *       .then((response) => {API success})\n   *       .catch((error) => {API failure});\n   *   }).catch((error) => {requireAdmin failure});\n   * }\n   * // vue\n   * this.$store.dispatch('action').then(() => {always executed})\n   *\n   * Since Promise.then().catch().then() will always execute the last then\n   * this.$store.dispatch('action').then will always be executed\n   *\n   * If you want requireAdmin failure to also catch the API request failure\n   * you will need to throw a new error in the api.get.catch()\n   *\n   * e.g\n   * api.requireAdmin().then((response) => {\n   *   api.get('url')\n   *     .then((response) => {API success})\n   *     .catch((error) => {throw error;});\n   * }).catch((error) => {requireAdmin OR API failure});\n   *\n   * @return {Promise}\n   */\n  requireAdmin() {\n    return confirmPassword();\n  },\n  get(url, options) {\n    return axios.get(sanitize(url), options);\n  },\n  post(url, data) {\n    return axios.post(sanitize(url), data);\n  },\n  patch(url, data) {\n    return axios.patch(sanitize(url), data);\n  },\n  put(url, data) {\n    return axios.put(sanitize(url), data);\n  },\n  delete(url, data) {\n    return axios.delete(sanitize(url), {\n      params: data\n    });\n  }\n};","/**\n * SPDX-FileCopyrightText: 2018 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport api from \"./api.js\";\nimport Vue from 'vue';\nimport axios from '@nextcloud/axios';\nimport { generateUrl } from '@nextcloud/router';\nimport { showError, showInfo } from '@nextcloud/dialogs';\nimport { loadState } from '@nextcloud/initial-state';\nconst state = {\n  apps: [],\n  bundles: loadState('settings', 'appstoreBundles', []),\n  categories: [],\n  updateCount: loadState('settings', 'appstoreUpdateCount', 0),\n  loading: {},\n  gettingCategoriesPromise: null,\n  appApiEnabled: loadState('settings', 'appApiEnabled', false)\n};\nconst mutations = {\n  APPS_API_FAILURE(state, error) {\n    showError(t('settings', 'An error occurred during the request. Unable to proceed.') + '<br>' + error.error.response.data.data.message, {\n      isHTML: true\n    });\n    console.error(state, error);\n  },\n  initCategories(state, _ref) {\n    let {\n      categories,\n      updateCount\n    } = _ref;\n    state.categories = categories;\n    state.updateCount = updateCount;\n  },\n  updateCategories(state, categoriesPromise) {\n    state.gettingCategoriesPromise = categoriesPromise;\n  },\n  setUpdateCount(state, updateCount) {\n    state.updateCount = updateCount;\n  },\n  addCategory(state, category) {\n    state.categories.push(category);\n  },\n  appendCategories(state, categoriesArray) {\n    // convert obj to array\n    state.categories = categoriesArray;\n  },\n  setAllApps(state, apps) {\n    state.apps = apps;\n  },\n  setError(state, _ref2) {\n    let {\n      appId,\n      error\n    } = _ref2;\n    if (!Array.isArray(appId)) {\n      appId = [appId];\n    }\n    appId.forEach(_id => {\n      const app = state.apps.find(app => app.id === _id);\n      app.error = error;\n    });\n  },\n  clearError(state, _ref3) {\n    let {\n      appId,\n      error\n    } = _ref3;\n    const app = state.apps.find(app => app.id === appId);\n    app.error = null;\n  },\n  enableApp(state, _ref4) {\n    let {\n      appId,\n      groups\n    } = _ref4;\n    const app = state.apps.find(app => app.id === appId);\n    app.active = true;\n    app.groups = groups;\n    if (app.id === 'app_api') {\n      state.appApiEnabled = true;\n    }\n  },\n  setInstallState(state, _ref5) {\n    let {\n      appId,\n      canInstall\n    } = _ref5;\n    const app = state.apps.find(app => app.id === appId);\n    if (app) {\n      app.canInstall = canInstall === true;\n    }\n  },\n  disableApp(state, appId) {\n    const app = state.apps.find(app => app.id === appId);\n    app.active = false;\n    app.groups = [];\n    if (app.removable) {\n      app.canUnInstall = true;\n    }\n    if (app.id === 'app_api') {\n      state.appApiEnabled = false;\n    }\n  },\n  uninstallApp(state, appId) {\n    state.apps.find(app => app.id === appId).active = false;\n    state.apps.find(app => app.id === appId).groups = [];\n    state.apps.find(app => app.id === appId).needsDownload = true;\n    state.apps.find(app => app.id === appId).installed = false;\n    state.apps.find(app => app.id === appId).canUnInstall = false;\n    state.apps.find(app => app.id === appId).canInstall = true;\n    if (appId === 'app_api') {\n      state.appApiEnabled = false;\n    }\n  },\n  updateApp(state, appId) {\n    const app = state.apps.find(app => app.id === appId);\n    const version = app.update;\n    app.update = null;\n    app.version = version;\n    state.updateCount--;\n  },\n  resetApps(state) {\n    state.apps = [];\n  },\n  reset(state) {\n    state.apps = [];\n    state.categories = [];\n    state.updateCount = 0;\n  },\n  startLoading(state, id) {\n    if (Array.isArray(id)) {\n      id.forEach(_id => {\n        Vue.set(state.loading, _id, true);\n      });\n    } else {\n      Vue.set(state.loading, id, true);\n    }\n  },\n  stopLoading(state, id) {\n    if (Array.isArray(id)) {\n      id.forEach(_id => {\n        Vue.set(state.loading, _id, false);\n      });\n    } else {\n      Vue.set(state.loading, id, false);\n    }\n  }\n};\nconst getters = {\n  isAppApiEnabled(state) {\n    return state.appApiEnabled;\n  },\n  loading(state) {\n    return function (id) {\n      return state.loading[id];\n    };\n  },\n  getCategories(state) {\n    return state.categories;\n  },\n  getAllApps(state) {\n    return state.apps;\n  },\n  getAppBundles(state) {\n    return state.bundles;\n  },\n  getUpdateCount(state) {\n    return state.updateCount;\n  },\n  getCategoryById: state => selectedCategoryId => {\n    return state.categories.find(category => category.id === selectedCategoryId);\n  }\n};\nconst actions = {\n  enableApp(context, _ref6) {\n    let {\n      appId,\n      groups\n    } = _ref6;\n    let apps;\n    if (Array.isArray(appId)) {\n      apps = appId;\n    } else {\n      apps = [appId];\n    }\n    return api.requireAdmin().then(response => {\n      context.commit('startLoading', apps);\n      context.commit('startLoading', 'install');\n      return api.post(generateUrl('settings/apps/enable'), {\n        appIds: apps,\n        groups\n      }).then(response => {\n        context.commit('stopLoading', apps);\n        context.commit('stopLoading', 'install');\n        apps.forEach(_appId => {\n          context.commit('enableApp', {\n            appId: _appId,\n            groups\n          });\n        });\n\n        // check for server health\n        return axios.get(generateUrl('apps/files/')).then(() => {\n          if (response.data.update_required) {\n            showInfo(t('settings', 'The app has been enabled but needs to be updated. You will be redirected to the update page in 5 seconds.'), {\n              onClick: () => window.location.reload(),\n              close: false\n            });\n            setTimeout(function () {\n              location.reload();\n            }, 5000);\n          }\n        }).catch(() => {\n          if (!Array.isArray(appId)) {\n            showError(t('settings', 'Error: This app cannot be enabled because it makes the server unstable'));\n            context.commit('setError', {\n              appId: apps,\n              error: t('settings', 'Error: This app cannot be enabled because it makes the server unstable')\n            });\n            context.dispatch('disableApp', {\n              appId\n            });\n          }\n        });\n      }).catch(error => {\n        context.commit('stopLoading', apps);\n        context.commit('stopLoading', 'install');\n        context.commit('setError', {\n          appId: apps,\n          error: error.response.data.data.message\n        });\n        context.commit('APPS_API_FAILURE', {\n          appId,\n          error\n        });\n      });\n    }).catch(error => context.commit('API_FAILURE', {\n      appId,\n      error\n    }));\n  },\n  forceEnableApp(context, _ref7) {\n    let {\n      appId,\n      groups\n    } = _ref7;\n    let apps;\n    if (Array.isArray(appId)) {\n      apps = appId;\n    } else {\n      apps = [appId];\n    }\n    return api.requireAdmin().then(() => {\n      context.commit('startLoading', apps);\n      context.commit('startLoading', 'install');\n      return api.post(generateUrl('settings/apps/force'), {\n        appId\n      }).then(response => {\n        context.commit('setInstallState', {\n          appId,\n          canInstall: true\n        });\n      }).catch(error => {\n        context.commit('stopLoading', apps);\n        context.commit('stopLoading', 'install');\n        context.commit('setError', {\n          appId: apps,\n          error: error.response.data.data.message\n        });\n        context.commit('APPS_API_FAILURE', {\n          appId,\n          error\n        });\n      }).finally(() => {\n        context.commit('stopLoading', apps);\n        context.commit('stopLoading', 'install');\n      });\n    }).catch(error => context.commit('API_FAILURE', {\n      appId,\n      error\n    }));\n  },\n  disableApp(context, _ref8) {\n    let {\n      appId\n    } = _ref8;\n    let apps;\n    if (Array.isArray(appId)) {\n      apps = appId;\n    } else {\n      apps = [appId];\n    }\n    return api.requireAdmin().then(response => {\n      context.commit('startLoading', apps);\n      return api.post(generateUrl('settings/apps/disable'), {\n        appIds: apps\n      }).then(response => {\n        context.commit('stopLoading', apps);\n        apps.forEach(_appId => {\n          context.commit('disableApp', _appId);\n        });\n        return true;\n      }).catch(error => {\n        context.commit('stopLoading', apps);\n        context.commit('APPS_API_FAILURE', {\n          appId,\n          error\n        });\n      });\n    }).catch(error => context.commit('API_FAILURE', {\n      appId,\n      error\n    }));\n  },\n  uninstallApp(context, _ref9) {\n    let {\n      appId\n    } = _ref9;\n    return api.requireAdmin().then(response => {\n      context.commit('startLoading', appId);\n      return api.get(generateUrl(`settings/apps/uninstall/${appId}`)).then(response => {\n        context.commit('stopLoading', appId);\n        context.commit('uninstallApp', appId);\n        return true;\n      }).catch(error => {\n        context.commit('stopLoading', appId);\n        context.commit('APPS_API_FAILURE', {\n          appId,\n          error\n        });\n      });\n    }).catch(error => context.commit('API_FAILURE', {\n      appId,\n      error\n    }));\n  },\n  updateApp(context, _ref0) {\n    let {\n      appId\n    } = _ref0;\n    return api.requireAdmin().then(response => {\n      context.commit('startLoading', appId);\n      context.commit('startLoading', 'install');\n      return api.get(generateUrl(`settings/apps/update/${appId}`)).then(response => {\n        context.commit('stopLoading', 'install');\n        context.commit('stopLoading', appId);\n        context.commit('updateApp', appId);\n        return true;\n      }).catch(error => {\n        context.commit('stopLoading', appId);\n        context.commit('stopLoading', 'install');\n        context.commit('APPS_API_FAILURE', {\n          appId,\n          error\n        });\n      });\n    }).catch(error => context.commit('API_FAILURE', {\n      appId,\n      error\n    }));\n  },\n  getAllApps(context) {\n    context.commit('startLoading', 'list');\n    return api.get(generateUrl('settings/apps/list')).then(response => {\n      context.commit('setAllApps', response.data.apps);\n      context.commit('stopLoading', 'list');\n      return true;\n    }).catch(error => context.commit('API_FAILURE', error));\n  },\n  async getCategories(context) {\n    let {\n      shouldRefetchCategories = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (shouldRefetchCategories || !context.state.gettingCategoriesPromise) {\n      context.commit('startLoading', 'categories');\n      try {\n        const categoriesPromise = api.get(generateUrl('settings/apps/categories'));\n        context.commit('updateCategories', categoriesPromise);\n        const categoriesPromiseResponse = await categoriesPromise;\n        if (categoriesPromiseResponse.data.length > 0) {\n          context.commit('appendCategories', categoriesPromiseResponse.data);\n          context.commit('stopLoading', 'categories');\n          return true;\n        }\n        context.commit('stopLoading', 'categories');\n        return false;\n      } catch (error) {\n        context.commit('API_FAILURE', error);\n      }\n    }\n    return context.state.gettingCategoriesPromise;\n  }\n};\nexport default {\n  state,\n  mutations,\n  getters,\n  actions\n};","/**\n * SPDX-FileCopyrightText: 2018 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport { Store } from 'vuex';\nimport users from \"./users.js\";\nimport apps from \"./apps.js\";\nimport settings from \"./users-settings.js\";\nimport oc from \"./oc.js\";\nimport { showError } from '@nextcloud/dialogs';\nconst debug = process.env.NODE_ENV !== 'production';\nconst mutations = {\n  API_FAILURE(state, error) {\n    try {\n      const message = error.error.response.data.ocs.meta.message;\n      showError(t('settings', 'An error occurred during the request. Unable to proceed.') + '<br>' + message, {\n        isHTML: true\n      });\n    } catch (e) {\n      showError(t('settings', 'An error occurred during the request. Unable to proceed.'));\n    }\n    console.error(state, error);\n  }\n};\nlet store = null;\nexport const useStore = () => {\n  if (store === null) {\n    store = new Store({\n      modules: {\n        users,\n        apps,\n        settings,\n        oc\n      },\n      strict: debug,\n      mutations\n    });\n  }\n  return store;\n};","/**\n * SPDX-FileCopyrightText: 2018 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport api from \"./api.js\";\nimport { generateOcsUrl } from '@nextcloud/router';\nconst state = {};\nconst mutations = {};\nconst getters = {};\nconst actions = {\n  /**\n   * Set application config in database\n   *\n   * @param {object} context store context\n   * @param {object} options destructuring object\n   * @param {string} options.app Application name\n   * @param {boolean} options.key Config key\n   * @param {boolean} options.value Value to set\n   * @return {Promise}\n   */\n  setAppConfig(context, _ref) {\n    let {\n      app,\n      key,\n      value\n    } = _ref;\n    return api.requireAdmin().then(response => {\n      return api.post(generateOcsUrl('apps/provisioning_api/api/v1/config/apps/{app}/{key}', {\n        app,\n        key\n      }), {\n        value\n      }).catch(error => {\n        throw error;\n      });\n    }).catch(error => context.commit('API_FAILURE', {\n      app,\n      key,\n      value,\n      error\n    }));\n  }\n};\nexport default {\n  state,\n  mutations,\n  getters,\n  actions\n};","/**\n * SPDX-FileCopyrightText: 2018 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport { loadState } from '@nextcloud/initial-state';\nconst state = {\n  serverData: loadState('settings', 'usersSettings', {})\n};\nconst mutations = {\n  setServerData(state, data) {\n    state.serverData = data;\n  }\n};\nconst getters = {\n  getServerData(state) {\n    return state.serverData;\n  }\n};\nconst actions = {};\nexport default {\n  state,\n  mutations,\n  getters,\n  actions\n};","/**\n * SPDX-FileCopyrightText: 2018 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport { getBuilder } from '@nextcloud/browser-storage';\nimport { getCapabilities } from '@nextcloud/capabilities';\nimport { parseFileSize } from '@nextcloud/files';\nimport { showError } from '@nextcloud/dialogs';\nimport { generateOcsUrl, generateUrl } from '@nextcloud/router';\nimport { loadState } from '@nextcloud/initial-state';\nimport axios from '@nextcloud/axios';\nimport { GroupSorting } from \"../constants/GroupManagement.ts\";\nimport { naturalCollator } from \"../utils/sorting.ts\";\nimport api from \"./api.js\";\nimport logger from \"../logger.ts\";\nconst usersSettings = loadState('settings', 'usersSettings', {});\nconst localStorage = getBuilder('settings').persist(true).build();\nconst defaults = {\n  /**\n   * @type {import('../views/user-types').IGroup}\n   */\n  group: {\n    id: '',\n    name: '',\n    usercount: 0,\n    disabled: 0,\n    canAdd: true,\n    canRemove: true\n  }\n};\nconst state = {\n  users: [],\n  groups: [...(usersSettings.getSubAdminGroups ?? []), ...(usersSettings.systemGroups ?? [])],\n  orderBy: usersSettings.sortGroups ?? GroupSorting.UserCount,\n  minPasswordLength: 0,\n  usersOffset: 0,\n  usersLimit: 25,\n  disabledUsersOffset: 0,\n  disabledUsersLimit: 25,\n  userCount: usersSettings.userCount ?? 0,\n  showConfig: {\n    showStoragePath: localStorage.getItem('account_settings__showStoragePath') === 'true',\n    showUserBackend: localStorage.getItem('account_settings__showUserBackend') === 'true',\n    showFirstLogin: localStorage.getItem('account_settings__showFirstLogin') === 'true',\n    showLastLogin: localStorage.getItem('account_settings__showLastLogin') === 'true',\n    showNewUserForm: localStorage.getItem('account_settings__showNewUserForm') === 'true',\n    showLanguages: localStorage.getItem('account_settings__showLanguages') === 'true'\n  }\n};\nconst mutations = {\n  appendUsers(state, usersObj) {\n    const existingUsers = state.users.map(_ref => {\n      let {\n        id\n      } = _ref;\n      return id;\n    });\n    const newUsers = Object.values(usersObj).filter(_ref2 => {\n      let {\n        id\n      } = _ref2;\n      return !existingUsers.includes(id);\n    });\n    const users = state.users.concat(newUsers);\n    state.usersOffset += state.usersLimit;\n    state.users = users;\n  },\n  updateDisabledUsers(state, _usersObj) {\n    state.disabledUsersOffset += state.disabledUsersLimit;\n  },\n  setPasswordPolicyMinLength(state, length) {\n    state.minPasswordLength = length !== '' ? length : 0;\n  },\n  /**\n   * @param {object} state store state\n   * @param {import('../views/user-types.js').IGroup} newGroup new group\n   */\n  addGroup(state, newGroup) {\n    try {\n      if (typeof state.groups.find(group => group.id === newGroup.id) !== 'undefined') {\n        return;\n      }\n      // extend group to default values\n      const group = Object.assign({}, defaults.group, newGroup);\n      state.groups.unshift(group);\n    } catch (e) {\n      console.error('Can\\'t create group', e);\n    }\n  },\n  renameGroup(state, _ref3) {\n    let {\n      gid,\n      displayName\n    } = _ref3;\n    const groupIndex = state.groups.findIndex(groupSearch => groupSearch.id === gid);\n    if (groupIndex >= 0) {\n      const updatedGroup = state.groups[groupIndex];\n      updatedGroup.name = displayName;\n      state.groups.splice(groupIndex, 1, updatedGroup);\n    }\n  },\n  removeGroup(state, gid) {\n    const groupIndex = state.groups.findIndex(groupSearch => groupSearch.id === gid);\n    if (groupIndex >= 0) {\n      state.groups.splice(groupIndex, 1);\n    }\n  },\n  addUserGroup(state, _ref4) {\n    let {\n      userid,\n      gid\n    } = _ref4;\n    const group = state.groups.find(groupSearch => groupSearch.id === gid);\n    const user = state.users.find(user => user.id === userid);\n    // increase count if user is enabled\n    if (group && user.enabled && state.userCount > 0) {\n      group.usercount++;\n    }\n    const groups = user.groups;\n    groups.push(gid);\n  },\n  removeUserGroup(state, _ref5) {\n    let {\n      userid,\n      gid\n    } = _ref5;\n    const group = state.groups.find(groupSearch => groupSearch.id === gid);\n    const user = state.users.find(user => user.id === userid);\n    // lower count if user is enabled\n    if (group && user.enabled && state.userCount > 0) {\n      group.usercount--;\n    }\n    const groups = user.groups;\n    groups.splice(groups.indexOf(gid), 1);\n  },\n  addUserSubAdmin(state, _ref6) {\n    let {\n      userid,\n      gid\n    } = _ref6;\n    const groups = state.users.find(user => user.id === userid).subadmin;\n    groups.push(gid);\n  },\n  removeUserSubAdmin(state, _ref7) {\n    let {\n      userid,\n      gid\n    } = _ref7;\n    const groups = state.users.find(user => user.id === userid).subadmin;\n    groups.splice(groups.indexOf(gid), 1);\n  },\n  deleteUser(state, userid) {\n    const userIndex = state.users.findIndex(user => user.id === userid);\n    this.commit('updateUserCounts', {\n      user: state.users[userIndex],\n      actionType: 'remove'\n    });\n    state.users.splice(userIndex, 1);\n  },\n  addUserData(state, response) {\n    const user = response.data.ocs.data;\n    state.users.unshift(user);\n    this.commit('updateUserCounts', {\n      user,\n      actionType: 'create'\n    });\n  },\n  enableDisableUser(state, _ref8) {\n    let {\n      userid,\n      enabled\n    } = _ref8;\n    const user = state.users.find(user => user.id === userid);\n    user.enabled = enabled;\n    this.commit('updateUserCounts', {\n      user,\n      actionType: enabled ? 'enable' : 'disable'\n    });\n  },\n  // update active/disabled counts, groups counts\n  updateUserCounts(state, _ref9) {\n    let {\n      user,\n      actionType\n    } = _ref9;\n    // 0 is a special value\n    if (state.userCount === 0) {\n      return;\n    }\n    const recentGroup = state.groups.find(group => group.id === '__nc_internal_recent');\n    const disabledGroup = state.groups.find(group => group.id === 'disabled');\n    switch (actionType) {\n      case 'enable':\n      case 'disable':\n        disabledGroup.usercount += user.enabled ? -1 : 1; // update Disabled Users count\n        recentGroup.usercount += user.enabled ? 1 : -1;\n        state.userCount += user.enabled ? 1 : -1; // update Active Users count\n        user.groups.forEach(userGroup => {\n          const group = state.groups.find(groupSearch => groupSearch.id === userGroup);\n          if (!group) {\n            return;\n          }\n          group.disabled += user.enabled ? -1 : 1; // update group disabled count\n        });\n        break;\n      case 'create':\n        recentGroup.usercount++;\n        state.userCount++; // increment Active Users count\n\n        user.groups.forEach(userGroup => {\n          const group = state.groups.find(groupSearch => groupSearch.id === userGroup);\n          if (!group) {\n            return;\n          }\n          group.usercount++; // increment group total count\n        });\n        break;\n      case 'remove':\n        if (user.enabled) {\n          recentGroup.usercount--;\n          state.userCount--; // decrement Active Users count\n          user.groups.forEach(userGroup => {\n            const group = state.groups.find(groupSearch => groupSearch.id === userGroup);\n            if (!group) {\n              console.warn('User group ' + userGroup + ' does not exist during user removal');\n              return;\n            }\n            group.usercount--; // decrement group total count\n          });\n        } else {\n          disabledGroup.usercount--; // decrement Disabled Users count\n          user.groups.forEach(userGroup => {\n            const group = state.groups.find(groupSearch => groupSearch.id === userGroup);\n            if (!group) {\n              return;\n            }\n            group.disabled--; // decrement group disabled count\n          });\n        }\n        break;\n      default:\n        logger.error(`Unknown action type in updateUserCounts: '${actionType}'`);\n      // not throwing error to interrupt execution as this is not fatal\n    }\n  },\n  setUserData(state, _ref0) {\n    let {\n      userid,\n      key,\n      value\n    } = _ref0;\n    if (key === 'quota') {\n      const humanValue = parseFileSize(value, true);\n      state.users.find(user => user.id === userid)[key][key] = humanValue !== null ? humanValue : value;\n    } else {\n      state.users.find(user => user.id === userid)[key] = value;\n    }\n  },\n  /**\n   * Reset users list\n   *\n   * @param {object} state the store state\n   */\n  resetUsers(state) {\n    state.users = [];\n    state.usersOffset = 0;\n    state.disabledUsersOffset = 0;\n  },\n  /**\n   * Reset group list\n   *\n   * @param {object} state the store state\n   */\n  resetGroups(state) {\n    state.groups = [...(usersSettings.getSubAdminGroups ?? []), ...(usersSettings.systemGroups ?? [])];\n  },\n  setShowConfig(state, _ref1) {\n    let {\n      key,\n      value\n    } = _ref1;\n    localStorage.setItem(`account_settings__${key}`, JSON.stringify(value));\n    state.showConfig[key] = value;\n  },\n  setGroupSorting(state, sorting) {\n    const oldValue = state.orderBy;\n    state.orderBy = sorting;\n\n    // Persist the value on the server\n    axios.post(generateUrl('/settings/users/preferences/group.sortBy'), {\n      value: String(sorting)\n    }).catch(error => {\n      state.orderBy = oldValue;\n      showError(t('settings', 'Could not set group sorting'));\n      logger.error(error);\n    });\n  }\n};\nconst getters = {\n  getUsers(state) {\n    return state.users;\n  },\n  getGroups(state) {\n    return state.groups;\n  },\n  getSubAdminGroups() {\n    return usersSettings.subAdminGroups ?? [];\n  },\n  getSortedGroups(state) {\n    const groups = [...state.groups];\n    if (state.orderBy === GroupSorting.UserCount) {\n      return groups.sort((a, b) => {\n        const numA = a.usercount - a.disabled;\n        const numB = b.usercount - b.disabled;\n        return numA < numB ? 1 : numB < numA ? -1 : naturalCollator.compare(a.name, b.name);\n      });\n    } else {\n      return groups.sort((a, b) => naturalCollator.compare(a.name, b.name));\n    }\n  },\n  getGroupSorting(state) {\n    return state.orderBy;\n  },\n  getPasswordPolicyMinLength(state) {\n    return state.minPasswordLength;\n  },\n  getUsersOffset(state) {\n    return state.usersOffset;\n  },\n  getUsersLimit(state) {\n    return state.usersLimit;\n  },\n  getDisabledUsersOffset(state) {\n    return state.disabledUsersOffset;\n  },\n  getDisabledUsersLimit(state) {\n    return state.disabledUsersLimit;\n  },\n  getUserCount(state) {\n    return state.userCount;\n  },\n  getShowConfig(state) {\n    return state.showConfig;\n  }\n};\nconst CancelToken = axios.CancelToken;\nlet searchRequestCancelSource = null;\nconst actions = {\n  /**\n   * search users\n   *\n   * @param {object} context store context\n   * @param {object} options destructuring object\n   * @param {number} options.offset List offset to request\n   * @param {number} options.limit List number to return from offset\n   * @param {string} options.search Search amongst users\n   * @return {Promise}\n   */\n  searchUsers(context, _ref10) {\n    let {\n      offset,\n      limit,\n      search\n    } = _ref10;\n    search = typeof search === 'string' ? search : '';\n    return api.get(generateOcsUrl('cloud/users/details?offset={offset}&limit={limit}&search={search}', {\n      offset,\n      limit,\n      search\n    })).catch(error => {\n      if (!axios.isCancel(error)) {\n        context.commit('API_FAILURE', error);\n      }\n    });\n  },\n  /**\n   * Get user details\n   *\n   * @param {object} context store context\n   * @param {string} userId user id\n   * @return {Promise}\n   */\n  getUser(context, userId) {\n    return api.get(generateOcsUrl(`cloud/users/${userId}`)).catch(error => {\n      if (!axios.isCancel(error)) {\n        context.commit('API_FAILURE', error);\n      }\n    });\n  },\n  /**\n   * Get all users with full details\n   *\n   * @param {object} context store context\n   * @param {object} options destructuring object\n   * @param {number} options.offset List offset to request\n   * @param {number} options.limit List number to return from offset\n   * @param {string} options.search Search amongst users\n   * @param {string} options.group Get users from group\n   * @return {Promise}\n   */\n  getUsers(context, _ref11) {\n    let {\n      offset,\n      limit,\n      search,\n      group\n    } = _ref11;\n    if (searchRequestCancelSource) {\n      searchRequestCancelSource.cancel('Operation canceled by another search request.');\n    }\n    searchRequestCancelSource = CancelToken.source();\n    search = typeof search === 'string' ? search : '';\n\n    /**\n     * Adding filters in the search bar such as in:files, in:users, etc.\n     * collides with this particular search, so we need to remove them\n     * here and leave only the original search query\n     */\n    search = search.replace(/in:[^\\s]+/g, '').trim();\n    group = typeof group === 'string' ? group : '';\n    if (group !== '') {\n      return api.get(generateOcsUrl('cloud/groups/{group}/users/details?offset={offset}&limit={limit}&search={search}', {\n        group: encodeURIComponent(group),\n        offset,\n        limit,\n        search\n      }), {\n        cancelToken: searchRequestCancelSource.token\n      }).then(response => {\n        const usersCount = Object.keys(response.data.ocs.data.users).length;\n        if (usersCount > 0) {\n          context.commit('appendUsers', response.data.ocs.data.users);\n        }\n        return usersCount;\n      }).catch(error => {\n        if (!axios.isCancel(error)) {\n          context.commit('API_FAILURE', error);\n        }\n      });\n    }\n    return api.get(generateOcsUrl('cloud/users/details?offset={offset}&limit={limit}&search={search}', {\n      offset,\n      limit,\n      search\n    }), {\n      cancelToken: searchRequestCancelSource.token\n    }).then(response => {\n      const usersCount = Object.keys(response.data.ocs.data.users).length;\n      if (usersCount > 0) {\n        context.commit('appendUsers', response.data.ocs.data.users);\n      }\n      return usersCount;\n    }).catch(error => {\n      if (!axios.isCancel(error)) {\n        context.commit('API_FAILURE', error);\n      }\n    });\n  },\n  /**\n   * Get recent users with full details\n   *\n   * @param {object} context store context\n   * @param {object} options destructuring object\n   * @param {number} options.offset List offset to request\n   * @param {number} options.limit List number to return from offset\n   * @param {string} options.search Search query\n   * @return {Promise<number>}\n   */\n  async getRecentUsers(context, _ref12) {\n    let {\n      offset,\n      limit,\n      search\n    } = _ref12;\n    const url = generateOcsUrl('cloud/users/recent?offset={offset}&limit={limit}&search={search}', {\n      offset,\n      limit,\n      search\n    });\n    try {\n      const response = await api.get(url);\n      const usersCount = Object.keys(response.data.ocs.data.users).length;\n      if (usersCount > 0) {\n        context.commit('appendUsers', response.data.ocs.data.users);\n      }\n      return usersCount;\n    } catch (error) {\n      context.commit('API_FAILURE', error);\n    }\n  },\n  /**\n   * Get disabled users with full details\n   *\n   * @param {object} context store context\n   * @param {object} options destructuring object\n   * @param {number} options.offset List offset to request\n   * @param {number} options.limit List number to return from offset\n   * @param options.search\n   * @return {Promise<number>}\n   */\n  async getDisabledUsers(context, _ref13) {\n    let {\n      offset,\n      limit,\n      search\n    } = _ref13;\n    const url = generateOcsUrl('cloud/users/disabled?offset={offset}&limit={limit}&search={search}', {\n      offset,\n      limit,\n      search\n    });\n    try {\n      const response = await api.get(url);\n      const usersCount = Object.keys(response.data.ocs.data.users).length;\n      if (usersCount > 0) {\n        context.commit('appendUsers', response.data.ocs.data.users);\n        context.commit('updateDisabledUsers', response.data.ocs.data.users);\n      }\n      return usersCount;\n    } catch (error) {\n      context.commit('API_FAILURE', error);\n    }\n  },\n  getGroups(context, _ref14) {\n    let {\n      offset,\n      limit,\n      search\n    } = _ref14;\n    search = typeof search === 'string' ? search : '';\n    const limitParam = limit === -1 ? '' : `&limit=${limit}`;\n    return api.get(generateOcsUrl('cloud/groups?offset={offset}&search={search}', {\n      offset,\n      search\n    }) + limitParam).then(response => {\n      if (Object.keys(response.data.ocs.data.groups).length > 0) {\n        response.data.ocs.data.groups.forEach(function (group) {\n          context.commit('addGroup', {\n            id: group,\n            name: group\n          });\n        });\n        return true;\n      }\n      return false;\n    }).catch(error => context.commit('API_FAILURE', error));\n  },\n  /**\n   * Get all users with full details\n   *\n   * @param {object} context store context\n   * @param {object} options destructuring object\n   * @param {number} options.offset List offset to request\n   * @param {number} options.limit List number to return from offset\n   * @param {string} options.search -\n   * @return {Promise}\n   */\n  getUsersFromList(context, _ref15) {\n    let {\n      offset,\n      limit,\n      search\n    } = _ref15;\n    search = typeof search === 'string' ? search : '';\n    return api.get(generateOcsUrl('cloud/users/details?offset={offset}&limit={limit}&search={search}', {\n      offset,\n      limit,\n      search\n    })).then(response => {\n      if (Object.keys(response.data.ocs.data.users).length > 0) {\n        context.commit('appendUsers', response.data.ocs.data.users);\n        return true;\n      }\n      return false;\n    }).catch(error => context.commit('API_FAILURE', error));\n  },\n  /**\n   * Get all users with full details from a groupid\n   *\n   * @param {object} context store context\n   * @param {object} options destructuring object\n   * @param {number} options.offset List offset to request\n   * @param {number} options.limit List number to return from offset\n   * @param {string} options.groupid -\n   * @return {Promise}\n   */\n  getUsersFromGroup(context, _ref16) {\n    let {\n      groupid,\n      offset,\n      limit\n    } = _ref16;\n    return api.get(generateOcsUrl('cloud/users/{groupId}/details?offset={offset}&limit={limit}', {\n      groupId: encodeURIComponent(groupid),\n      offset,\n      limit\n    })).then(response => context.commit('getUsersFromList', response.data.ocs.data.users)).catch(error => context.commit('API_FAILURE', error));\n  },\n  getPasswordPolicyMinLength(context) {\n    if (getCapabilities().password_policy && getCapabilities().password_policy.minLength) {\n      context.commit('setPasswordPolicyMinLength', getCapabilities().password_policy.minLength);\n      return getCapabilities().password_policy.minLength;\n    }\n    return false;\n  },\n  /**\n   * Add group\n   *\n   * @param {object} context store context\n   * @param {string} gid Group id\n   * @return {Promise}\n   */\n  addGroup(context, gid) {\n    return api.requireAdmin().then(response => {\n      return api.post(generateOcsUrl('cloud/groups'), {\n        groupid: gid\n      }).then(response => {\n        context.commit('addGroup', {\n          id: gid,\n          name: gid\n        });\n        return {\n          gid,\n          displayName: gid\n        };\n      }).catch(error => {\n        throw error;\n      });\n    }).catch(error => {\n      context.commit('API_FAILURE', {\n        gid,\n        error\n      });\n      // let's throw one more time to prevent the view\n      // from adding the user to a group that doesn't exists\n      throw error;\n    });\n  },\n  /**\n   * Rename group\n   *\n   * @param {object} context store context\n   * @param {string} groupid Group id\n   * @param {string} displayName Group display name\n   * @return {Promise}\n   */\n  renameGroup(context, _ref17) {\n    let {\n      groupid,\n      displayName\n    } = _ref17;\n    return api.requireAdmin().then(response => {\n      return api.put(generateOcsUrl('cloud/groups/{groupId}', {\n        groupId: encodeURIComponent(groupid)\n      }), {\n        key: 'displayname',\n        value: displayName\n      }).then(response => {\n        context.commit('renameGroup', {\n          gid: groupid,\n          displayName\n        });\n        return {\n          groupid,\n          displayName\n        };\n      }).catch(error => {\n        throw error;\n      });\n    }).catch(error => {\n      context.commit('API_FAILURE', {\n        groupid,\n        error\n      });\n      // let's throw one more time to prevent the view\n      // from renaming the group\n      throw error;\n    });\n  },\n  /**\n   * Remove group\n   *\n   * @param {object} context store context\n   * @param {string} gid Group id\n   * @return {Promise}\n   */\n  removeGroup(context, gid) {\n    return api.requireAdmin().then(response => {\n      return api.delete(generateOcsUrl('cloud/groups/{groupId}', {\n        groupId: encodeURIComponent(gid)\n      })).then(response => context.commit('removeGroup', gid)).catch(error => {\n        throw error;\n      });\n    }).catch(error => context.commit('API_FAILURE', {\n      gid,\n      error\n    }));\n  },\n  /**\n   * Add user to group\n   *\n   * @param {object} context store context\n   * @param {object} options destructuring object\n   * @param {string} options.userid User id\n   * @param {string} options.gid Group id\n   * @return {Promise}\n   */\n  addUserGroup(context, _ref18) {\n    let {\n      userid,\n      gid\n    } = _ref18;\n    return api.requireAdmin().then(response => {\n      return api.post(generateOcsUrl('cloud/users/{userid}/groups', {\n        userid\n      }), {\n        groupid: gid\n      }).then(response => context.commit('addUserGroup', {\n        userid,\n        gid\n      })).catch(error => {\n        throw error;\n      });\n    }).catch(error => context.commit('API_FAILURE', {\n      userid,\n      error\n    }));\n  },\n  /**\n   * Remove user from group\n   *\n   * @param {object} context store context\n   * @param {object} options destructuring object\n   * @param {string} options.userid User id\n   * @param {string} options.gid Group id\n   * @return {Promise}\n   */\n  removeUserGroup(context, _ref19) {\n    let {\n      userid,\n      gid\n    } = _ref19;\n    return api.requireAdmin().then(response => {\n      return api.delete(generateOcsUrl('cloud/users/{userid}/groups', {\n        userid\n      }), {\n        groupid: gid\n      }).then(response => context.commit('removeUserGroup', {\n        userid,\n        gid\n      })).catch(error => {\n        throw error;\n      });\n    }).catch(error => {\n      context.commit('API_FAILURE', {\n        userid,\n        error\n      });\n      // let's throw one more time to prevent\n      // the view from removing the user row on failure\n      throw error;\n    });\n  },\n  /**\n   * Add user to group admin\n   *\n   * @param {object} context store context\n   * @param {object} options destructuring object\n   * @param {string} options.userid User id\n   * @param {string} options.gid Group id\n   * @return {Promise}\n   */\n  addUserSubAdmin(context, _ref20) {\n    let {\n      userid,\n      gid\n    } = _ref20;\n    return api.requireAdmin().then(response => {\n      return api.post(generateOcsUrl('cloud/users/{userid}/subadmins', {\n        userid\n      }), {\n        groupid: gid\n      }).then(response => context.commit('addUserSubAdmin', {\n        userid,\n        gid\n      })).catch(error => {\n        throw error;\n      });\n    }).catch(error => context.commit('API_FAILURE', {\n      userid,\n      error\n    }));\n  },\n  /**\n   * Remove user from group admin\n   *\n   * @param {object} context store context\n   * @param {object} options destructuring object\n   * @param {string} options.userid User id\n   * @param {string} options.gid Group id\n   * @return {Promise}\n   */\n  removeUserSubAdmin(context, _ref21) {\n    let {\n      userid,\n      gid\n    } = _ref21;\n    return api.requireAdmin().then(response => {\n      return api.delete(generateOcsUrl('cloud/users/{userid}/subadmins', {\n        userid\n      }), {\n        groupid: gid\n      }).then(response => context.commit('removeUserSubAdmin', {\n        userid,\n        gid\n      })).catch(error => {\n        throw error;\n      });\n    }).catch(error => context.commit('API_FAILURE', {\n      userid,\n      error\n    }));\n  },\n  /**\n   * Mark all user devices for remote wipe\n   *\n   * @param {object} context store context\n   * @param {string} userid User id\n   * @return {Promise}\n   */\n  async wipeUserDevices(context, userid) {\n    try {\n      await api.requireAdmin();\n      return await api.post(generateOcsUrl('cloud/users/{userid}/wipe', {\n        userid\n      }));\n    } catch (error) {\n      context.commit('API_FAILURE', {\n        userid,\n        error\n      });\n      return Promise.reject(new Error('Failed to wipe user devices'));\n    }\n  },\n  /**\n   * Delete a user\n   *\n   * @param {object} context store context\n   * @param {string} userid User id\n   * @return {Promise}\n   */\n  deleteUser(context, userid) {\n    return api.requireAdmin().then(response => {\n      return api.delete(generateOcsUrl('cloud/users/{userid}', {\n        userid\n      })).then(response => context.commit('deleteUser', userid)).catch(error => {\n        throw error;\n      });\n    }).catch(error => context.commit('API_FAILURE', {\n      userid,\n      error\n    }));\n  },\n  /**\n   * Add a user\n   *\n   * @param {object} context store context\n   * @param {Function} context.commit -\n   * @param {Function} context.dispatch -\n   * @param {object} options destructuring object\n   * @param {string} options.userid User id\n   * @param {string} options.password User password\n   * @param {string} options.displayName User display name\n   * @param {string} options.email User email\n   * @param {string} options.groups User groups\n   * @param {string} options.subadmin User subadmin groups\n   * @param {string} options.quota User email\n   * @param {string} options.language User language\n   * @param {string} options.manager User manager\n   * @return {Promise}\n   */\n  addUser(_ref22, _ref23) {\n    let {\n      commit,\n      dispatch\n    } = _ref22;\n    let {\n      userid,\n      password,\n      displayName,\n      email,\n      groups,\n      subadmin,\n      quota,\n      language,\n      manager\n    } = _ref23;\n    return api.requireAdmin().then(response => {\n      return api.post(generateOcsUrl('cloud/users'), {\n        userid,\n        password,\n        displayName,\n        email,\n        groups,\n        subadmin,\n        quota,\n        language,\n        manager\n      }).then(response => dispatch('addUserData', userid || response.data.ocs.data.id)).catch(error => {\n        throw error;\n      });\n    }).catch(error => {\n      commit('API_FAILURE', {\n        userid,\n        error\n      });\n      throw error;\n    });\n  },\n  /**\n   * Get user data and commit addition\n   *\n   * @param {object} context store context\n   * @param {string} userid User id\n   * @return {Promise}\n   */\n  addUserData(context, userid) {\n    return api.requireAdmin().then(response => {\n      return api.get(generateOcsUrl('cloud/users/{userid}', {\n        userid\n      })).then(response => context.commit('addUserData', response)).catch(error => {\n        throw error;\n      });\n    }).catch(error => context.commit('API_FAILURE', {\n      userid,\n      error\n    }));\n  },\n  /**\n   * Enable or disable user\n   *\n   * @param {object} context store context\n   * @param {object} options destructuring object\n   * @param {string} options.userid User id\n   * @param {boolean} options.enabled User enablement status\n   * @return {Promise}\n   */\n  enableDisableUser(context, _ref24) {\n    let {\n      userid,\n      enabled = true\n    } = _ref24;\n    const userStatus = enabled ? 'enable' : 'disable';\n    return api.requireAdmin().then(response => {\n      return api.put(generateOcsUrl('cloud/users/{userid}/{userStatus}', {\n        userid,\n        userStatus\n      })).then(response => context.commit('enableDisableUser', {\n        userid,\n        enabled\n      })).catch(error => {\n        throw error;\n      });\n    }).catch(error => context.commit('API_FAILURE', {\n      userid,\n      error\n    }));\n  },\n  /**\n   * Edit user data\n   *\n   * @param {object} context store context\n   * @param {object} options destructuring object\n   * @param {string} options.userid User id\n   * @param {string} options.key User field to edit\n   * @param {string} options.value Value of the change\n   * @return {Promise}\n   */\n  async setUserData(context, _ref25) {\n    let {\n      userid,\n      key,\n      value\n    } = _ref25;\n    const allowedEmpty = ['email', 'displayname', 'manager'];\n    const validKeys = ['email', 'language', 'quota', 'displayname', 'password', 'manager'];\n    if (!validKeys.includes(key)) {\n      throw new Error('Invalid request data');\n    }\n\n    // If value is empty and the key doesn't allow empty values, throw error\n    if (value === '' && !allowedEmpty.includes(key)) {\n      throw new Error('Value cannot be empty for this field');\n    }\n    try {\n      await api.requireAdmin();\n      await api.put(generateOcsUrl('cloud/users/{userid}', {\n        userid\n      }), {\n        key,\n        value\n      });\n      return context.commit('setUserData', {\n        userid,\n        key,\n        value\n      });\n    } catch (error) {\n      context.commit('API_FAILURE', {\n        userid,\n        error\n      });\n      throw error;\n    }\n  },\n  /**\n   * Send welcome mail\n   *\n   * @param {object} context store context\n   * @param {string} userid User id\n   * @return {Promise}\n   */\n  sendWelcomeMail(context, userid) {\n    return api.requireAdmin().then(response => {\n      return api.post(generateOcsUrl('cloud/users/{userid}/welcome', {\n        userid\n      })).then(response => true).catch(error => {\n        throw error;\n      });\n    }).catch(error => context.commit('API_FAILURE', {\n      userid,\n      error\n    }));\n  }\n};\nexport default {\n  state,\n  mutations,\n  getters,\n  actions\n};","/**\n * SPDX-FileCopyrightText: 2025 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport { getCanonicalLocale, getLanguage } from '@nextcloud/l10n';\nexport const naturalCollator = Intl.Collator([getLanguage(), getCanonicalLocale()], {\n  numeric: true,\n  usage: 'sort'\n});","import { render, staticRenderFns } from \"./SettingsApp.vue?vue&type=template&id=21177c05\"\nimport script from \"./SettingsApp.vue?vue&type=script&setup=true&lang=ts\"\nexport * from \"./SettingsApp.vue?vue&type=script&setup=true&lang=ts\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (module.hot) {\n  var api = require(\"/home/richard/src/nextcloud/master/node_modules/vue-hot-reload-api/dist/index.js\")\n  api.install(require('vue'))\n  if (api.compatible) {\n    module.hot.accept()\n    if (!api.isRecorded('21177c05')) {\n      api.createRecord('21177c05', component.options)\n    } else {\n      api.reload('21177c05', component.options)\n    }\n    module.hot.accept(\"./SettingsApp.vue?vue&type=template&id=21177c05\", function () {\n      api.rerender('21177c05', {\n        render: render,\n        staticRenderFns: staticRenderFns\n      })\n    })\n  }\n}\ncomponent.options.__file = \"apps/settings/src/views/SettingsApp.vue\"\nexport default component.exports","import mod from \"-!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/ts-loader/index.js??clonedRuleSet-4.use[1]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsApp.vue?vue&type=script&setup=true&lang=ts\"; export default mod; export * from \"-!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/ts-loader/index.js??clonedRuleSet-4.use[1]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsApp.vue?vue&type=script&setup=true&lang=ts\"","export * from \"-!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[3]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./SettingsApp.vue?vue&type=template&id=21177c05\"","import { defineComponent as _defineComponent } from 'vue';\nimport NcContent from '@nextcloud/vue/components/NcContent';\nexport default /*#__PURE__*/_defineComponent({\n  __name: 'SettingsApp',\n  setup(__props) {\n    return {\n      __sfc: true,\n      NcContent\n    };\n  }\n});","var render = function render() {\n  var _vm = this,\n    _c = _vm._self._c,\n    _setup = _vm._self._setupProxy;\n  return _c(_setup.NcContent, {\n    attrs: {\n      \"app-name\": \"settings\"\n    }\n  }, [_c(\"router-view\", {\n    attrs: {\n      name: \"navigation\"\n    }\n  }), _vm._v(\" \"), _c(\"router-view\"), _vm._v(\" \"), _c(\"router-view\", {\n    attrs: {\n      name: \"sidebar\"\n    }\n  })], 1);\n};\nvar staticRenderFns = [];\nrender._withStripped = true;\nexport { render, staticRenderFns };","exports.sync = function (store, router, options) {\n  var moduleName = (options || {}).moduleName || 'route'\n\n  store.registerModule(moduleName, {\n    namespaced: true,\n    state: cloneRoute(router.currentRoute),\n    mutations: {\n      'ROUTE_CHANGED': function ROUTE_CHANGED (state, transition) {\n        store.state[moduleName] = cloneRoute(transition.to, transition.from)\n      }\n    }\n  })\n\n  var isTimeTraveling = false\n  var currentPath\n\n  // sync router on store change\n  var storeUnwatch = store.watch(\n    function (state) { return state[moduleName]; },\n    function (route) {\n      var fullPath = route.fullPath;\n      if (fullPath === currentPath) {\n        return\n      }\n      if (currentPath != null) {\n        isTimeTraveling = true\n        router.push(route)\n      }\n      currentPath = fullPath\n    },\n    { sync: true }\n  )\n\n  // sync store on router navigation\n  var afterEachUnHook = router.afterEach(function (to, from) {\n    if (isTimeTraveling) {\n      isTimeTraveling = false\n      return\n    }\n    currentPath = to.fullPath\n    store.commit(moduleName + '/ROUTE_CHANGED', { to: to, from: from })\n  })\n\n  return function unsync () {\n    // On unsync, remove router hook\n    if (afterEachUnHook != null) {\n      afterEachUnHook()\n    }\n\n    // On unsync, remove store watch\n    if (storeUnwatch != null) {\n      storeUnwatch()\n    }\n\n    // On unsync, unregister Module with store\n    store.unregisterModule(moduleName)\n  }\n}\n\nfunction cloneRoute (to, from) {\n  var clone = {\n    name: to.name,\n    path: to.path,\n    hash: to.hash,\n    query: to.query,\n    params: to.params,\n    fullPath: to.fullPath,\n    meta: to.meta\n  }\n  if (from) {\n    clone.from = cloneRoute(from)\n  }\n  return Object.freeze(clone)\n}\n\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \"-\" + chunkId + \".js?v=\" + {\"node_modules_nextcloud_dialogs_dist_chunks_index-BC-7VPxC_mjs\":\"0a21f85fb5edb886fad0\",\"node_modules_nextcloud_dialogs_dist_chunks_PublicAuthPrompt-BSFsDqYB_mjs\":\"5414d4143400c9b713c3\",\"settings-apps-view\":\"90b6c968e335d404e41e\",\"settings-users\":\"1044d80e7cf4e74dcc48\",\"data_image_svg_xml_3c_21--_20-_20SPDX-FileCopyrightText_202020_20Google_20Inc_20-_20SPDX-Lice-391a6e\":\"87f84948225387ac2eec\",\"apps_settings_src_components_AppStoreDiscover_PostType_vue\":\"d0457d62c7973999eac5\",\"apps_settings_src_components_AppStoreDiscover_CarouselType_vue\":\"809b60be0cfe9bf18a2b\",\"apps_settings_src_components_AppStoreDiscover_ShowcaseType_vue\":\"51d2f27298371e407f50\",\"node_modules_rehype-highlight_index_js\":\"3c5c32c691780bf457a0\"}[chunkId] + \"\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"nextcloud:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/^blob:/, \"\").replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"settings-vue-settings-apps-users-management\": 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunknextcloud\"] = self[\"webpackChunknextcloud\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","__webpack_require__.nc = undefined;","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"core-common\"], () => (__webpack_require__(\"./apps/settings/src/main-apps-users-management.ts\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}