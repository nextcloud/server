{"version":3,"file":"common-ClkJEDcz.chunk.mjs","names":["computed","readonly","trigger","computed","li","index"],"sources":["../node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js","../node_modules/tributejs/dist/tribute.esm.js"],"sourcesContent":["/**\n* @vue/reactivity v3.5.22\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { extend, hasChanged, isArray, isIntegerKey, isSymbol, isMap, hasOwn, makeMap, isObject, capitalize, toRawType, def, isFunction, EMPTY_OBJ, isSet, isPlainObject, remove, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal track `on` calls, allow `on` call multiple times\n     */\n    this._on = 0;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this._isPaused = false;\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  pause() {\n    if (this._active) {\n      this._isPaused = true;\n      let i, l;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].pause();\n        }\n      }\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].pause();\n      }\n    }\n  }\n  /**\n   * Resumes the effect scope, including all child scopes and effects.\n   */\n  resume() {\n    if (this._active) {\n      if (this._isPaused) {\n        this._isPaused = false;\n        let i, l;\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].resume();\n          }\n        }\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].resume();\n        }\n      }\n    }\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    if (++this._on === 1) {\n      this.prevScope = activeEffectScope;\n      activeEffectScope = this;\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    if (this._on > 0 && --this._on === 0) {\n      activeEffectScope = this.prevScope;\n      this.prevScope = void 0;\n    }\n  }\n  stop(fromParent) {\n    if (this._active) {\n      this._active = false;\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      this.effects.length = 0;\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      this.cleanups.length = 0;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n        this.scopes.length = 0;\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn, failSilently = false) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nlet activeSub;\nconst EffectFlags = {\n  \"ACTIVE\": 1,\n  \"1\": \"ACTIVE\",\n  \"RUNNING\": 2,\n  \"2\": \"RUNNING\",\n  \"TRACKING\": 4,\n  \"4\": \"TRACKING\",\n  \"NOTIFIED\": 8,\n  \"8\": \"NOTIFIED\",\n  \"DIRTY\": 16,\n  \"16\": \"DIRTY\",\n  \"ALLOW_RECURSE\": 32,\n  \"32\": \"ALLOW_RECURSE\",\n  \"PAUSED\": 64,\n  \"64\": \"PAUSED\",\n  \"EVALUATED\": 128,\n  \"128\": \"EVALUATED\"\n};\nconst pausedQueueEffects = /* @__PURE__ */ new WeakSet();\nclass ReactiveEffect {\n  constructor(fn) {\n    this.fn = fn;\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 1 | 4;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    /**\n     * @internal\n     */\n    this.cleanup = void 0;\n    this.scheduler = void 0;\n    if (activeEffectScope && activeEffectScope.active) {\n      activeEffectScope.effects.push(this);\n    }\n  }\n  pause() {\n    this.flags |= 64;\n  }\n  resume() {\n    if (this.flags & 64) {\n      this.flags &= -65;\n      if (pausedQueueEffects.has(this)) {\n        pausedQueueEffects.delete(this);\n        this.trigger();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    if (this.flags & 2 && !(this.flags & 32)) {\n      return;\n    }\n    if (!(this.flags & 8)) {\n      batch(this);\n    }\n  }\n  run() {\n    if (!(this.flags & 1)) {\n      return this.fn();\n    }\n    this.flags |= 2;\n    cleanupEffect(this);\n    prepareDeps(this);\n    const prevEffect = activeSub;\n    const prevShouldTrack = shouldTrack;\n    activeSub = this;\n    shouldTrack = true;\n    try {\n      return this.fn();\n    } finally {\n      if (!!(process.env.NODE_ENV !== \"production\") && activeSub !== this) {\n        warn(\n          \"Active effect was not restored correctly - this is likely a Vue internal bug.\"\n        );\n      }\n      cleanupDeps(this);\n      activeSub = prevEffect;\n      shouldTrack = prevShouldTrack;\n      this.flags &= -3;\n    }\n  }\n  stop() {\n    if (this.flags & 1) {\n      for (let link = this.deps; link; link = link.nextDep) {\n        removeSub(link);\n      }\n      this.deps = this.depsTail = void 0;\n      cleanupEffect(this);\n      this.onStop && this.onStop();\n      this.flags &= -2;\n    }\n  }\n  trigger() {\n    if (this.flags & 64) {\n      pausedQueueEffects.add(this);\n    } else if (this.scheduler) {\n      this.scheduler();\n    } else {\n      this.runIfDirty();\n    }\n  }\n  /**\n   * @internal\n   */\n  runIfDirty() {\n    if (isDirty(this)) {\n      this.run();\n    }\n  }\n  get dirty() {\n    return isDirty(this);\n  }\n}\nlet batchDepth = 0;\nlet batchedSub;\nlet batchedComputed;\nfunction batch(sub, isComputed = false) {\n  sub.flags |= 8;\n  if (isComputed) {\n    sub.next = batchedComputed;\n    batchedComputed = sub;\n    return;\n  }\n  sub.next = batchedSub;\n  batchedSub = sub;\n}\nfunction startBatch() {\n  batchDepth++;\n}\nfunction endBatch() {\n  if (--batchDepth > 0) {\n    return;\n  }\n  if (batchedComputed) {\n    let e = batchedComputed;\n    batchedComputed = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= -9;\n      e = next;\n    }\n  }\n  let error;\n  while (batchedSub) {\n    let e = batchedSub;\n    batchedSub = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= -9;\n      if (e.flags & 1) {\n        try {\n          ;\n          e.trigger();\n        } catch (err) {\n          if (!error) error = err;\n        }\n      }\n      e = next;\n    }\n  }\n  if (error) throw error;\n}\nfunction prepareDeps(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    link.version = -1;\n    link.prevActiveLink = link.dep.activeLink;\n    link.dep.activeLink = link;\n  }\n}\nfunction cleanupDeps(sub) {\n  let head;\n  let tail = sub.depsTail;\n  let link = tail;\n  while (link) {\n    const prev = link.prevDep;\n    if (link.version === -1) {\n      if (link === tail) tail = prev;\n      removeSub(link);\n      removeDep(link);\n    } else {\n      head = link;\n    }\n    link.dep.activeLink = link.prevActiveLink;\n    link.prevActiveLink = void 0;\n    link = prev;\n  }\n  sub.deps = head;\n  sub.depsTail = tail;\n}\nfunction isDirty(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {\n      return true;\n    }\n  }\n  if (sub._dirty) {\n    return true;\n  }\n  return false;\n}\nfunction refreshComputed(computed) {\n  if (computed.flags & 4 && !(computed.flags & 16)) {\n    return;\n  }\n  computed.flags &= -17;\n  if (computed.globalVersion === globalVersion) {\n    return;\n  }\n  computed.globalVersion = globalVersion;\n  if (!computed.isSSR && computed.flags & 128 && (!computed.deps && !computed._dirty || !isDirty(computed))) {\n    return;\n  }\n  computed.flags |= 2;\n  const dep = computed.dep;\n  const prevSub = activeSub;\n  const prevShouldTrack = shouldTrack;\n  activeSub = computed;\n  shouldTrack = true;\n  try {\n    prepareDeps(computed);\n    const value = computed.fn(computed._value);\n    if (dep.version === 0 || hasChanged(value, computed._value)) {\n      computed.flags |= 128;\n      computed._value = value;\n      dep.version++;\n    }\n  } catch (err) {\n    dep.version++;\n    throw err;\n  } finally {\n    activeSub = prevSub;\n    shouldTrack = prevShouldTrack;\n    cleanupDeps(computed);\n    computed.flags &= -3;\n  }\n}\nfunction removeSub(link, soft = false) {\n  const { dep, prevSub, nextSub } = link;\n  if (prevSub) {\n    prevSub.nextSub = nextSub;\n    link.prevSub = void 0;\n  }\n  if (nextSub) {\n    nextSub.prevSub = prevSub;\n    link.nextSub = void 0;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && dep.subsHead === link) {\n    dep.subsHead = nextSub;\n  }\n  if (dep.subs === link) {\n    dep.subs = prevSub;\n    if (!prevSub && dep.computed) {\n      dep.computed.flags &= -5;\n      for (let l = dep.computed.deps; l; l = l.nextDep) {\n        removeSub(l, true);\n      }\n    }\n  }\n  if (!soft && !--dep.sc && dep.map) {\n    dep.map.delete(dep.key);\n  }\n}\nfunction removeDep(link) {\n  const { prevDep, nextDep } = link;\n  if (prevDep) {\n    prevDep.nextDep = nextDep;\n    link.prevDep = void 0;\n  }\n  if (nextDep) {\n    nextDep.prevDep = prevDep;\n    link.nextDep = void 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const e = new ReactiveEffect(fn);\n  if (options) {\n    extend(e, options);\n  }\n  try {\n    e.run();\n  } catch (err) {\n    e.stop();\n    throw err;\n  }\n  const runner = e.run.bind(e);\n  runner.effect = e;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction onEffectCleanup(fn, failSilently = false) {\n  if (activeSub instanceof ReactiveEffect) {\n    activeSub.cleanup = fn;\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onEffectCleanup() was called when there was no active effect to associate with.`\n    );\n  }\n}\nfunction cleanupEffect(e) {\n  const { cleanup } = e;\n  e.cleanup = void 0;\n  if (cleanup) {\n    const prevSub = activeSub;\n    activeSub = void 0;\n    try {\n      cleanup();\n    } finally {\n      activeSub = prevSub;\n    }\n  }\n}\n\nlet globalVersion = 0;\nclass Link {\n  constructor(sub, dep) {\n    this.sub = sub;\n    this.dep = dep;\n    this.version = dep.version;\n    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;\n  }\n}\nclass Dep {\n  // TODO isolatedDeclarations \"__v_skip\"\n  constructor(computed) {\n    this.computed = computed;\n    this.version = 0;\n    /**\n     * Link between this dep and the current active effect\n     */\n    this.activeLink = void 0;\n    /**\n     * Doubly linked list representing the subscribing effects (tail)\n     */\n    this.subs = void 0;\n    /**\n     * For object property deps cleanup\n     */\n    this.map = void 0;\n    this.key = void 0;\n    /**\n     * Subscriber counter\n     */\n    this.sc = 0;\n    /**\n     * @internal\n     */\n    this.__v_skip = true;\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.subsHead = void 0;\n    }\n  }\n  track(debugInfo) {\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\n      return;\n    }\n    let link = this.activeLink;\n    if (link === void 0 || link.sub !== activeSub) {\n      link = this.activeLink = new Link(activeSub, this);\n      if (!activeSub.deps) {\n        activeSub.deps = activeSub.depsTail = link;\n      } else {\n        link.prevDep = activeSub.depsTail;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n      }\n      addSub(link);\n    } else if (link.version === -1) {\n      link.version = this.version;\n      if (link.nextDep) {\n        const next = link.nextDep;\n        next.prevDep = link.prevDep;\n        if (link.prevDep) {\n          link.prevDep.nextDep = next;\n        }\n        link.prevDep = activeSub.depsTail;\n        link.nextDep = void 0;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n        if (activeSub.deps === link) {\n          activeSub.deps = next;\n        }\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && activeSub.onTrack) {\n      activeSub.onTrack(\n        extend(\n          {\n            effect: activeSub\n          },\n          debugInfo\n        )\n      );\n    }\n    return link;\n  }\n  trigger(debugInfo) {\n    this.version++;\n    globalVersion++;\n    this.notify(debugInfo);\n  }\n  notify(debugInfo) {\n    startBatch();\n    try {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        for (let head = this.subsHead; head; head = head.nextSub) {\n          if (head.sub.onTrigger && !(head.sub.flags & 8)) {\n            head.sub.onTrigger(\n              extend(\n                {\n                  effect: head.sub\n                },\n                debugInfo\n              )\n            );\n          }\n        }\n      }\n      for (let link = this.subs; link; link = link.prevSub) {\n        if (link.sub.notify()) {\n          ;\n          link.sub.dep.notify();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  }\n}\nfunction addSub(link) {\n  link.dep.sc++;\n  if (link.sub.flags & 4) {\n    const computed = link.dep.computed;\n    if (computed && !link.dep.subs) {\n      computed.flags |= 4 | 16;\n      for (let l = computed.deps; l; l = l.nextDep) {\n        addSub(l);\n      }\n    }\n    const currentTail = link.dep.subs;\n    if (currentTail !== link) {\n      link.prevSub = currentTail;\n      if (currentTail) currentTail.nextSub = link;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && link.dep.subsHead === void 0) {\n      link.dep.subsHead = link;\n    }\n    link.dep.subs = link;\n  }\n}\nconst targetMap = /* @__PURE__ */ new WeakMap();\nconst ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Object iterate\" : \"\"\n);\nconst MAP_KEY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Map keys iterate\" : \"\"\n);\nconst ARRAY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Array iterate\" : \"\"\n);\nfunction track(target, type, key) {\n  if (shouldTrack && activeSub) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Dep());\n      dep.map = depsMap;\n      dep.key = key;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      dep.track({\n        target,\n        type,\n        key\n      });\n    } else {\n      dep.track();\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    globalVersion++;\n    return;\n  }\n  const run = (dep) => {\n    if (dep) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        dep.trigger({\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      } else {\n        dep.trigger();\n      }\n    }\n  };\n  startBatch();\n  if (type === \"clear\") {\n    depsMap.forEach(run);\n  } else {\n    const targetIsArray = isArray(target);\n    const isArrayIndex = targetIsArray && isIntegerKey(key);\n    if (targetIsArray && key === \"length\") {\n      const newLength = Number(newValue);\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {\n          run(dep);\n        }\n      });\n    } else {\n      if (key !== void 0 || depsMap.has(void 0)) {\n        run(depsMap.get(key));\n      }\n      if (isArrayIndex) {\n        run(depsMap.get(ARRAY_ITERATE_KEY));\n      }\n      switch (type) {\n        case \"add\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isArrayIndex) {\n            run(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (isMap(target)) {\n            run(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n  }\n  endBatch();\n}\nfunction getDepFromReactive(object, key) {\n  const depMap = targetMap.get(object);\n  return depMap && depMap.get(key);\n}\n\nfunction reactiveReadArray(array) {\n  const raw = toRaw(array);\n  if (raw === array) return raw;\n  track(raw, \"iterate\", ARRAY_ITERATE_KEY);\n  return isShallow(array) ? raw : raw.map(toReactive);\n}\nfunction shallowReadArray(arr) {\n  track(arr = toRaw(arr), \"iterate\", ARRAY_ITERATE_KEY);\n  return arr;\n}\nconst arrayInstrumentations = {\n  __proto__: null,\n  [Symbol.iterator]() {\n    return iterator(this, Symbol.iterator, toReactive);\n  },\n  concat(...args) {\n    return reactiveReadArray(this).concat(\n      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)\n    );\n  },\n  entries() {\n    return iterator(this, \"entries\", (value) => {\n      value[1] = toReactive(value[1]);\n      return value;\n    });\n  },\n  every(fn, thisArg) {\n    return apply(this, \"every\", fn, thisArg, void 0, arguments);\n  },\n  filter(fn, thisArg) {\n    return apply(this, \"filter\", fn, thisArg, (v) => v.map(toReactive), arguments);\n  },\n  find(fn, thisArg) {\n    return apply(this, \"find\", fn, thisArg, toReactive, arguments);\n  },\n  findIndex(fn, thisArg) {\n    return apply(this, \"findIndex\", fn, thisArg, void 0, arguments);\n  },\n  findLast(fn, thisArg) {\n    return apply(this, \"findLast\", fn, thisArg, toReactive, arguments);\n  },\n  findLastIndex(fn, thisArg) {\n    return apply(this, \"findLastIndex\", fn, thisArg, void 0, arguments);\n  },\n  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement\n  forEach(fn, thisArg) {\n    return apply(this, \"forEach\", fn, thisArg, void 0, arguments);\n  },\n  includes(...args) {\n    return searchProxy(this, \"includes\", args);\n  },\n  indexOf(...args) {\n    return searchProxy(this, \"indexOf\", args);\n  },\n  join(separator) {\n    return reactiveReadArray(this).join(separator);\n  },\n  // keys() iterator only reads `length`, no optimization required\n  lastIndexOf(...args) {\n    return searchProxy(this, \"lastIndexOf\", args);\n  },\n  map(fn, thisArg) {\n    return apply(this, \"map\", fn, thisArg, void 0, arguments);\n  },\n  pop() {\n    return noTracking(this, \"pop\");\n  },\n  push(...args) {\n    return noTracking(this, \"push\", args);\n  },\n  reduce(fn, ...args) {\n    return reduce(this, \"reduce\", fn, args);\n  },\n  reduceRight(fn, ...args) {\n    return reduce(this, \"reduceRight\", fn, args);\n  },\n  shift() {\n    return noTracking(this, \"shift\");\n  },\n  // slice could use ARRAY_ITERATE but also seems to beg for range tracking\n  some(fn, thisArg) {\n    return apply(this, \"some\", fn, thisArg, void 0, arguments);\n  },\n  splice(...args) {\n    return noTracking(this, \"splice\", args);\n  },\n  toReversed() {\n    return reactiveReadArray(this).toReversed();\n  },\n  toSorted(comparer) {\n    return reactiveReadArray(this).toSorted(comparer);\n  },\n  toSpliced(...args) {\n    return reactiveReadArray(this).toSpliced(...args);\n  },\n  unshift(...args) {\n    return noTracking(this, \"unshift\", args);\n  },\n  values() {\n    return iterator(this, \"values\", toReactive);\n  }\n};\nfunction iterator(self, method, wrapValue) {\n  const arr = shallowReadArray(self);\n  const iter = arr[method]();\n  if (arr !== self && !isShallow(self)) {\n    iter._next = iter.next;\n    iter.next = () => {\n      const result = iter._next();\n      if (!result.done) {\n        result.value = wrapValue(result.value);\n      }\n      return result;\n    };\n  }\n  return iter;\n}\nconst arrayProto = Array.prototype;\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  const arr = shallowReadArray(self);\n  const needsWrap = arr !== self && !isShallow(self);\n  const methodFn = arr[method];\n  if (methodFn !== arrayProto[method]) {\n    const result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, toReactive(item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n  const result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\nfunction reduce(self, method, fn, args) {\n  const arr = shallowReadArray(self);\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (!isShallow(self)) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, toReactive(item), index, self);\n      };\n    } else if (fn.length > 3) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, item, index, self);\n      };\n    }\n  }\n  return arr[method](wrappedFn, ...args);\n}\nfunction searchProxy(self, method, args) {\n  const arr = toRaw(self);\n  track(arr, \"iterate\", ARRAY_ITERATE_KEY);\n  const res = arr[method](...args);\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method](...args);\n  }\n  return res;\n}\nfunction noTracking(self, method, args = []) {\n  pauseTracking();\n  startBatch();\n  const res = toRaw(self)[method].apply(self, args);\n  endBatch();\n  resetTracking();\n  return res;\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key)) key = String(key);\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _isShallow = false) {\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n  get(target, key, receiver) {\n    if (key === \"__v_skip\") return target[\"__v_skip\"];\n    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return isShallow2;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the receiver is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      let fn;\n      if (targetIsArray && (fn = arrayInstrumentations[key])) {\n        return fn;\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(\n      target,\n      key,\n      // if this is a proxy wrapping a ref, return methods using the raw ref\n      // as receiver so that we don't have to call `toRaw` on the ref in all\n      // its class methods\n      isRef(target) ? target : receiver\n    );\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (isShallow2) {\n      return res;\n    }\n    if (isRef(res)) {\n      const value = targetIsArray && isIntegerKey(key) ? res : res.value;\n      return isReadonly2 && isObject(value) ? readonly(value) : value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(false, isShallow2);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!this._isShallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            warn(\n              `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n              target[key]\n            );\n          }\n          return true;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(\n      target,\n      key,\n      value,\n      isRef(target) ? target : receiver\n    );\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(\n      target,\n      \"iterate\",\n      isArray(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(true, isShallow2);\n  }\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);\nconst shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction createIterableMethod(method, isReadonly2, isShallow2) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations(readonly, shallow) {\n  const instrumentations = {\n    get(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"get\", key);\n        }\n        track(rawTarget, \"get\", rawKey);\n      }\n      const { has } = getProto(rawTarget);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n      } else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n      } else if (target !== rawTarget) {\n        target.get(key);\n      }\n    },\n    get size() {\n      const target = this[\"__v_raw\"];\n      !readonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n      return target.size;\n    },\n    has(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"has\", key);\n        }\n        track(rawTarget, \"has\", rawKey);\n      }\n      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n    },\n    forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      !readonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    }\n  };\n  extend(\n    instrumentations,\n    readonly ? {\n      add: createReadonlyMethod(\"add\"),\n      set: createReadonlyMethod(\"set\"),\n      delete: createReadonlyMethod(\"delete\"),\n      clear: createReadonlyMethod(\"clear\")\n    } : {\n      add(value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const proto = getProto(target);\n        const hadKey = proto.has.call(target, value);\n        if (!hadKey) {\n          target.add(value);\n          trigger(target, \"add\", value, value);\n        }\n        return this;\n      },\n      set(key, value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get.call(target, key);\n        target.set(key, value);\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if (hasChanged(value, oldValue)) {\n          trigger(target, \"set\", key, value, oldValue);\n        }\n        return this;\n      },\n      delete(key) {\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get ? get.call(target, key) : void 0;\n        const result = target.delete(key);\n        if (hadKey) {\n          trigger(target, \"delete\", key, void 0, oldValue);\n        }\n        return result;\n      },\n      clear() {\n        const target = toRaw(this);\n        const hadItems = target.size !== 0;\n        const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n        const result = target.clear();\n        if (hadItems) {\n          trigger(\n            target,\n            \"clear\",\n            void 0,\n            void 0,\n            oldTarget\n          );\n        }\n        return result;\n      }\n    }\n  );\n  const iteratorMethods = [\n    \"keys\",\n    \"values\",\n    \"entries\",\n    Symbol.iterator\n  ];\n  iteratorMethods.forEach((method) => {\n    instrumentations[method] = createIterableMethod(method, readonly, shallow);\n  });\n  return instrumentations;\n}\nfunction createInstrumentationGetter(isReadonly2, shallow) {\n  const instrumentations = createInstrumentations(isReadonly2, shallow);\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `value cannot be made ${isReadonly2 ? \"readonly\" : \"reactive\"}: ${String(\n          target\n        )}`\n      );\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (!hasOwn(value, \"__v_skip\") && Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n  return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction isRef(r) {\n  return r ? r[\"__v_isRef\"] === true : false;\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, isShallow2) {\n    this.dep = new Dep();\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isShallow\"] = false;\n    this._rawValue = isShallow2 ? value : toRaw(value);\n    this._value = isShallow2 ? value : toReactive(value);\n    this[\"__v_isShallow\"] = isShallow2;\n  }\n  get value() {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.dep.track({\n        target: this,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      this.dep.track();\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    const oldValue = this._rawValue;\n    const useDirectValue = this[\"__v_isShallow\"] || isShallow(newValue) || isReadonly(newValue);\n    newValue = useDirectValue ? newValue : toRaw(newValue);\n    if (hasChanged(newValue, oldValue)) {\n      this._rawValue = newValue;\n      this._value = useDirectValue ? newValue : toReactive(newValue);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        this.dep.trigger({\n          target: this,\n          type: \"set\",\n          key: \"value\",\n          newValue,\n          oldValue\n        });\n      } else {\n        this.dep.trigger();\n      }\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  if (ref2.dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      ref2.dep.trigger({\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: ref2._value\n      });\n    } else {\n      ref2.dep.trigger();\n    }\n  }\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => key === \"__v_raw\" ? target : unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    const dep = this.dep = new Dep();\n    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._value = this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return this._value = val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isReadonly\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    return this._value = this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n  constructor(fn, setter, isSSR) {\n    this.fn = fn;\n    this.setter = setter;\n    /**\n     * @internal\n     */\n    this._value = void 0;\n    /**\n     * @internal\n     */\n    this.dep = new Dep(this);\n    /**\n     * @internal\n     */\n    this.__v_isRef = true;\n    // TODO isolatedDeclarations \"__v_isReadonly\"\n    // A computed is also a subscriber that tracks other deps\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 16;\n    /**\n     * @internal\n     */\n    this.globalVersion = globalVersion - 1;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    // for backwards compat\n    this.effect = this;\n    this[\"__v_isReadonly\"] = !setter;\n    this.isSSR = isSSR;\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    this.flags |= 16;\n    if (!(this.flags & 8) && // avoid infinite self recursion\n    activeSub !== this) {\n      batch(this, true);\n      return true;\n    } else if (!!(process.env.NODE_ENV !== \"production\")) ;\n  }\n  get value() {\n    const link = !!(process.env.NODE_ENV !== \"production\") ? this.dep.track({\n      target: this,\n      type: \"get\",\n      key: \"value\"\n    }) : this.dep.track();\n    refreshComputed(this);\n    if (link) {\n      link.version = this.dep.version;\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    if (this.setter) {\n      this.setter(newValue);\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\"Write operation failed: computed value is readonly\");\n    }\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.onTrack = debugOptions.onTrack;\n    cRef.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\",\n  \"IS_REF\": \"__v_isRef\"\n};\n\nconst WatchErrorCodes = {\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\"\n};\nconst INITIAL_WATCHER_VALUE = {};\nconst cleanupMap = /* @__PURE__ */ new WeakMap();\nlet activeWatcher = void 0;\nfunction getCurrentWatcher() {\n  return activeWatcher;\n}\nfunction onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {\n  if (owner) {\n    let cleanups = cleanupMap.get(owner);\n    if (!cleanups) cleanupMap.set(owner, cleanups = []);\n    cleanups.push(cleanupFn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onWatcherCleanup() was called when there was no active watcher to associate with.`\n    );\n  }\n}\nfunction watch(source, cb, options = EMPTY_OBJ) {\n  const { immediate, deep, once, scheduler, augmentJob, call } = options;\n  const warnInvalidSource = (s) => {\n    (options.onWarn || warn)(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`\n    );\n  };\n  const reactiveGetter = (source2) => {\n    if (deep) return source2;\n    if (isShallow(source2) || deep === false || deep === 0)\n      return traverse(source2, 1);\n    return traverse(source2);\n  };\n  let effect;\n  let getter;\n  let cleanup;\n  let boundCleanup;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source);\n    forceTrigger = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));\n    getter = () => source.map((s) => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return reactiveGetter(s);\n      } else if (isFunction(s)) {\n        return call ? call(s, 2) : s();\n      } else {\n        !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      getter = call ? () => call(source, 2) : source;\n    } else {\n      getter = () => {\n        if (cleanup) {\n          pauseTracking();\n          try {\n            cleanup();\n          } finally {\n            resetTracking();\n          }\n        }\n        const currentEffect = activeWatcher;\n        activeWatcher = effect;\n        try {\n          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);\n        } finally {\n          activeWatcher = currentEffect;\n        }\n      };\n    }\n  } else {\n    getter = NOOP;\n    !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    const depth = deep === true ? Infinity : deep;\n    getter = () => traverse(baseGetter(), depth);\n  }\n  const scope = getCurrentScope();\n  const watchHandle = () => {\n    effect.stop();\n    if (scope && scope.active) {\n      remove(scope.effects, effect);\n    }\n  };\n  if (once && cb) {\n    const _cb = cb;\n    cb = (...args) => {\n      _cb(...args);\n      watchHandle();\n    };\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = (immediateFirstRun) => {\n    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        if (cleanup) {\n          cleanup();\n        }\n        const currentWatcher = activeWatcher;\n        activeWatcher = effect;\n        try {\n          const args = [\n            newValue,\n            // pass undefined as the old value when it's changed for the first time\n            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,\n            boundCleanup\n          ];\n          oldValue = newValue;\n          call ? call(cb, 3, args) : (\n            // @ts-expect-error\n            cb(...args)\n          );\n        } finally {\n          activeWatcher = currentWatcher;\n        }\n      }\n    } else {\n      effect.run();\n    }\n  };\n  if (augmentJob) {\n    augmentJob(job);\n  }\n  effect = new ReactiveEffect(getter);\n  effect.scheduler = scheduler ? () => scheduler(job, false) : job;\n  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);\n  cleanup = effect.onStop = () => {\n    const cleanups = cleanupMap.get(effect);\n    if (cleanups) {\n      if (call) {\n        call(cleanups, 4);\n      } else {\n        for (const cleanup2 of cleanups) cleanup2();\n      }\n      cleanupMap.delete(effect);\n    }\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    effect.onTrack = options.onTrack;\n    effect.onTrigger = options.onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job(true);\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true);\n  } else {\n    effect.run();\n  }\n  watchHandle.pause = effect.pause.bind(effect);\n  watchHandle.resume = effect.resume.bind(effect);\n  watchHandle.stop = watchHandle;\n  return watchHandle;\n}\nfunction traverse(value, depth = Infinity, seen) {\n  if (depth <= 0 || !isObject(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */ new Map();\n  if ((seen.get(value) || 0) >= depth) {\n    return value;\n  }\n  seen.set(value, depth);\n  depth--;\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach((v) => {\n      traverse(v, depth, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, seen);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n      if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n        traverse(value[key], depth, seen);\n      }\n    }\n  }\n  return value;\n}\n\nexport { ARRAY_ITERATE_KEY, EffectFlags, EffectScope, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveEffect, ReactiveFlags, TrackOpTypes, TriggerOpTypes, WatchErrorCodes, computed, customRef, effect, effectScope, enableTracking, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onEffectCleanup, onScopeDispose, onWatcherCleanup, pauseTracking, proxyRefs, reactive, reactiveReadArray, readonly, ref, resetTracking, shallowReactive, shallowReadArray, shallowReadonly, shallowRef, stop, toRaw, toReactive, toReadonly, toRef, toRefs, toValue, track, traverse, trigger, triggerRef, unref, watch };\n","if (!Array.prototype.find) {\n    Array.prototype.find = function(predicate) {\n        if (this === null) {\n            throw new TypeError('Array.prototype.find called on null or undefined')\n        }\n        if (typeof predicate !== 'function') {\n            throw new TypeError('predicate must be a function')\n        }\n        var list = Object(this);\n        var length = list.length >>> 0;\n        var thisArg = arguments[1];\n        var value;\n\n        for (var i = 0; i < length; i++) {\n            value = list[i];\n            if (predicate.call(thisArg, value, i, list)) {\n                return value\n            }\n        }\n        return undefined\n    };\n}\n\nif (window && typeof window.CustomEvent !== \"function\") {\n  function CustomEvent$1(event, params) {\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: undefined\n    };\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt\n  }\n\n if (typeof window.Event !== 'undefined') {\n   CustomEvent$1.prototype = window.Event.prototype;\n }\n\n  window.CustomEvent = CustomEvent$1;\n}\n\nclass TributeEvents {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.events = this;\n  }\n\n  static keys() {\n    return [\n      {\n        key: 9,\n        value: \"TAB\"\n      },\n      {\n        key: 8,\n        value: \"DELETE\"\n      },\n      {\n        key: 13,\n        value: \"ENTER\"\n      },\n      {\n        key: 27,\n        value: \"ESCAPE\"\n      },\n      {\n        key: 32,\n        value: \"SPACE\"\n      },\n      {\n        key: 38,\n        value: \"UP\"\n      },\n      {\n        key: 40,\n        value: \"DOWN\"\n      }\n    ];\n  }\n\n  bind(element) {\n    element.boundKeydown = this.keydown.bind(element, this);\n    element.boundKeyup = this.keyup.bind(element, this);\n    element.boundInput = this.input.bind(element, this);\n\n    element.addEventListener(\"keydown\", element.boundKeydown, false);\n    element.addEventListener(\"keyup\", element.boundKeyup, false);\n    element.addEventListener(\"input\", element.boundInput, false);\n  }\n\n  unbind(element) {\n    element.removeEventListener(\"keydown\", element.boundKeydown, false);\n    element.removeEventListener(\"keyup\", element.boundKeyup, false);\n    element.removeEventListener(\"input\", element.boundInput, false);\n\n    delete element.boundKeydown;\n    delete element.boundKeyup;\n    delete element.boundInput;\n  }\n\n  keydown(instance, event) {\n    if (instance.shouldDeactivate(event)) {\n      instance.tribute.isActive = false;\n      instance.tribute.hideMenu();\n    }\n\n    let element = this;\n    instance.commandEvent = false;\n\n    TributeEvents.keys().forEach(o => {\n      if (o.key === event.keyCode) {\n        instance.commandEvent = true;\n        instance.callbacks()[o.value.toLowerCase()](event, element);\n      }\n    });\n  }\n\n  input(instance, event) {\n    instance.inputEvent = true;\n    instance.keyup.call(this, instance, event);\n  }\n\n  click(instance, event) {\n    let tribute = instance.tribute;\n    if (tribute.menu && tribute.menu.contains(event.target)) {\n      let li = event.target;\n      event.preventDefault();\n      event.stopPropagation();\n      while (li.nodeName.toLowerCase() !== \"li\") {\n        li = li.parentNode;\n        if (!li || li === tribute.menu) {\n          throw new Error(\"cannot find the <li> container for the click\");\n        }\n      }\n      tribute.selectItemAtIndex(li.getAttribute(\"data-index\"), event);\n      tribute.hideMenu();\n\n      // TODO: should fire with externalTrigger and target is outside of menu\n    } else if (tribute.current.element && !tribute.current.externalTrigger) {\n      tribute.current.externalTrigger = false;\n      setTimeout(() => tribute.hideMenu());\n    }\n  }\n\n  keyup(instance, event) {\n    if (instance.inputEvent) {\n      instance.inputEvent = false;\n    }\n    instance.updateSelection(this);\n\n    if (event.keyCode === 27) return;\n\n    if (!instance.tribute.allowSpaces && instance.tribute.hasTrailingSpace) {\n      instance.tribute.hasTrailingSpace = false;\n      instance.commandEvent = true;\n      instance.callbacks()[\"space\"](event, this);\n      return;\n    }\n\n    if (!instance.tribute.isActive) {\n      if (instance.tribute.autocompleteMode) {\n        instance.callbacks().triggerChar(event, this, \"\");\n      } else {\n        let keyCode = instance.getKeyCode(instance, this, event);\n\n        if (isNaN(keyCode) || !keyCode) return;\n\n        let trigger = instance.tribute.triggers().find(trigger => {\n          return trigger.charCodeAt(0) === keyCode;\n        });\n\n        if (typeof trigger !== \"undefined\") {\n          instance.callbacks().triggerChar(event, this, trigger);\n        }\n      }\n    }\n\n    if (\n      instance.tribute.current.mentionText.length <\n      instance.tribute.current.collection.menuShowMinLength\n    ) {\n      return;\n    }\n\n    if (\n      ((instance.tribute.current.trigger ||\n        instance.tribute.autocompleteMode) &&\n        instance.commandEvent === false) ||\n      (instance.tribute.isActive && event.keyCode === 8)\n    ) {\n      instance.tribute.showMenuFor(this, true);\n    }\n  }\n\n  shouldDeactivate(event) {\n    if (!this.tribute.isActive) return false;\n\n    if (this.tribute.current.mentionText.length === 0) {\n      let eventKeyPressed = false;\n      TributeEvents.keys().forEach(o => {\n        if (event.keyCode === o.key) eventKeyPressed = true;\n      });\n\n      return !eventKeyPressed;\n    }\n\n    return false;\n  }\n\n  getKeyCode(instance, el, event) {\n    let tribute = instance.tribute;\n    let info = tribute.range.getTriggerInfo(\n      false,\n      tribute.hasTrailingSpace,\n      true,\n      tribute.allowSpaces,\n      tribute.autocompleteMode\n    );\n\n    if (info) {\n      return info.mentionTriggerChar.charCodeAt(0);\n    } else {\n      return false;\n    }\n  }\n\n  updateSelection(el) {\n    this.tribute.current.element = el;\n    let info = this.tribute.range.getTriggerInfo(\n      false,\n      this.tribute.hasTrailingSpace,\n      true,\n      this.tribute.allowSpaces,\n      this.tribute.autocompleteMode\n    );\n\n    if (info) {\n      this.tribute.current.selectedPath = info.mentionSelectedPath;\n      this.tribute.current.mentionText = info.mentionText;\n      this.tribute.current.selectedOffset = info.mentionSelectedOffset;\n    }\n  }\n\n  callbacks() {\n    return {\n      triggerChar: (e, el, trigger) => {\n        let tribute = this.tribute;\n        tribute.current.trigger = trigger;\n\n        let collectionItem = tribute.collection.find(item => {\n          return item.trigger === trigger;\n        });\n\n        tribute.current.collection = collectionItem;\n\n        if (\n          tribute.current.mentionText.length >=\n            tribute.current.collection.menuShowMinLength &&\n          tribute.inputEvent\n        ) {\n          tribute.showMenuFor(el, true);\n        }\n      },\n      enter: (e, el) => {\n        // choose selection\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopPropagation();\n          setTimeout(() => {\n            this.tribute.selectItemAtIndex(this.tribute.menuSelected, e);\n            this.tribute.hideMenu();\n          }, 0);\n        }\n      },\n      escape: (e, el) => {\n        if (this.tribute.isActive) {\n          e.preventDefault();\n          e.stopPropagation();\n          this.tribute.isActive = false;\n          this.tribute.hideMenu();\n        }\n      },\n      tab: (e, el) => {\n        // choose first match\n        this.callbacks().enter(e, el);\n      },\n      space: (e, el) => {\n        if (this.tribute.isActive) {\n          if (this.tribute.spaceSelectsMatch) {\n            this.callbacks().enter(e, el);\n          } else if (!this.tribute.allowSpaces) {\n            e.stopPropagation();\n            setTimeout(() => {\n              this.tribute.hideMenu();\n              this.tribute.isActive = false;\n            }, 0);\n          }\n        }\n      },\n      up: (e, el) => {\n        // navigate up ul\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopPropagation();\n          let count = this.tribute.current.filteredItems.length,\n            selected = this.tribute.menuSelected;\n\n          if (count > selected && selected > 0) {\n            this.tribute.menuSelected--;\n            this.setActiveLi();\n          } else if (selected === 0) {\n            this.tribute.menuSelected = count - 1;\n            this.setActiveLi();\n            this.tribute.menu.scrollTop = this.tribute.menu.scrollHeight;\n          }\n        }\n      },\n      down: (e, el) => {\n        // navigate down ul\n        if (this.tribute.isActive && this.tribute.current.filteredItems) {\n          e.preventDefault();\n          e.stopPropagation();\n          let count = this.tribute.current.filteredItems.length - 1,\n            selected = this.tribute.menuSelected;\n\n          if (count > selected) {\n            this.tribute.menuSelected++;\n            this.setActiveLi();\n          } else if (count === selected) {\n            this.tribute.menuSelected = 0;\n            this.setActiveLi();\n            this.tribute.menu.scrollTop = 0;\n          }\n        }\n      },\n      delete: (e, el) => {\n        if (\n          this.tribute.isActive &&\n          this.tribute.current.mentionText.length < 1\n        ) {\n          this.tribute.hideMenu();\n        } else if (this.tribute.isActive) {\n          this.tribute.showMenuFor(el);\n        }\n      }\n    };\n  }\n\n  setActiveLi(index) {\n    let lis = this.tribute.menu.querySelectorAll(\"li\"),\n      length = lis.length >>> 0;\n\n    if (index) this.tribute.menuSelected = parseInt(index);\n\n    for (let i = 0; i < length; i++) {\n      let li = lis[i];\n      if (i === this.tribute.menuSelected) {\n        li.classList.add(this.tribute.current.collection.selectClass);\n\n        let liClientRect = li.getBoundingClientRect();\n        let menuClientRect = this.tribute.menu.getBoundingClientRect();\n\n        if (liClientRect.bottom > menuClientRect.bottom) {\n          let scrollDistance = liClientRect.bottom - menuClientRect.bottom;\n          this.tribute.menu.scrollTop += scrollDistance;\n        } else if (liClientRect.top < menuClientRect.top) {\n          let scrollDistance = menuClientRect.top - liClientRect.top;\n          this.tribute.menu.scrollTop -= scrollDistance;\n        }\n      } else {\n        li.classList.remove(this.tribute.current.collection.selectClass);\n      }\n    }\n  }\n\n  getFullHeight(elem, includeMargin) {\n    let height = elem.getBoundingClientRect().height;\n\n    if (includeMargin) {\n      let style = elem.currentStyle || window.getComputedStyle(elem);\n      return (\n        height + parseFloat(style.marginTop) + parseFloat(style.marginBottom)\n      );\n    }\n\n    return height;\n  }\n}\n\nclass TributeMenuEvents {\n  constructor(tribute) {\n    this.tribute = tribute;\n    this.tribute.menuEvents = this;\n    this.menu = this.tribute.menu;\n  }\n\n  bind(menu) {\n    this.menuClickEvent = this.tribute.events.click.bind(null, this);\n    this.menuContainerScrollEvent = this.debounce(\n      () => {\n        if (this.tribute.isActive) {\n          this.tribute.showMenuFor(this.tribute.current.element, false);\n        }\n      },\n      300,\n      false\n    );\n    this.windowResizeEvent = this.debounce(\n      () => {\n        if (this.tribute.isActive) {\n          this.tribute.range.positionMenuAtCaret(true);\n        }\n      },\n      300,\n      false\n    );\n\n    // fixes IE11 issues with mousedown\n    this.tribute.range\n      .getDocument()\n      .addEventListener(\"MSPointerDown\", this.menuClickEvent, false);\n    this.tribute.range\n      .getDocument()\n      .addEventListener(\"mousedown\", this.menuClickEvent, false);\n    window.addEventListener(\"resize\", this.windowResizeEvent);\n\n    if (this.menuContainer) {\n      this.menuContainer.addEventListener(\n        \"scroll\",\n        this.menuContainerScrollEvent,\n        false\n      );\n    } else {\n      window.addEventListener(\"scroll\", this.menuContainerScrollEvent);\n    }\n  }\n\n  unbind(menu) {\n    this.tribute.range\n      .getDocument()\n      .removeEventListener(\"mousedown\", this.menuClickEvent, false);\n    this.tribute.range\n      .getDocument()\n      .removeEventListener(\"MSPointerDown\", this.menuClickEvent, false);\n    window.removeEventListener(\"resize\", this.windowResizeEvent);\n\n    if (this.menuContainer) {\n      this.menuContainer.removeEventListener(\n        \"scroll\",\n        this.menuContainerScrollEvent,\n        false\n      );\n    } else {\n      window.removeEventListener(\"scroll\", this.menuContainerScrollEvent);\n    }\n  }\n\n  debounce(func, wait, immediate) {\n    var timeout;\n    return () => {\n      var context = this,\n        args = arguments;\n      var later = () => {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) func.apply(context, args);\n    };\n  }\n}\n\n// Thanks to https://github.com/jeff-collins/ment.io\n\nclass TributeRange {\n    constructor(tribute) {\n        this.tribute = tribute;\n        this.tribute.range = this;\n    }\n\n    getDocument() {\n        let iframe;\n        if (this.tribute.current.collection) {\n            iframe = this.tribute.current.collection.iframe;\n        }\n\n        if (!iframe) {\n            return document\n        }\n\n        return iframe.contentWindow.document\n    }\n\n    positionMenuAtCaret(scrollTo) {\n        let context = this.tribute.current,\n            coordinates;\n\n        let info = this.getTriggerInfo(false, this.tribute.hasTrailingSpace, true, this.tribute.allowSpaces, this.tribute.autocompleteMode);\n\n        if (typeof info !== 'undefined') {\n\n            if(!this.tribute.positionMenu){\n                this.tribute.menu.style.cssText = `display: block;`;\n                return\n            }\n\n            if (!this.isContentEditable(context.element)) {\n                coordinates = this.getTextAreaOrInputUnderlinePosition(this.tribute.current.element,\n                    info.mentionPosition);\n            }\n            else {\n                coordinates = this.getContentEditableCaretPosition(info.mentionPosition);\n            }\n\n            this.tribute.menu.style.cssText = `top: ${coordinates.top}px;\n                                     left: ${coordinates.left}px;\n                                     right: ${coordinates.right}px;\n                                     bottom: ${coordinates.bottom}px;\n                                     position: absolute;\n                                     display: block;`;\n\n            if (coordinates.left === 'auto') {\n                this.tribute.menu.style.left = 'auto';\n            }\n\n            if (coordinates.top === 'auto') {\n                this.tribute.menu.style.top = 'auto';\n            }\n\n            if (scrollTo) this.scrollIntoView();\n\n            window.setTimeout(() => {\n                let menuDimensions = {\n                   width: this.tribute.menu.offsetWidth,\n                   height: this.tribute.menu.offsetHeight\n                };\n                let menuIsOffScreen = this.isMenuOffScreen(coordinates, menuDimensions);\n\n                let menuIsOffScreenHorizontally = window.innerWidth > menuDimensions.width && (menuIsOffScreen.left || menuIsOffScreen.right);\n                let menuIsOffScreenVertically = window.innerHeight > menuDimensions.height && (menuIsOffScreen.top || menuIsOffScreen.bottom);\n                if (menuIsOffScreenHorizontally || menuIsOffScreenVertically) {\n                    this.tribute.menu.style.cssText = 'display: none';\n                    this.positionMenuAtCaret(scrollTo);\n                }\n            }, 0);\n\n        } else {\n            this.tribute.menu.style.cssText = 'display: none';\n        }\n    }\n\n    get menuContainerIsBody() {\n        return this.tribute.menuContainer === document.body || !this.tribute.menuContainer;\n    }\n\n\n    selectElement(targetElement, path, offset) {\n        let range;\n        let elem = targetElement;\n\n        if (path) {\n            for (var i = 0; i < path.length; i++) {\n                elem = elem.childNodes[path[i]];\n                if (elem === undefined) {\n                    return\n                }\n                while (elem.length < offset) {\n                    offset -= elem.length;\n                    elem = elem.nextSibling;\n                }\n                if (elem.childNodes.length === 0 && !elem.length) {\n                    elem = elem.previousSibling;\n                }\n            }\n        }\n        let sel = this.getWindowSelection();\n\n        range = this.getDocument().createRange();\n        range.setStart(elem, offset);\n        range.setEnd(elem, offset);\n        range.collapse(true);\n\n        try {\n            sel.removeAllRanges();\n        } catch (error) {}\n\n        sel.addRange(range);\n        targetElement.focus();\n    }\n\n    replaceTriggerText(text, requireLeadingSpace, hasTrailingSpace, originalEvent, item) {\n        let info = this.getTriggerInfo(true, hasTrailingSpace, requireLeadingSpace, this.tribute.allowSpaces, this.tribute.autocompleteMode);\n\n        if (info !== undefined) {\n            let context = this.tribute.current;\n            let replaceEvent = new CustomEvent('tribute-replaced', {\n                detail: {\n                    item: item,\n                    instance: context,\n                    context: info,\n                    event: originalEvent,\n                }\n            });\n\n            if (!this.isContentEditable(context.element)) {\n                let myField = this.tribute.current.element;\n                let textSuffix = typeof this.tribute.replaceTextSuffix == 'string'\n                    ? this.tribute.replaceTextSuffix\n                    : ' ';\n                text += textSuffix;\n                let startPos = info.mentionPosition;\n                let endPos = info.mentionPosition + info.mentionText.length + textSuffix.length;\n                if (!this.tribute.autocompleteMode) {\n                    endPos += info.mentionTriggerChar.length - 1;\n                }\n                myField.value = myField.value.substring(0, startPos) + text +\n                    myField.value.substring(endPos, myField.value.length);\n                myField.selectionStart = startPos + text.length;\n                myField.selectionEnd = startPos + text.length;\n            } else {\n                // add a space to the end of the pasted text\n                let textSuffix = typeof this.tribute.replaceTextSuffix == 'string'\n                    ? this.tribute.replaceTextSuffix\n                    : '\\xA0';\n                text += textSuffix;\n                let endPos = info.mentionPosition + info.mentionText.length;\n                if (!this.tribute.autocompleteMode) {\n                    endPos += info.mentionTriggerChar.length;\n                }\n                this.pasteHtml(text, info.mentionPosition, endPos);\n            }\n\n            context.element.dispatchEvent(new CustomEvent('input', { bubbles: true }));\n            context.element.dispatchEvent(replaceEvent);\n        }\n    }\n\n    pasteHtml(html, startPos, endPos) {\n        let range, sel;\n        sel = this.getWindowSelection();\n        range = this.getDocument().createRange();\n        range.setStart(sel.anchorNode, startPos);\n        range.setEnd(sel.anchorNode, endPos);\n        range.deleteContents();\n\n        let el = this.getDocument().createElement('div');\n        el.innerHTML = html;\n        let frag = this.getDocument().createDocumentFragment(),\n            node, lastNode;\n        while ((node = el.firstChild)) {\n            lastNode = frag.appendChild(node);\n        }\n        range.insertNode(frag);\n\n        // Preserve the selection\n        if (lastNode) {\n            range = range.cloneRange();\n            range.setStartAfter(lastNode);\n            range.collapse(true);\n            sel.removeAllRanges();\n            sel.addRange(range);\n        }\n    }\n\n    getWindowSelection() {\n        if (this.tribute.collection.iframe) {\n            return this.tribute.collection.iframe.contentWindow.getSelection()\n        }\n\n        return window.getSelection()\n    }\n\n    getNodePositionInParent(element) {\n        if (element.parentNode === null) {\n            return 0\n        }\n\n        for (var i = 0; i < element.parentNode.childNodes.length; i++) {\n            let node = element.parentNode.childNodes[i];\n\n            if (node === element) {\n                return i\n            }\n        }\n    }\n\n    getContentEditableSelectedPath(ctx) {\n        let sel = this.getWindowSelection();\n        let selected = sel.anchorNode;\n        let path = [];\n        let offset;\n\n        if (selected != null) {\n            let i;\n            let ce = selected.contentEditable;\n            while (selected !== null && ce !== 'true') {\n                i = this.getNodePositionInParent(selected);\n                path.push(i);\n                selected = selected.parentNode;\n                if (selected !== null) {\n                    ce = selected.contentEditable;\n                }\n            }\n            path.reverse();\n\n            // getRangeAt may not exist, need alternative\n            offset = sel.getRangeAt(0).startOffset;\n\n            return {\n                selected: selected,\n                path: path,\n                offset: offset\n            }\n        }\n    }\n\n    getTextPrecedingCurrentSelection() {\n        let context = this.tribute.current,\n            text = '';\n\n        if (!this.isContentEditable(context.element)) {\n            let textComponent = this.tribute.current.element;\n            if (textComponent) {\n                let startPos = textComponent.selectionStart;\n                if (textComponent.value && startPos >= 0) {\n                    text = textComponent.value.substring(0, startPos);\n                }\n            }\n\n        } else {\n            let selectedElem = this.getWindowSelection().anchorNode;\n\n            if (selectedElem != null) {\n                let workingNodeContent = selectedElem.textContent;\n                let selectStartOffset = this.getWindowSelection().getRangeAt(0).startOffset;\n\n                if (workingNodeContent && selectStartOffset >= 0) {\n                    text = workingNodeContent.substring(0, selectStartOffset);\n                }\n            }\n        }\n\n        return text\n    }\n\n    getLastWordInText(text) {\n        text = text.replace(/\\u00A0/g, ' '); // https://stackoverflow.com/questions/29850407/how-do-i-replace-unicode-character-u00a0-with-a-space-in-javascript\n        let wordsArray = text.split(/\\s+/);\n        let worldsCount = wordsArray.length - 1;\n        return wordsArray[worldsCount].trim()\n    }\n\n    getTriggerInfo(menuAlreadyActive, hasTrailingSpace, requireLeadingSpace, allowSpaces, isAutocomplete) {\n        let ctx = this.tribute.current;\n        let selected, path, offset;\n\n        if (!this.isContentEditable(ctx.element)) {\n            selected = this.tribute.current.element;\n        } else {\n            let selectionInfo = this.getContentEditableSelectedPath(ctx);\n\n            if (selectionInfo) {\n                selected = selectionInfo.selected;\n                path = selectionInfo.path;\n                offset = selectionInfo.offset;\n            }\n        }\n\n        let effectiveRange = this.getTextPrecedingCurrentSelection();\n        let lastWordOfEffectiveRange = this.getLastWordInText(effectiveRange);\n\n        if (isAutocomplete) {\n            return {\n                mentionPosition: effectiveRange.length - lastWordOfEffectiveRange.length,\n                mentionText: lastWordOfEffectiveRange,\n                mentionSelectedElement: selected,\n                mentionSelectedPath: path,\n                mentionSelectedOffset: offset\n            }\n        }\n\n        if (effectiveRange !== undefined && effectiveRange !== null) {\n            let mostRecentTriggerCharPos = -1;\n            let triggerChar;\n\n            this.tribute.collection.forEach(config => {\n                let c = config.trigger;\n                let idx = config.requireLeadingSpace ?\n                    this.lastIndexWithLeadingSpace(effectiveRange, c) :\n                    effectiveRange.lastIndexOf(c);\n\n                if (idx > mostRecentTriggerCharPos) {\n                    mostRecentTriggerCharPos = idx;\n                    triggerChar = c;\n                    requireLeadingSpace = config.requireLeadingSpace;\n                }\n            });\n\n            if (mostRecentTriggerCharPos >= 0 &&\n                (\n                    mostRecentTriggerCharPos === 0 ||\n                    !requireLeadingSpace ||\n                    /[\\xA0\\s]/g.test(\n                        effectiveRange.substring(\n                            mostRecentTriggerCharPos - 1,\n                            mostRecentTriggerCharPos)\n                    )\n                )\n            ) {\n                let currentTriggerSnippet = effectiveRange.substring(mostRecentTriggerCharPos + triggerChar.length,\n                    effectiveRange.length);\n\n                triggerChar = effectiveRange.substring(mostRecentTriggerCharPos, mostRecentTriggerCharPos + triggerChar.length);\n                let firstSnippetChar = currentTriggerSnippet.substring(0, 1);\n                let leadingSpace = currentTriggerSnippet.length > 0 &&\n                    (\n                        firstSnippetChar === ' ' ||\n                        firstSnippetChar === '\\xA0'\n                    );\n                if (hasTrailingSpace) {\n                    currentTriggerSnippet = currentTriggerSnippet.trim();\n                }\n\n                let regex = allowSpaces ? /[^\\S ]/g : /[\\xA0\\s]/g;\n\n                this.tribute.hasTrailingSpace = regex.test(currentTriggerSnippet);\n\n                if (!leadingSpace && (menuAlreadyActive || !(regex.test(currentTriggerSnippet)))) {\n                    return {\n                        mentionPosition: mostRecentTriggerCharPos,\n                        mentionText: currentTriggerSnippet,\n                        mentionSelectedElement: selected,\n                        mentionSelectedPath: path,\n                        mentionSelectedOffset: offset,\n                        mentionTriggerChar: triggerChar\n                    }\n                }\n            }\n        }\n    }\n\n    lastIndexWithLeadingSpace (str, trigger) {\n        let reversedStr = str.split('').reverse().join('');\n        let index = -1;\n\n        for (let cidx = 0, len = str.length; cidx < len; cidx++) {\n            let firstChar = cidx === str.length - 1;\n            let leadingSpace = /\\s/.test(reversedStr[cidx + 1]);\n\n            let match = true;\n            for (let triggerIdx = trigger.length - 1; triggerIdx >= 0; triggerIdx--) {\n              if (trigger[triggerIdx] !== reversedStr[cidx-triggerIdx]) {\n                match = false;\n                break\n              }\n            }\n\n            if (match && (firstChar || leadingSpace)) {\n                index = str.length - 1 - cidx;\n                break\n            }\n        }\n\n        return index\n    }\n\n    isContentEditable(element) {\n        return element.nodeName !== 'INPUT' && element.nodeName !== 'TEXTAREA'\n    }\n\n    isMenuOffScreen(coordinates, menuDimensions) {\n        let windowWidth = window.innerWidth;\n        let windowHeight = window.innerHeight;\n        let doc = document.documentElement;\n        let windowLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n        let windowTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n\n        let menuTop = typeof coordinates.top === 'number' ? coordinates.top : windowTop + windowHeight - coordinates.bottom - menuDimensions.height;\n        let menuRight = typeof coordinates.right === 'number' ? coordinates.right : coordinates.left + menuDimensions.width;\n        let menuBottom = typeof coordinates.bottom === 'number' ? coordinates.bottom : coordinates.top + menuDimensions.height;\n        let menuLeft = typeof coordinates.left === 'number' ? coordinates.left : windowLeft + windowWidth - coordinates.right - menuDimensions.width;\n\n        return {\n            top: menuTop < Math.floor(windowTop),\n            right: menuRight > Math.ceil(windowLeft + windowWidth),\n            bottom: menuBottom > Math.ceil(windowTop + windowHeight),\n            left: menuLeft < Math.floor(windowLeft)\n        }\n    }\n\n    getMenuDimensions() {\n        // Width of the menu depends of its contents and position\n        // We must check what its width would be without any obstruction\n        // This way, we can achieve good positioning for flipping the menu\n        let dimensions = {\n            width: null,\n            height: null\n        };\n\n        this.tribute.menu.style.cssText = `top: 0px;\n                                 left: 0px;\n                                 position: fixed;\n                                 display: block;\n                                 visibility; hidden;`;\n       dimensions.width = this.tribute.menu.offsetWidth;\n       dimensions.height = this.tribute.menu.offsetHeight;\n\n       this.tribute.menu.style.cssText = `display: none;`;\n\n       return dimensions\n    }\n\n    getTextAreaOrInputUnderlinePosition(element, position, flipped) {\n        let properties = ['direction', 'boxSizing', 'width', 'height', 'overflowX',\n            'overflowY', 'borderTopWidth', 'borderRightWidth',\n            'borderBottomWidth', 'borderLeftWidth', 'paddingTop',\n            'paddingRight', 'paddingBottom', 'paddingLeft',\n            'fontStyle', 'fontVariant', 'fontWeight', 'fontStretch',\n            'fontSize', 'fontSizeAdjust', 'lineHeight', 'fontFamily',\n            'textAlign', 'textTransform', 'textIndent',\n            'textDecoration', 'letterSpacing', 'wordSpacing'\n        ];\n\n        let isFirefox = (window.mozInnerScreenX !== null);\n\n        let div = this.getDocument().createElement('div');\n        div.id = 'input-textarea-caret-position-mirror-div';\n        this.getDocument().body.appendChild(div);\n\n        let style = div.style;\n        let computed = window.getComputedStyle ? getComputedStyle(element) : element.currentStyle;\n\n        style.whiteSpace = 'pre-wrap';\n        if (element.nodeName !== 'INPUT') {\n            style.wordWrap = 'break-word';\n        }\n\n        // position off-screen\n        style.position = 'absolute';\n        style.visibility = 'hidden';\n\n        // transfer the element's properties to the div\n        properties.forEach(prop => {\n            style[prop] = computed[prop];\n        });\n\n        if (isFirefox) {\n            style.width = `${(parseInt(computed.width) - 2)}px`;\n            if (element.scrollHeight > parseInt(computed.height))\n                style.overflowY = 'scroll';\n        } else {\n            style.overflow = 'hidden';\n        }\n\n        div.textContent = element.value.substring(0, position);\n\n        if (element.nodeName === 'INPUT') {\n            div.textContent = div.textContent.replace(/\\s/g, '');\n        }\n\n        let span = this.getDocument().createElement('span');\n        span.textContent = element.value.substring(position) || '.';\n        div.appendChild(span);\n\n        let rect = element.getBoundingClientRect();\n        let doc = document.documentElement;\n        let windowLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n        let windowTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n\n        let top = 0;\n        let left = 0;\n        if (this.menuContainerIsBody) {\n          top = rect.top;\n          left = rect.left;\n        }\n\n        let coordinates = {\n            top: top + windowTop + span.offsetTop + parseInt(computed.borderTopWidth) + parseInt(computed.fontSize) - element.scrollTop,\n            left: left + windowLeft + span.offsetLeft + parseInt(computed.borderLeftWidth)\n        };\n\n        let windowWidth = window.innerWidth;\n        let windowHeight = window.innerHeight;\n\n        let menuDimensions = this.getMenuDimensions();\n        let menuIsOffScreen = this.isMenuOffScreen(coordinates, menuDimensions);\n\n        if (menuIsOffScreen.right) {\n            coordinates.right = windowWidth - coordinates.left;\n            coordinates.left = 'auto';\n        }\n\n        let parentHeight = this.tribute.menuContainer\n            ? this.tribute.menuContainer.offsetHeight\n            : this.getDocument().body.offsetHeight;\n\n        if (menuIsOffScreen.bottom) {\n            let parentRect = this.tribute.menuContainer\n                ? this.tribute.menuContainer.getBoundingClientRect()\n                : this.getDocument().body.getBoundingClientRect();\n            let scrollStillAvailable = parentHeight - (windowHeight - parentRect.top);\n\n            coordinates.bottom = scrollStillAvailable + (windowHeight - rect.top - span.offsetTop);\n            coordinates.top = 'auto';\n        }\n\n        menuIsOffScreen = this.isMenuOffScreen(coordinates, menuDimensions);\n        if (menuIsOffScreen.left) {\n            coordinates.left = windowWidth > menuDimensions.width\n                ? windowLeft + windowWidth - menuDimensions.width\n                : windowLeft;\n            delete coordinates.right;\n        }\n        if (menuIsOffScreen.top) {\n            coordinates.top = windowHeight > menuDimensions.height\n                ? windowTop + windowHeight - menuDimensions.height\n                : windowTop;\n            delete coordinates.bottom;\n        }\n\n        this.getDocument().body.removeChild(div);\n        return coordinates\n    }\n\n    getContentEditableCaretPosition(selectedNodePosition) {\n        let range;\n        let sel = this.getWindowSelection();\n\n        range = this.getDocument().createRange();\n        range.setStart(sel.anchorNode, selectedNodePosition);\n        range.setEnd(sel.anchorNode, selectedNodePosition);\n\n        range.collapse(false);\n\n        let rect = range.getBoundingClientRect();\n        let doc = document.documentElement;\n        let windowLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n        let windowTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n\n        let left = rect.left;\n        let top = rect.top;\n\n        let coordinates = {\n            left: left + windowLeft,\n            top: top + rect.height + windowTop\n        };\n        let windowWidth = window.innerWidth;\n        let windowHeight = window.innerHeight;\n\n        let menuDimensions = this.getMenuDimensions();\n        let menuIsOffScreen = this.isMenuOffScreen(coordinates, menuDimensions);\n\n        if (menuIsOffScreen.right) {\n            coordinates.left = 'auto';\n            coordinates.right = windowWidth - rect.left - windowLeft;\n        }\n\n        let parentHeight = this.tribute.menuContainer\n            ? this.tribute.menuContainer.offsetHeight\n            : this.getDocument().body.offsetHeight;\n\n        if (menuIsOffScreen.bottom) {\n            let parentRect = this.tribute.menuContainer\n                ? this.tribute.menuContainer.getBoundingClientRect()\n                : this.getDocument().body.getBoundingClientRect();\n            let scrollStillAvailable = parentHeight - (windowHeight - parentRect.top);\n\n            coordinates.top = 'auto';\n            coordinates.bottom = scrollStillAvailable + (windowHeight - rect.top);\n        }\n\n        menuIsOffScreen = this.isMenuOffScreen(coordinates, menuDimensions);\n        if (menuIsOffScreen.left) {\n            coordinates.left = windowWidth > menuDimensions.width\n                ? windowLeft + windowWidth - menuDimensions.width\n                : windowLeft;\n            delete coordinates.right;\n        }\n        if (menuIsOffScreen.top) {\n            coordinates.top = windowHeight > menuDimensions.height\n                ? windowTop + windowHeight - menuDimensions.height\n                : windowTop;\n            delete coordinates.bottom;\n        }\n\n        if (!this.menuContainerIsBody) {\n            coordinates.left = coordinates.left ? coordinates.left - this.tribute.menuContainer.offsetLeft : coordinates.left;\n            coordinates.top = coordinates.top ? coordinates.top - this.tribute.menuContainer.offsetTop : coordinates.top;\n        }\n\n        return coordinates\n    }\n\n    scrollIntoView(elem) {\n        let reasonableBuffer = 20,\n            clientRect;\n        let maxScrollDisplacement = 100;\n        let e = this.menu;\n\n        if (typeof e === 'undefined') return;\n\n        while (clientRect === undefined || clientRect.height === 0) {\n            clientRect = e.getBoundingClientRect();\n\n            if (clientRect.height === 0) {\n                e = e.childNodes[0];\n                if (e === undefined || !e.getBoundingClientRect) {\n                    return\n                }\n            }\n        }\n\n        let elemTop = clientRect.top;\n        let elemBottom = elemTop + clientRect.height;\n\n        if (elemTop < 0) {\n            window.scrollTo(0, window.pageYOffset + clientRect.top - reasonableBuffer);\n        } else if (elemBottom > window.innerHeight) {\n            let maxY = window.pageYOffset + clientRect.top - reasonableBuffer;\n\n            if (maxY - window.pageYOffset > maxScrollDisplacement) {\n                maxY = window.pageYOffset + maxScrollDisplacement;\n            }\n\n            let targetY = window.pageYOffset - (window.innerHeight - elemBottom);\n\n            if (targetY > maxY) {\n                targetY = maxY;\n            }\n\n            window.scrollTo(0, targetY);\n        }\n    }\n}\n\n// Thanks to https://github.com/mattyork/fuzzy\nclass TributeSearch {\n    constructor(tribute) {\n        this.tribute = tribute;\n        this.tribute.search = this;\n    }\n\n    simpleFilter(pattern, array) {\n        return array.filter(string => {\n            return this.test(pattern, string)\n        })\n    }\n\n    test(pattern, string) {\n        return this.match(pattern, string) !== null\n    }\n\n    match(pattern, string, opts) {\n        opts = opts || {};\n        let len = string.length,\n            pre = opts.pre || '',\n            post = opts.post || '',\n            compareString = opts.caseSensitive && string || string.toLowerCase();\n\n        if (opts.skip) {\n            return {rendered: string, score: 0}\n        }\n\n        pattern = opts.caseSensitive && pattern || pattern.toLowerCase();\n\n        let patternCache = this.traverse(compareString, pattern, 0, 0, []);\n        if (!patternCache) {\n            return null\n        }\n        return {\n            rendered: this.render(string, patternCache.cache, pre, post),\n            score: patternCache.score\n        }\n    }\n\n    traverse(string, pattern, stringIndex, patternIndex, patternCache) {\n        // if the pattern search at end\n        if (pattern.length === patternIndex) {\n\n            // calculate score and copy the cache containing the indices where it's found\n            return {\n                score: this.calculateScore(patternCache),\n                cache: patternCache.slice()\n            }\n        }\n\n        // if string at end or remaining pattern > remaining string\n        if (string.length === stringIndex || pattern.length - patternIndex > string.length - stringIndex) {\n            return undefined\n        }\n\n        let c = pattern[patternIndex];\n        let index = string.indexOf(c, stringIndex);\n        let best, temp;\n\n        while (index > -1) {\n            patternCache.push(index);\n            temp = this.traverse(string, pattern, index + 1, patternIndex + 1, patternCache);\n            patternCache.pop();\n\n            // if downstream traversal failed, return best answer so far\n            if (!temp) {\n                return best\n            }\n\n            if (!best || best.score < temp.score) {\n                best = temp;\n            }\n\n            index = string.indexOf(c, index + 1);\n        }\n\n        return best\n    }\n\n    calculateScore(patternCache) {\n        let score = 0;\n        let temp = 1;\n\n        patternCache.forEach((index, i) => {\n            if (i > 0) {\n                if (patternCache[i - 1] + 1 === index) {\n                    temp += temp + 1;\n                }\n                else {\n                    temp = 1;\n                }\n            }\n\n            score += temp;\n        });\n\n        return score\n    }\n\n    render(string, indices, pre, post) {\n        var rendered = string.substring(0, indices[0]);\n\n        indices.forEach((index, i) => {\n            rendered += pre + string[index] + post +\n                string.substring(index + 1, (indices[i + 1]) ? indices[i + 1] : string.length);\n        });\n\n        return rendered\n    }\n\n    filter(pattern, arr, opts) {\n        opts = opts || {};\n        return arr\n            .reduce((prev, element, idx, arr) => {\n                let str = element;\n\n                if (opts.extract) {\n                    str = opts.extract(element);\n\n                    if (!str) { // take care of undefineds / nulls / etc.\n                        str = '';\n                    }\n                }\n\n                let rendered = this.match(pattern, str, opts);\n\n                if (rendered != null) {\n                    prev[prev.length] = {\n                        string: rendered.rendered,\n                        score: rendered.score,\n                        index: idx,\n                        original: element\n                    };\n                }\n\n                return prev\n            }, [])\n\n        .sort((a, b) => {\n            let compare = b.score - a.score;\n            if (compare) return compare\n            return a.index - b.index\n        })\n    }\n}\n\nclass Tribute {\n  constructor({\n    values = null,\n    iframe = null,\n    selectClass = \"highlight\",\n    containerClass = \"tribute-container\",\n    itemClass = \"\",\n    trigger = \"@\",\n    autocompleteMode = false,\n    selectTemplate = null,\n    menuItemTemplate = null,\n    lookup = \"key\",\n    fillAttr = \"value\",\n    collection = null,\n    menuContainer = null,\n    noMatchTemplate = null,\n    requireLeadingSpace = true,\n    allowSpaces = false,\n    replaceTextSuffix = null,\n    positionMenu = true,\n    spaceSelectsMatch = false,\n    searchOpts = {},\n    menuItemLimit = null,\n    menuShowMinLength = 0\n  }) {\n    this.autocompleteMode = autocompleteMode;\n    this.menuSelected = 0;\n    this.current = {};\n    this.inputEvent = false;\n    this.isActive = false;\n    this.menuContainer = menuContainer;\n    this.allowSpaces = allowSpaces;\n    this.replaceTextSuffix = replaceTextSuffix;\n    this.positionMenu = positionMenu;\n    this.hasTrailingSpace = false;\n    this.spaceSelectsMatch = spaceSelectsMatch;\n\n    if (this.autocompleteMode) {\n      trigger = \"\";\n      allowSpaces = false;\n    }\n\n    if (values) {\n      this.collection = [\n        {\n          // symbol that starts the lookup\n          trigger: trigger,\n\n          // is it wrapped in an iframe\n          iframe: iframe,\n\n          // class applied to selected item\n          selectClass: selectClass,\n\n          // class applied to the Container\n          containerClass: containerClass,\n\n          // class applied to each item\n          itemClass: itemClass,\n\n          // function called on select that retuns the content to insert\n          selectTemplate: (\n            selectTemplate || Tribute.defaultSelectTemplate\n          ).bind(this),\n\n          // function called that returns content for an item\n          menuItemTemplate: (\n            menuItemTemplate || Tribute.defaultMenuItemTemplate\n          ).bind(this),\n\n          // function called when menu is empty, disables hiding of menu.\n          noMatchTemplate: (t => {\n            if (typeof t === \"string\") {\n              if (t.trim() === \"\") return null;\n              return t;\n            }\n            if (typeof t === \"function\") {\n              return t.bind(this);\n            }\n\n            return (\n              noMatchTemplate ||\n              function() {\n                return \"<li>No Match Found!</li>\";\n              }.bind(this)\n            );\n          })(noMatchTemplate),\n\n          // column to search against in the object\n          lookup: lookup,\n\n          // column that contains the content to insert by default\n          fillAttr: fillAttr,\n\n          // array of objects or a function returning an array of objects\n          values: values,\n\n          requireLeadingSpace: requireLeadingSpace,\n\n          searchOpts: searchOpts,\n\n          menuItemLimit: menuItemLimit,\n\n          menuShowMinLength: menuShowMinLength\n        }\n      ];\n    } else if (collection) {\n      if (this.autocompleteMode)\n        console.warn(\n          \"Tribute in autocomplete mode does not work for collections\"\n        );\n      this.collection = collection.map(item => {\n        return {\n          trigger: item.trigger || trigger,\n          iframe: item.iframe || iframe,\n          selectClass: item.selectClass || selectClass,\n          containerClass: item.containerClass || containerClass,\n          itemClass: item.itemClass || itemClass,\n          selectTemplate: (\n            item.selectTemplate || Tribute.defaultSelectTemplate\n          ).bind(this),\n          menuItemTemplate: (\n            item.menuItemTemplate || Tribute.defaultMenuItemTemplate\n          ).bind(this),\n          // function called when menu is empty, disables hiding of menu.\n          noMatchTemplate: (t => {\n            if (typeof t === \"string\") {\n              if (t.trim() === \"\") return null;\n              return t;\n            }\n            if (typeof t === \"function\") {\n              return t.bind(this);\n            }\n\n            return (\n              noMatchTemplate ||\n              function() {\n                return \"<li>No Match Found!</li>\";\n              }.bind(this)\n            );\n          })(noMatchTemplate),\n          lookup: item.lookup || lookup,\n          fillAttr: item.fillAttr || fillAttr,\n          values: item.values,\n          requireLeadingSpace: item.requireLeadingSpace,\n          searchOpts: item.searchOpts || searchOpts,\n          menuItemLimit: item.menuItemLimit || menuItemLimit,\n          menuShowMinLength: item.menuShowMinLength || menuShowMinLength\n        };\n      });\n    } else {\n      throw new Error(\"[Tribute] No collection specified.\");\n    }\n\n    new TributeRange(this);\n    new TributeEvents(this);\n    new TributeMenuEvents(this);\n    new TributeSearch(this);\n  }\n\n  get isActive() {\n    return this._isActive;\n  }\n\n  set isActive(val) {\n    if (this._isActive != val) {\n      this._isActive = val;\n      if (this.current.element) {\n        let noMatchEvent = new CustomEvent(`tribute-active-${val}`);\n        this.current.element.dispatchEvent(noMatchEvent);\n      }\n    }\n  }\n\n  static defaultSelectTemplate(item) {\n    if (typeof item === \"undefined\")\n      return `${this.current.collection.trigger}${this.current.mentionText}`;\n    if (this.range.isContentEditable(this.current.element)) {\n      return (\n        '<span class=\"tribute-mention\">' +\n        (this.current.collection.trigger +\n          item.original[this.current.collection.fillAttr]) +\n        \"</span>\"\n      );\n    }\n\n    return (\n      this.current.collection.trigger +\n      item.original[this.current.collection.fillAttr]\n    );\n  }\n\n  static defaultMenuItemTemplate(matchItem) {\n    return matchItem.string;\n  }\n\n  static inputTypes() {\n    return [\"TEXTAREA\", \"INPUT\"];\n  }\n\n  triggers() {\n    return this.collection.map(config => {\n      return config.trigger;\n    });\n  }\n\n  attach(el) {\n    if (!el) {\n      throw new Error(\"[Tribute] Must pass in a DOM node or NodeList.\");\n    }\n\n    // Check if it is a jQuery collection\n    if (typeof jQuery !== \"undefined\" && el instanceof jQuery) {\n      el = el.get();\n    }\n\n    // Is el an Array/Array-like object?\n    if (\n      el.constructor === NodeList ||\n      el.constructor === HTMLCollection ||\n      el.constructor === Array\n    ) {\n      let length = el.length;\n      for (var i = 0; i < length; ++i) {\n        this._attach(el[i]);\n      }\n    } else {\n      this._attach(el);\n    }\n  }\n\n  _attach(el) {\n    if (el.hasAttribute(\"data-tribute\")) {\n      console.warn(\"Tribute was already bound to \" + el.nodeName);\n    }\n\n    this.ensureEditable(el);\n    this.events.bind(el);\n    el.setAttribute(\"data-tribute\", true);\n  }\n\n  ensureEditable(element) {\n    if (Tribute.inputTypes().indexOf(element.nodeName) === -1) {\n      if (element.contentEditable) {\n        element.contentEditable = true;\n      } else {\n        throw new Error(\"[Tribute] Cannot bind to \" + element.nodeName);\n      }\n    }\n  }\n\n  createMenu(containerClass) {\n    let wrapper = this.range.getDocument().createElement(\"div\"),\n      ul = this.range.getDocument().createElement(\"ul\");\n    wrapper.className = containerClass;\n    wrapper.appendChild(ul);\n\n    if (this.menuContainer) {\n      return this.menuContainer.appendChild(wrapper);\n    }\n\n    return this.range.getDocument().body.appendChild(wrapper);\n  }\n\n  showMenuFor(element, scrollTo) {\n    // Only proceed if menu isn't already shown for the current element & mentionText\n    if (\n      this.isActive &&\n      this.current.element === element &&\n      this.current.mentionText === this.currentMentionTextSnapshot\n    ) {\n      return;\n    }\n    this.currentMentionTextSnapshot = this.current.mentionText;\n\n    // create the menu if it doesn't exist.\n    if (!this.menu) {\n      this.menu = this.createMenu(this.current.collection.containerClass);\n      element.tributeMenu = this.menu;\n      this.menuEvents.bind(this.menu);\n    }\n\n    this.isActive = true;\n    this.menuSelected = 0;\n\n    if (!this.current.mentionText) {\n      this.current.mentionText = \"\";\n    }\n\n    const processValues = values => {\n      // Tribute may not be active any more by the time the value callback returns\n      if (!this.isActive) {\n        return;\n      }\n\n      let items = this.search.filter(this.current.mentionText, values, {\n        pre: this.current.collection.searchOpts.pre || \"<span>\",\n        post: this.current.collection.searchOpts.post || \"</span>\",\n        skip: this.current.collection.searchOpts.skip,\n        extract: el => {\n          if (typeof this.current.collection.lookup === \"string\") {\n            return el[this.current.collection.lookup];\n          } else if (typeof this.current.collection.lookup === \"function\") {\n            return this.current.collection.lookup(el, this.current.mentionText);\n          } else {\n            throw new Error(\n              \"Invalid lookup attribute, lookup must be string or function.\"\n            );\n          }\n        }\n      });\n\n      if (this.current.collection.menuItemLimit) {\n        items = items.slice(0, this.current.collection.menuItemLimit);\n      }\n\n      this.current.filteredItems = items;\n\n      let ul = this.menu.querySelector(\"ul\");\n\n      this.range.positionMenuAtCaret(scrollTo);\n\n      if (!items.length) {\n        let noMatchEvent = new CustomEvent(\"tribute-no-match\", {\n          detail: this.menu\n        });\n        this.current.element.dispatchEvent(noMatchEvent);\n        if (\n          (typeof this.current.collection.noMatchTemplate === \"function\" &&\n            !this.current.collection.noMatchTemplate()) ||\n          !this.current.collection.noMatchTemplate\n        ) {\n          this.hideMenu();\n        } else {\n          typeof this.current.collection.noMatchTemplate === \"function\"\n            ? (ul.innerHTML = this.current.collection.noMatchTemplate())\n            : (ul.innerHTML = this.current.collection.noMatchTemplate);\n        }\n\n        return;\n      }\n\n      ul.innerHTML = \"\";\n      let fragment = this.range.getDocument().createDocumentFragment();\n\n      items.forEach((item, index) => {\n        let li = this.range.getDocument().createElement(\"li\");\n        li.setAttribute(\"data-index\", index);\n        li.className = this.current.collection.itemClass;\n        li.addEventListener(\"mousemove\", e => {\n          let [li, index] = this._findLiTarget(e.target);\n          if (e.movementY !== 0) {\n            this.events.setActiveLi(index);\n          }\n        });\n        if (this.menuSelected === index) {\n          li.classList.add(this.current.collection.selectClass);\n        }\n        li.innerHTML = this.current.collection.menuItemTemplate(item);\n        fragment.appendChild(li);\n      });\n      ul.appendChild(fragment);\n    };\n\n    if (typeof this.current.collection.values === \"function\") {\n      this.current.collection.values(this.current.mentionText, processValues);\n    } else {\n      processValues(this.current.collection.values);\n    }\n  }\n\n  _findLiTarget(el) {\n    if (!el) return [];\n    const index = el.getAttribute(\"data-index\");\n    return !index ? this._findLiTarget(el.parentNode) : [el, index];\n  }\n\n  showMenuForCollection(element, collectionIndex) {\n    if (element !== document.activeElement) {\n      this.placeCaretAtEnd(element);\n    }\n\n    this.current.collection = this.collection[collectionIndex || 0];\n    this.current.externalTrigger = true;\n    this.current.element = element;\n\n    if (element.isContentEditable)\n      this.insertTextAtCursor(this.current.collection.trigger);\n    else this.insertAtCaret(element, this.current.collection.trigger);\n\n    this.showMenuFor(element);\n  }\n\n  // TODO: make sure this works for inputs/textareas\n  placeCaretAtEnd(el) {\n    el.focus();\n    if (\n      typeof window.getSelection != \"undefined\" &&\n      typeof document.createRange != \"undefined\"\n    ) {\n      var range = document.createRange();\n      range.selectNodeContents(el);\n      range.collapse(false);\n      var sel = window.getSelection();\n      sel.removeAllRanges();\n      sel.addRange(range);\n    } else if (typeof document.body.createTextRange != \"undefined\") {\n      var textRange = document.body.createTextRange();\n      textRange.moveToElementText(el);\n      textRange.collapse(false);\n      textRange.select();\n    }\n  }\n\n  // for contenteditable\n  insertTextAtCursor(text) {\n    var sel, range;\n    sel = window.getSelection();\n    range = sel.getRangeAt(0);\n    range.deleteContents();\n    var textNode = document.createTextNode(text);\n    range.insertNode(textNode);\n    range.selectNodeContents(textNode);\n    range.collapse(false);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  }\n\n  // for regular inputs\n  insertAtCaret(textarea, text) {\n    var scrollPos = textarea.scrollTop;\n    var caretPos = textarea.selectionStart;\n\n    var front = textarea.value.substring(0, caretPos);\n    var back = textarea.value.substring(\n      textarea.selectionEnd,\n      textarea.value.length\n    );\n    textarea.value = front + text + back;\n    caretPos = caretPos + text.length;\n    textarea.selectionStart = caretPos;\n    textarea.selectionEnd = caretPos;\n    textarea.focus();\n    textarea.scrollTop = scrollPos;\n  }\n\n  hideMenu() {\n    if (this.menu) {\n      this.menu.style.cssText = \"display: none;\";\n      this.isActive = false;\n      this.menuSelected = 0;\n      this.current = {};\n    }\n  }\n\n  selectItemAtIndex(index, originalEvent) {\n    index = parseInt(index);\n    if (typeof index !== \"number\" || isNaN(index)) return;\n    let item = this.current.filteredItems[index];\n    let content = this.current.collection.selectTemplate(item);\n    if (content !== null) this.replaceText(content, originalEvent, item);\n  }\n\n  replaceText(content, originalEvent, item) {\n    this.range.replaceTriggerText(content, true, true, originalEvent, item);\n  }\n\n  _append(collection, newValues, replace) {\n    if (typeof collection.values === \"function\") {\n      throw new Error(\"Unable to append to values, as it is a function.\");\n    } else if (!replace) {\n      collection.values = collection.values.concat(newValues);\n    } else {\n      collection.values = newValues;\n    }\n  }\n\n  append(collectionIndex, newValues, replace) {\n    let index = parseInt(collectionIndex);\n    if (typeof index !== \"number\")\n      throw new Error(\"please provide an index for the collection to update.\");\n\n    let collection = this.collection[index];\n\n    this._append(collection, newValues, replace);\n  }\n\n  appendCurrent(newValues, replace) {\n    if (this.isActive) {\n      this._append(this.current.collection, newValues, replace);\n    } else {\n      throw new Error(\n        \"No active state. Please use append instead and pass an index.\"\n      );\n    }\n  }\n\n  detach(el) {\n    if (!el) {\n      throw new Error(\"[Tribute] Must pass in a DOM node or NodeList.\");\n    }\n\n    // Check if it is a jQuery collection\n    if (typeof jQuery !== \"undefined\" && el instanceof jQuery) {\n      el = el.get();\n    }\n\n    // Is el an Array/Array-like object?\n    if (\n      el.constructor === NodeList ||\n      el.constructor === HTMLCollection ||\n      el.constructor === Array\n    ) {\n      let length = el.length;\n      for (var i = 0; i < length; ++i) {\n        this._detach(el[i]);\n      }\n    } else {\n      this._detach(el);\n    }\n  }\n\n  _detach(el) {\n    this.events.unbind(el);\n    if (el.tributeMenu) {\n      this.menuEvents.unbind(el.tributeMenu);\n    }\n\n    setTimeout(() => {\n      el.removeAttribute(\"data-tribute\");\n      this.isActive = false;\n      if (el.tributeMenu) {\n        el.tributeMenu.remove();\n      }\n    });\n  }\n}\n\n/**\n * Tribute.js\n * Native ES6 JavaScript @mention Plugin\n **/\n\nexport default Tribute;\n"],"x_google_ignoreList":[0,1],"mappings":"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"}