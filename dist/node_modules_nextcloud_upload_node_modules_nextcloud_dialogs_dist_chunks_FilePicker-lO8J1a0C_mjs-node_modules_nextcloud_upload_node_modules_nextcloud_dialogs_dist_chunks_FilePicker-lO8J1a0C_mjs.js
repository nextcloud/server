"use strict";
(globalThis["webpackChunknextcloud_ui_legacy"] = globalThis["webpackChunknextcloud_ui_legacy"] || []).push([["node_modules_nextcloud_upload_node_modules_nextcloud_dialogs_dist_chunks_FilePicker-lO8J1a0C_mjs"],{

/***/ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/dist/chunks/FilePicker-lO8J1a0C.mjs":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/dist/chunks/FilePicker-lO8J1a0C.mjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FilePicker)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.runtime.esm.js");
/* harmony import */ var _plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_plugin-vue2_normalizer-jrlE7CJU.mjs */ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/dist/chunks/_plugin-vue2_normalizer-jrlE7CJU.mjs");
/* harmony import */ var _nextcloud_files__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @nextcloud/files */ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/files/dist/index.mjs");
/* harmony import */ var _nextcloud_vue_components_NcButton__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @nextcloud/vue/components/NcButton */ "./node_modules/@nextcloud/vue/dist/Components/NcButton.mjs");
/* harmony import */ var _nextcloud_vue_components_NcCheckboxRadioSwitch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @nextcloud/vue/components/NcCheckboxRadioSwitch */ "./node_modules/@nextcloud/vue/dist/Components/NcCheckboxRadioSwitch.mjs");
/* harmony import */ var _nextcloud_initial_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @nextcloud/initial-state */ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/initial-state/dist/index.js");
/* harmony import */ var _nextcloud_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @nextcloud/router */ "./node_modules/@nextcloud/router/dist/index.mjs");
/* harmony import */ var _nextcloud_sharing_public__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @nextcloud/sharing/public */ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/sharing/dist/public.js");
/* harmony import */ var _vueuse_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @vueuse/core */ "./node_modules/@vueuse/shared/index.mjs");
/* harmony import */ var _nextcloud_axios__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @nextcloud/axios */ "./node_modules/@nextcloud/axios/dist/index.mjs");
/* harmony import */ var _nextcloud_vue_components_NcDateTime__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @nextcloud/vue/components/NcDateTime */ "./node_modules/@nextcloud/vue/dist/Components/NcDateTime.mjs");
/* harmony import */ var _mdi_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @mdi/js */ "./node_modules/@mdi/js/mdi.js");
/* harmony import */ var _nextcloud_sharing__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @nextcloud/sharing */ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/sharing/dist/index.js");
/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! p-queue */ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/p-queue/dist/index.js");
/* harmony import */ var _nextcloud_vue_components_NcIconSvgWrapper__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @nextcloud/vue/components/NcIconSvgWrapper */ "./node_modules/@nextcloud/vue/dist/Components/NcIconSvgWrapper.mjs");
/* harmony import */ var _nextcloud_vue_components_NcActions__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @nextcloud/vue/components/NcActions */ "./node_modules/@nextcloud/vue/dist/Components/NcActions.mjs");
/* harmony import */ var _nextcloud_vue_components_NcActionInput__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @nextcloud/vue/components/NcActionInput */ "./node_modules/@nextcloud/vue/dist/Components/NcActionInput.mjs");
/* harmony import */ var _nextcloud_vue_components_NcBreadcrumbs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @nextcloud/vue/components/NcBreadcrumbs */ "./node_modules/@nextcloud/vue/dist/Components/NcBreadcrumbs.mjs");
/* harmony import */ var _nextcloud_vue_components_NcBreadcrumb__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @nextcloud/vue/components/NcBreadcrumb */ "./node_modules/@nextcloud/vue/dist/Components/NcBreadcrumb.mjs");
/* harmony import */ var _nextcloud_auth__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @nextcloud/auth */ "./node_modules/@nextcloud/auth/dist/index.mjs");
/* harmony import */ var _nextcloud_vue_components_NcSelect__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @nextcloud/vue/components/NcSelect */ "./node_modules/@nextcloud/vue/dist/Components/NcSelect.mjs");
/* harmony import */ var _nextcloud_vue_components_NcTextField__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @nextcloud/vue/components/NcTextField */ "./node_modules/@nextcloud/vue/dist/Components/NcTextField.mjs");
/* harmony import */ var vue_frag__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! vue-frag */ "./node_modules/vue-frag/dist/frag.esm.js");
/* harmony import */ var _nextcloud_event_bus__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @nextcloud/event-bus */ "./node_modules/@nextcloud/event-bus/dist/index.mjs");
/* harmony import */ var _nextcloud_vue_components_NcDialog__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @nextcloud/vue/components/NcDialog */ "./node_modules/@nextcloud/vue/dist/Components/NcDialog.mjs");
/* harmony import */ var _nextcloud_vue_components_NcEmptyContent__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @nextcloud/vue/components/NcEmptyContent */ "./node_modules/@nextcloud/vue/dist/Components/NcEmptyContent.mjs");
/* harmony import */ var cancelable_promise__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! cancelable-promise */ "./node_modules/cancelable-promise/umd/CancelablePromise.js");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! path */ "./node_modules/path/path.js");




























const _sfc_main$e = {
  name: "FileIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$e = function render() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon file-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M13,9V3.5L18.5,9M6,2C4.89,2 4,2.89 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2H6Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$e = [];
var __component__$e = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main$e,
  _sfc_render$e,
  _sfc_staticRenderFns$e,
  false,
  null,
  null
);
const IconFile = __component__$e.exports;
const useFilesSettings = () => {
  const filesUserState = (0,_nextcloud_initial_state__WEBPACK_IMPORTED_MODULE_5__.loadState)("files", "config", null);
  const showHiddenFiles = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(filesUserState?.show_hidden ?? true);
  const sortFavoritesFirst = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(filesUserState?.sort_favorites_first ?? true);
  const cropImagePreviews = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(filesUserState?.crop_image_previews ?? true);
  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
    if (!(0,_nextcloud_sharing_public__WEBPACK_IMPORTED_MODULE_7__.isPublicShare)()) {
      try {
        const { data } = await _nextcloud_axios__WEBPACK_IMPORTED_MODULE_9__["default"].get((0,_nextcloud_router__WEBPACK_IMPORTED_MODULE_6__.generateUrl)("/apps/files/api/v1/configs"));
        showHiddenFiles.value = data?.data?.show_hidden ?? false;
        sortFavoritesFirst.value = data?.data?.sort_favorites_first ?? true;
        cropImagePreviews.value = data?.data?.crop_image_previews ?? true;
      } catch (error) {
        console.error("Could not load files settings", error);
        (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.l)((0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)("Could not load files settings"));
      }
    } else {
      console.debug("Skip loading files settings - currently on public share");
    }
  });
  return {
    showHiddenFiles,
    sortFavoritesFirst,
    cropImagePreviews
  };
};
const useFilesViews = (currentView) => {
  const convertOrder = (order2) => order2 === "asc" ? "ascending" : order2 === "desc" ? "descending" : "none";
  const filesViewsState = (0,_nextcloud_initial_state__WEBPACK_IMPORTED_MODULE_5__.loadState)("files", "viewConfigs", null);
  const filesViewConfig = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({
    sortBy: filesViewsState?.files?.sorting_mode ?? "basename",
    order: convertOrder(filesViewsState?.files?.sorting_direction ?? "asc")
  });
  const recentViewConfig = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({
    sortBy: filesViewsState?.recent?.sorting_mode ?? "basename",
    order: convertOrder(filesViewsState?.recent?.sorting_direction ?? "asc")
  });
  const favoritesViewConfig = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)({
    sortBy: filesViewsState?.favorites?.sorting_mode ?? "basename",
    order: convertOrder(filesViewsState?.favorites?.sorting_direction ?? "asc")
  });
  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(async () => {
    if (!(0,_nextcloud_sharing_public__WEBPACK_IMPORTED_MODULE_7__.isPublicShare)()) {
      try {
        const { data } = await _nextcloud_axios__WEBPACK_IMPORTED_MODULE_9__["default"].get((0,_nextcloud_router__WEBPACK_IMPORTED_MODULE_6__.generateUrl)("/apps/files/api/v1/views"));
        filesViewConfig.value = {
          sortBy: data?.data?.files?.sorting_mode ?? "basename",
          order: convertOrder(data?.data?.files?.sorting_direction)
        };
        favoritesViewConfig.value = {
          sortBy: data?.data?.favorites?.sorting_mode ?? "basename",
          order: convertOrder(data?.data?.favorites?.sorting_direction)
        };
        recentViewConfig.value = {
          sortBy: data?.data?.recent?.sorting_mode ?? "basename",
          order: convertOrder(data?.data?.recent?.sorting_direction)
        };
      } catch (error) {
        console.error("Could not load files views", error);
        (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.l)((0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)("Could not load files views"));
      }
    } else {
      console.debug("Skip loading files views - currently on public share");
    }
  });
  const currentConfig = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (0,_vueuse_core__WEBPACK_IMPORTED_MODULE_8__.toValue)(currentView || "files") === "files" ? filesViewConfig.value : (0,_vueuse_core__WEBPACK_IMPORTED_MODULE_8__.toValue)(currentView) === "recent" ? recentViewConfig.value : favoritesViewConfig.value);
  const sortBy = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => currentConfig.value.sortBy);
  const order = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => currentConfig.value.order);
  return {
    filesViewConfig,
    favoritesViewConfig,
    recentViewConfig,
    currentConfig,
    sortBy,
    order
  };
};
const _sfc_main$d = {
  name: "MenuUpIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$d = function render2() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon menu-up-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M7,15L12,10L17,15H7Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$d = [];
var __component__$d = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main$d,
  _sfc_render$d,
  _sfc_staticRenderFns$d,
  false,
  null,
  null
);
const IconSortAscending = __component__$d.exports;
const _sfc_main$c = {
  name: "MenuDownIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$c = function render3() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon menu-down-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M7,10L12,15L17,10H7Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$c = [];
var __component__$c = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main$c,
  _sfc_render$c,
  _sfc_staticRenderFns$c,
  false,
  null,
  null
);
const IconSortDescending = __component__$c.exports;
const fileListIconStylesModule = {
  "file-picker__file-icon": "_file-picker__file-icon_3v9zx_9",
  "file-picker__file-icon--primary": "_file-picker__file-icon--primary_3v9zx_21",
  "file-picker__file-icon-overlay": "_file-picker__file-icon-overlay_3v9zx_25"
};
const _sfc_main$b = /* @__PURE__ */ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
  __name: "LoadingTableRow",
  props: {
    showCheckbox: { type: Boolean }
  },
  setup(__props) {
    return { __sfc: true, fileListIconStyles: fileListIconStylesModule };
  }
});
var _sfc_render$b = function render4() {
  var _vm = this, _c = _vm._self._c, _setup = _vm._self._setupProxy;
  return _c("tr", { staticClass: "file-picker__row loading-row", attrs: { "aria-hidden": "true" } }, [_vm.showCheckbox ? _c("td", { staticClass: "row-checkbox" }, [_c("span")]) : _vm._e(), _c("td", { staticClass: "row-name" }, [_c("div", { staticClass: "row-wrapper" }, [_c("span", { class: _setup.fileListIconStyles["file-picker__file-icon"] }), _c("span")])]), _vm._m(0), _vm._m(1)]);
};
var _sfc_staticRenderFns$b = [function() {
  var _vm = this, _c = _vm._self._c;
  _vm._self._setupProxy;
  return _c("td", { staticClass: "row-size" }, [_c("span")]);
}, function() {
  var _vm = this, _c = _vm._self._c;
  _vm._self._setupProxy;
  return _c("td", { staticClass: "row-modified" }, [_c("span")]);
}];
var __component__$b = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main$b,
  _sfc_render$b,
  _sfc_staticRenderFns$b,
  false,
  null,
  "15187afc"
);
const LoadingTableRow = __component__$b.exports;
const queue = new p_queue__WEBPACK_IMPORTED_MODULE_13__["default"]({ concurrency: 5 });
function preloadImage(url) {
  const { resolve, promise } = Promise.withResolvers();
  queue.add(() => {
    const image = new Image();
    image.onerror = () => resolve(false);
    image.onload = () => resolve(true);
    image.src = url;
    return promise;
  });
  return promise;
}
function getPreviewURL(node, options = {}) {
  options = { size: 32, cropPreview: false, mimeFallback: true, ...options };
  try {
    const previewUrl = node.attributes?.previewUrl || (0,_nextcloud_router__WEBPACK_IMPORTED_MODULE_6__.generateUrl)("/core/preview?fileId={fileid}", {
      fileid: node.fileid
    });
    let url;
    try {
      url = new URL(previewUrl);
    } catch (e) {
      url = new URL(previewUrl, window.location.origin);
    }
    url.searchParams.set("x", `${options.size}`);
    url.searchParams.set("y", `${options.size}`);
    url.searchParams.set("mimeFallback", `${options.mimeFallback}`);
    url.searchParams.set("a", options.cropPreview === true ? "0" : "1");
    url.searchParams.set("c", `${node.attributes.etag}`);
    return url;
  } catch (e) {
    return null;
  }
}
const usePreviewURL = (node, options) => {
  const previewURL = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
  const previewLoaded = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
  (0,vue__WEBPACK_IMPORTED_MODULE_0__.watchEffect)(() => {
    previewLoaded.value = false;
    previewURL.value = getPreviewURL((0,_vueuse_core__WEBPACK_IMPORTED_MODULE_8__.toValue)(node), (0,_vueuse_core__WEBPACK_IMPORTED_MODULE_8__.toValue)(options || {}));
    if (previewURL.value && (0,_vueuse_core__WEBPACK_IMPORTED_MODULE_8__.toValue)(node).type === _nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.FileType.File) {
      preloadImage(previewURL.value.href).then((success) => {
        previewLoaded.value = success;
      });
    }
  });
  return {
    previewURL,
    previewLoaded
  };
};
const _sfc_main$a = {
  name: "FolderIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$a = function render5() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon folder-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M10,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V8C22,6.89 21.1,6 20,6H12L10,4Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$a = [];
var __component__$a = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main$a,
  _sfc_render$a,
  _sfc_staticRenderFns$a,
  false,
  null,
  null
);
const IconFolder = __component__$a.exports;
const __default__$1 = {
  name: "FilePreview"
};
const _sfc_main$9 = /* @__PURE__ */ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
  ...__default__$1,
  props: {
    node: null,
    cropImagePreviews: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    const fileListIconStyles = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(fileListIconStylesModule);
    const {
      previewURL,
      previewLoaded
    } = usePreviewURL((0,vue__WEBPACK_IMPORTED_MODULE_0__.toRef)(props, "node"), (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => ({ cropPreview: props.cropImagePreviews })));
    const isFile = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.node.type === _nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.FileType.File);
    const folderDecorationIcon = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      if (props.node.type !== _nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.FileType.Folder) {
        return null;
      }
      if (props.node.attributes?.["is-encrypted"] === 1) {
        return _mdi_js__WEBPACK_IMPORTED_MODULE_11__.mdiLock;
      }
      if (props.node.attributes?.["is-tag"]) {
        return _mdi_js__WEBPACK_IMPORTED_MODULE_11__.mdiTag;
      }
      const shareTypes = Object.values(props.node.attributes?.["share-types"] || {}).flat();
      if (shareTypes.some((type) => type === _nextcloud_sharing__WEBPACK_IMPORTED_MODULE_12__.ShareType.Link || type === _nextcloud_sharing__WEBPACK_IMPORTED_MODULE_12__.ShareType.Email)) {
        return _mdi_js__WEBPACK_IMPORTED_MODULE_11__.mdiLink;
      }
      if (shareTypes.length > 0) {
        return _mdi_js__WEBPACK_IMPORTED_MODULE_11__.mdiAccountPlus;
      }
      switch (props.node.attributes?.["mount-type"]) {
        case "external":
        case "external-session":
          return _mdi_js__WEBPACK_IMPORTED_MODULE_11__.mdiNetwork;
        case "group":
          return _mdi_js__WEBPACK_IMPORTED_MODULE_11__.mdiGroup;
        case "shared":
          return _mdi_js__WEBPACK_IMPORTED_MODULE_11__.mdiAccountPlus;
      }
      return null;
    });
    return { __sfc: true, fileListIconStyles, props, previewURL, previewLoaded, isFile, folderDecorationIcon, NcIconSvgWrapper: _nextcloud_vue_components_NcIconSvgWrapper__WEBPACK_IMPORTED_MODULE_14__["default"], IconFile, IconFolder };
  }
});
var _sfc_render$9 = function render6() {
  var _vm = this, _c = _vm._self._c, _setup = _vm._self._setupProxy;
  return _c("div", { class: _setup.fileListIconStyles["file-picker__file-icon"], style: _setup.previewLoaded ? { backgroundImage: `url(${_setup.previewURL})` } : void 0 }, [!_setup.previewLoaded ? [_setup.isFile ? _c(_setup.IconFile, { attrs: { "size": 32 } }) : [_setup.folderDecorationIcon ? _c(_setup.NcIconSvgWrapper, { class: _setup.fileListIconStyles["file-picker__file-icon-overlay"], attrs: { "inline": "", "path": _setup.folderDecorationIcon, "size": 16 } }) : _vm._e(), _c(_setup.IconFolder, { class: _setup.fileListIconStyles["file-picker__file-icon--primary"], attrs: { "size": 32 } })]] : _vm._e()], 2);
};
var _sfc_staticRenderFns$9 = [];
var __component__$9 = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main$9,
  _sfc_render$9,
  _sfc_staticRenderFns$9,
  false,
  null,
  null
);
const FilePreview = __component__$9.exports;
const _sfc_main$8 = /* @__PURE__ */ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
  __name: "FileListRow",
  props: {
    allowPickDirectory: { type: Boolean },
    selected: { type: Boolean },
    showCheckbox: { type: Boolean },
    canPick: { type: Boolean },
    node: null,
    cropImagePreviews: { type: Boolean }
  },
  emits: ["update:selected", "enter-directory"],
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const displayName = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.node.attributes?.displayName || props.node.basename.slice(0, props.node.extension ? -props.node.extension.length : void 0));
    const fileExtension = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.node.extension);
    const isDirectory = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.node.type === _nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.FileType.Folder);
    const isPickable = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.canPick && (props.allowPickDirectory || !isDirectory.value));
    const isNavigatable = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => (props.node.permissions & _nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.Permission.READ) === _nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.Permission.READ);
    function toggleSelected() {
      if (!isPickable.value) {
        return;
      }
      emit2("update:selected", !props.selected);
    }
    function handleClick() {
      if (isDirectory.value) {
        if (isNavigatable.value) {
          emit2("enter-directory", props.node);
        }
      } else {
        toggleSelected();
      }
    }
    function handleKeyDown(event) {
      if (event.key === "Enter") {
        handleClick();
      }
    }
    return { __sfc: true, props, emit: emit2, displayName, fileExtension, isDirectory, isPickable, isNavigatable, toggleSelected, handleClick, handleKeyDown, formatFileSize: _nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.formatFileSize, NcCheckboxRadioSwitch: _nextcloud_vue_components_NcCheckboxRadioSwitch__WEBPACK_IMPORTED_MODULE_4__["default"], NcDateTime: _nextcloud_vue_components_NcDateTime__WEBPACK_IMPORTED_MODULE_10__["default"], t: _plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t, FilePreview };
  }
});
var _sfc_render$8 = function render7() {
  var _vm = this, _c = _vm._self._c, _setup = _vm._self._setupProxy;
  return _c("tr", _vm._g({ class: ["file-picker__row", {
    "file-picker__row--selected": _vm.selected && !_vm.showCheckbox,
    "file-picker__row--not-navigatable": _setup.isDirectory && !_setup.isNavigatable,
    "file-picker__row--not-pickable": !_setup.isPickable
  }], attrs: { "tabindex": _vm.showCheckbox && !_setup.isDirectory ? void 0 : 0, "aria-selected": !_setup.isPickable ? void 0 : _vm.selected, "data-filename": _vm.node.basename, "data-testid": "file-list-row" } }, {
    click: _setup.handleClick,
    /* same as tabindex -> if we hide the checkbox or this is a directory we need keyboard access to enter the directory or select the node */
    ...!_vm.showCheckbox || _setup.isDirectory ? { keydown: _setup.handleKeyDown } : {}
  }), [_vm.showCheckbox ? _c("td", { staticClass: "row-checkbox", on: { "click": function($event) {
    $event.stopPropagation();
    return (() => {
    }).apply(null, arguments);
  } } }, [_c(_setup.NcCheckboxRadioSwitch, { attrs: { "aria-label": _setup.t("Select the row for {nodename}", { nodename: _setup.displayName }), "disabled": !_setup.isPickable, "data-testid": "row-checkbox", "model-value": _vm.selected }, on: { "update:model-value": _setup.toggleSelected } })], 1) : _vm._e(), _c("td", { staticClass: "row-name" }, [_c("div", { staticClass: "file-picker__name-container", attrs: { "data-testid": "row-name" } }, [_c(_setup.FilePreview, { attrs: { "node": _vm.node, "crop-image-previews": _vm.cropImagePreviews } }), _c("div", { staticClass: "file-picker__file-name", attrs: { "title": _setup.displayName }, domProps: { "textContent": _vm._s(_setup.displayName) } }), _c("div", { staticClass: "file-picker__file-extension", domProps: { "textContent": _vm._s(_setup.fileExtension) } })], 1)]), _c("td", { staticClass: "row-size" }, [_vm._v(" " + _vm._s(_setup.formatFileSize(_vm.node.size || 0)) + " ")]), _c("td", { staticClass: "row-modified" }, [_c(_setup.NcDateTime, { attrs: { "timestamp": _vm.node.mtime, "ignore-seconds": true } })], 1)]);
};
var _sfc_staticRenderFns$8 = [];
var __component__$8 = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main$8,
  _sfc_render$8,
  _sfc_staticRenderFns$8,
  false,
  null,
  "ba4db9f8"
);
const FileListRow = __component__$8.exports;
const _sfc_main$7 = /* @__PURE__ */ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
  __name: "FileList",
  props: {
    currentView: null,
    multiselect: { type: Boolean },
    allowPickDirectory: { type: Boolean },
    loading: { type: Boolean },
    files: null,
    canPick: null,
    selectedFiles: null,
    path: null
  },
  emits: ["update:path", "update:selectedFiles"],
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const customSortingConfig = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)();
    const { currentConfig: filesAppSorting } = useFilesViews(props.currentView);
    const sortingConfig = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => customSortingConfig.value ?? filesAppSorting.value);
    const sortByName = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => sortingConfig.value.sortBy === "basename" ? sortingConfig.value.order === "none" ? void 0 : sortingConfig.value.order : void 0);
    const sortBySize = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => sortingConfig.value.sortBy === "size" ? sortingConfig.value.order === "none" ? void 0 : sortingConfig.value.order : void 0);
    const sortByModified = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => sortingConfig.value.sortBy === "mtime" ? sortingConfig.value.order === "none" ? void 0 : sortingConfig.value.order : void 0);
    const toggleSorting = (sortBy) => {
      if (sortingConfig.value.sortBy === sortBy) {
        if (sortingConfig.value.order === "ascending") {
          customSortingConfig.value = { sortBy: sortingConfig.value.sortBy, order: "descending" };
        } else {
          customSortingConfig.value = { sortBy: sortingConfig.value.sortBy, order: "ascending" };
        }
      } else {
        customSortingConfig.value = { sortBy, order: "ascending" };
      }
    };
    const { sortFavoritesFirst, cropImagePreviews } = useFilesSettings();
    const sortedFiles = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      return (0,_nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.sortNodes)(props.files, {
        sortFoldersFirst: true,
        sortFavoritesFirst: sortFavoritesFirst.value,
        sortingOrder: sortingConfig.value.order === "descending" ? "desc" : "asc",
        sortingMode: sortingConfig.value.sortBy
      });
    });
    const selectableFiles = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => props.files.filter((file) => props.allowPickDirectory || file.type !== _nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.FileType.Folder));
    const allSelected = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => !props.loading && props.selectedFiles.length > 0 && props.selectedFiles.length >= selectableFiles.value.length);
    function onSelectAll() {
      if (props.selectedFiles.length < selectableFiles.value.length) {
        emit2("update:selectedFiles", selectableFiles.value);
      } else {
        emit2("update:selectedFiles", []);
      }
    }
    function onNodeSelected(file) {
      if (props.selectedFiles.includes(file)) {
        emit2("update:selectedFiles", props.selectedFiles.filter((f) => f.path !== file.path));
      } else {
        if (props.multiselect) {
          emit2("update:selectedFiles", [...props.selectedFiles, file]);
        } else {
          emit2("update:selectedFiles", [file]);
        }
      }
    }
    function onChangeDirectory(dir) {
      emit2("update:path", dir.path);
    }
    const skeletonNumber = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(4);
    const fileContainer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)();
    {
      const resize = () => (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
        const nodes = fileContainer.value?.parentElement?.children || [];
        let height = fileContainer.value?.parentElement?.clientHeight || 450;
        for (let index = 0; index < nodes.length; index++) {
          if (!fileContainer.value?.isSameNode(nodes[index])) {
            height -= nodes[index].clientHeight;
          }
        }
        skeletonNumber.value = Math.max(1, Math.floor((height - 50) / 50));
      });
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
        window.addEventListener("resize", resize);
        resize();
      });
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.onUnmounted)(() => {
        window.removeEventListener("resize", resize);
      });
    }
    return { __sfc: true, props, emit: emit2, customSortingConfig, filesAppSorting, sortingConfig, sortByName, sortBySize, sortByModified, toggleSorting, sortFavoritesFirst, cropImagePreviews, sortedFiles, selectableFiles, allSelected, onSelectAll, onNodeSelected, onChangeDirectory, skeletonNumber, fileContainer, NcButton: _nextcloud_vue_components_NcButton__WEBPACK_IMPORTED_MODULE_3__["default"], NcCheckboxRadioSwitch: _nextcloud_vue_components_NcCheckboxRadioSwitch__WEBPACK_IMPORTED_MODULE_4__["default"], t: _plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t, IconSortAscending, IconSortDescending, LoadingTableRow, FileListRow };
  }
});
var _sfc_render$7 = function render8() {
  var _vm = this, _c = _vm._self._c, _setup = _vm._self._setupProxy;
  return _c("div", { ref: "fileContainer", staticClass: "file-picker__files" }, [_c("table", [_c("thead", [_c("tr", [_vm.multiselect ? _c("th", { staticClass: "row-checkbox" }, [_c("span", { staticClass: "hidden-visually" }, [_vm._v(" " + _vm._s(_setup.t("Select entry")) + " ")]), _vm.multiselect ? _c(_setup.NcCheckboxRadioSwitch, { attrs: { "aria-label": _setup.t("Select all entries"), "data-testid": "select-all-checkbox", "model-value": _setup.allSelected }, on: { "update:model-value": _setup.onSelectAll } }) : _vm._e()], 1) : _vm._e(), _c("th", { staticClass: "row-name", attrs: { "aria-sort": _setup.sortByName } }, [_c("div", { staticClass: "header-wrapper" }, [_c("span", { staticClass: "file-picker__header-preview" }), _c(_setup.NcButton, { attrs: { "wide": true, "type": "tertiary", "data-test": "file-picker_sort-name" }, on: { "click": function($event) {
    return _setup.toggleSorting("basename");
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_setup.sortByName === "ascending" ? _c(_setup.IconSortAscending, { attrs: { "size": 20 } }) : _setup.sortByName === "descending" ? _c(_setup.IconSortDescending, { attrs: { "size": 20 } }) : _c("span", { staticStyle: { "width": "44px" } })];
  }, proxy: true }]) }, [_vm._v(" " + _vm._s(_setup.t("Name")) + " ")])], 1)]), _c("th", { staticClass: "row-size", attrs: { "aria-sort": _setup.sortBySize } }, [_c(_setup.NcButton, { attrs: { "wide": true, "type": "tertiary" }, on: { "click": function($event) {
    return _setup.toggleSorting("size");
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_setup.sortBySize === "ascending" ? _c(_setup.IconSortAscending, { attrs: { "size": 20 } }) : _setup.sortBySize === "descending" ? _c(_setup.IconSortDescending, { attrs: { "size": 20 } }) : _c("span", { staticStyle: { "width": "44px" } })];
  }, proxy: true }]) }, [_vm._v(" " + _vm._s(_setup.t("Size")) + " ")])], 1), _c("th", { staticClass: "row-modified", attrs: { "aria-sort": _setup.sortByModified } }, [_c(_setup.NcButton, { attrs: { "wide": true, "type": "tertiary" }, on: { "click": function($event) {
    return _setup.toggleSorting("mtime");
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_setup.sortByModified === "ascending" ? _c(_setup.IconSortAscending, { attrs: { "size": 20 } }) : _setup.sortByModified === "descending" ? _c(_setup.IconSortDescending, { attrs: { "size": 20 } }) : _c("span", { staticStyle: { "width": "44px" } })];
  }, proxy: true }]) }, [_vm._v(" " + _vm._s(_setup.t("Modified")) + " ")])], 1)])]), _c("tbody", [_vm.loading ? _vm._l(_setup.skeletonNumber, function(index) {
    return _c(_setup.LoadingTableRow, { key: index, attrs: { "show-checkbox": _vm.multiselect } });
  }) : _vm._l(_setup.sortedFiles, function(file) {
    return _c(_setup.FileListRow, { key: file.fileid || file.path, attrs: { "allow-pick-directory": _vm.allowPickDirectory, "show-checkbox": _vm.multiselect, "can-pick": (_vm.multiselect || _vm.selectedFiles.length === 0 || _vm.selectedFiles.includes(file)) && (_vm.canPick === void 0 || _vm.canPick(file)), "selected": _vm.selectedFiles.includes(file), "node": file, "crop-image-previews": _setup.cropImagePreviews }, on: { "update:selected": function($event) {
      return _setup.onNodeSelected(file);
    }, "enter-directory": _setup.onChangeDirectory } });
  })], 2)])]);
};
var _sfc_staticRenderFns$7 = [];
var __component__$7 = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main$7,
  _sfc_render$7,
  _sfc_staticRenderFns$7,
  false,
  null,
  "6503afab"
);
const FileList = __component__$7.exports;
const _sfc_main$6 = {
  name: "HomeIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$6 = function render9() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon home-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M10,20V14H14V20H19V12H22L12,3L2,12H5V20H10Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$6 = [];
var __component__$6 = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main$6,
  _sfc_render$6,
  _sfc_staticRenderFns$6,
  false,
  null,
  null
);
const IconHome = __component__$6.exports;
const _sfc_main$5 = {
  name: "PlusIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$5 = function render10() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon plus-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$5 = [];
var __component__$5 = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main$5,
  _sfc_render$5,
  _sfc_staticRenderFns$5,
  false,
  null,
  null
);
const IconPlus = __component__$5.exports;
const _sfc_main$4 = /* @__PURE__ */ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
  __name: "FilePickerBreadcrumbs",
  props: {
    path: null,
    showMenu: { type: Boolean }
  },
  emits: ["update:path", "create-node"],
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const actionsOpen = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(false);
    const newNodeName = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)("");
    const nameInput = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)();
    function validateInput() {
      const name = newNodeName.value.trim();
      const input = nameInput.value?.$el?.querySelector("input");
      let validity = "";
      if (name.length === 0) {
        validity = (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)("Folder name cannot be empty.");
      } else if (name.includes("/")) {
        validity = (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)('"/" is not allowed inside a folder name.');
      } else if (["..", "."].includes(name)) {
        validity = (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)('"{name}" is an invalid folder name.', { name });
      } else if (window.OC.config?.blacklist_files_regex && name.match(window.OC.config?.blacklist_files_regex)) {
        validity = (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)('"{name}" is not an allowed folder name', { name });
      }
      if (input) {
        input.setCustomValidity(validity);
      }
      return validity === "";
    }
    const onSubmit = function() {
      const name = newNodeName.value.trim();
      if (validateInput()) {
        actionsOpen.value = false;
        emit2("create-node", name);
        newNodeName.value = "";
      }
    };
    const pathElements = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(
      () => props.path.split("/").filter((v) => v !== "").map((v, i, elements) => ({
        name: v,
        path: "/" + elements.slice(0, i + 1).join("/")
      }))
    );
    return { __sfc: true, props, emit: emit2, actionsOpen, newNodeName, nameInput, validateInput, onSubmit, pathElements, IconFolder, IconHome, IconPlus, NcActions: _nextcloud_vue_components_NcActions__WEBPACK_IMPORTED_MODULE_15__["default"], NcActionInput: _nextcloud_vue_components_NcActionInput__WEBPACK_IMPORTED_MODULE_16__["default"], NcBreadcrumbs: _nextcloud_vue_components_NcBreadcrumbs__WEBPACK_IMPORTED_MODULE_17__["default"], NcBreadcrumb: _nextcloud_vue_components_NcBreadcrumb__WEBPACK_IMPORTED_MODULE_18__["default"], t: _plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t };
  }
});
var _sfc_render$4 = function render11() {
  var _vm = this, _c = _vm._self._c, _setup = _vm._self._setupProxy;
  return _c(_setup.NcBreadcrumbs, { staticClass: "file-picker__breadcrumbs", scopedSlots: _vm._u([{ key: "default", fn: function() {
    return [_c(_setup.NcBreadcrumb, { attrs: { "name": _setup.t("All files"), "title": _setup.t("Home") }, on: { "click": function($event) {
      return _setup.emit("update:path", "/");
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c(_setup.IconHome, { attrs: { "size": 20 } })];
    }, proxy: true }]) }), _vm._l(_setup.pathElements, function(dir) {
      return _c(_setup.NcBreadcrumb, { key: dir.path, attrs: { "name": dir.name, "title": dir.path }, on: { "click": function($event) {
        return _setup.emit("update:path", dir.path);
      } } });
    })];
  }, proxy: true }, _vm.showMenu ? { key: "actions", fn: function() {
    return [_c(_setup.NcActions, { attrs: { "open": _setup.actionsOpen, "aria-label": _setup.t("Create directory"), "force-menu": true, "force-name": true, "menu-name": _setup.t("New"), "type": "secondary" }, on: { "update:open": function($event) {
      _setup.actionsOpen = $event;
    }, "close": function($event) {
      _setup.newNodeName = "";
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c(_setup.IconPlus, { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 2971667417) }, [_c(_setup.NcActionInput, { ref: "nameInput", attrs: { "value": _setup.newNodeName, "label": _setup.t("New folder"), "placeholder": _setup.t("New folder name") }, on: { "update:value": function($event) {
      _setup.newNodeName = $event;
    }, "submit": _setup.onSubmit, "update:model-value": _setup.validateInput }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c(_setup.IconFolder, { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 1614167509) })], 1)];
  }, proxy: true } : null], null, true) });
};
var _sfc_staticRenderFns$4 = [];
var __component__$4 = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main$4,
  _sfc_render$4,
  _sfc_staticRenderFns$4,
  false,
  null,
  "ec4d392b"
);
const FilePickerBreadcrumbs = __component__$4.exports;
const _sfc_main$3 = {
  name: "CloseIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$3 = function render12() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon close-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$3 = [];
var __component__$3 = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main$3,
  _sfc_render$3,
  _sfc_staticRenderFns$3,
  false,
  null,
  null
);
const IconClose = __component__$3.exports;
const _sfc_main$2 = {
  name: "MagnifyIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$2 = function render13() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon magnify-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$2 = [];
var __component__$2 = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main$2,
  _sfc_render$2,
  _sfc_staticRenderFns$2,
  false,
  null,
  null
);
const IconMagnify = __component__$2.exports;
const useViews = (isAnonymous) => {
  const allViews = [
    {
      id: "files",
      label: (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)("All files"),
      icon: _mdi_js__WEBPACK_IMPORTED_MODULE_11__.mdiFolder
    },
    {
      id: "recent",
      label: (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)("Recent"),
      icon: _mdi_js__WEBPACK_IMPORTED_MODULE_11__.mdiClock
    },
    {
      id: "favorites",
      label: (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)("Favorites"),
      icon: _mdi_js__WEBPACK_IMPORTED_MODULE_11__.mdiStar
    }
  ];
  const availableViews = isAnonymous.value ? allViews.filter(({ id }) => id === "files") : allViews;
  return {
    allViews,
    availableViews
  };
};
const _sfc_main$1 = /* @__PURE__ */ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
  __name: "FilePickerNavigation",
  props: {
    currentView: null,
    filterString: null,
    isCollapsed: { type: Boolean },
    disabledNavigation: { type: Boolean }
  },
  emits: ["update:currentView", "update:filterString"],
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const { availableViews } = useViews((0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)((0,_nextcloud_auth__WEBPACK_IMPORTED_MODULE_19__.getCurrentUser)() === null));
    const currentViewObject = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => availableViews.filter((v) => v.id === props.currentView)[0] ?? availableViews[0]);
    const updateFilterValue = (value) => emit2("update:filterString", value);
    return { __sfc: true, props, emit: emit2, availableViews, currentViewObject, updateFilterValue, IconClose, IconMagnify, NcButton: _nextcloud_vue_components_NcButton__WEBPACK_IMPORTED_MODULE_3__["default"], NcIconSvgWrapper: _nextcloud_vue_components_NcIconSvgWrapper__WEBPACK_IMPORTED_MODULE_14__["default"], NcSelect: _nextcloud_vue_components_NcSelect__WEBPACK_IMPORTED_MODULE_20__["default"], NcTextField: _nextcloud_vue_components_NcTextField__WEBPACK_IMPORTED_MODULE_21__["default"], Fragment: vue_frag__WEBPACK_IMPORTED_MODULE_22__.Fragment, t: _plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t };
  }
});
var _sfc_render$1 = function render14() {
  var _vm = this, _c = _vm._self._c, _setup = _vm._self._setupProxy;
  return _c(_setup.Fragment, [_c(_setup.NcTextField, { staticClass: "file-picker__filter-input", attrs: { "label": _setup.t("Filter file list"), "show-trailing-button": !!_vm.filterString, "model-value": _vm.filterString }, on: { "update:model-value": _setup.updateFilterValue, "trailing-button-click": function($event) {
    return _setup.updateFilterValue("");
  } }, scopedSlots: _vm._u([{ key: "trailing-button-icon", fn: function() {
    return [_c(_setup.IconClose, { attrs: { "size": 16 } })];
  }, proxy: true }]) }, [_c(_setup.IconMagnify, { attrs: { "size": 16 } })], 1), _setup.availableViews.length > 1 && !_vm.disabledNavigation ? [!_vm.isCollapsed ? _c("ul", { staticClass: "file-picker__side" }, _vm._l(_setup.availableViews, function(view) {
    return _c("li", { key: view.id }, [_c(_setup.NcButton, { attrs: { "type": _vm.currentView === view.id ? "primary" : "tertiary", "wide": true }, on: { "click": function($event) {
      return _vm.$emit("update:currentView", view.id);
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c(_setup.NcIconSvgWrapper, { attrs: { "path": view.icon, "size": 20 } })];
    }, proxy: true }], null, true) }, [_vm._v(" " + _vm._s(view.label) + " ")])], 1);
  }), 0) : _c(_setup.NcSelect, { attrs: { "aria-label": _setup.t("Current view selector"), "clearable": false, "searchable": false, "options": _setup.availableViews, "model-value": _setup.currentViewObject }, on: { "update:model-value": function($event) {
    return _setup.emit("update:currentView", $event.id);
  } } })] : _vm._e()], 2);
};
var _sfc_staticRenderFns$1 = [];
var __component__$1 = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main$1,
  _sfc_render$1,
  _sfc_staticRenderFns$1,
  false,
  null,
  "f5975252"
);
const FilePickerNavigation = __component__$1.exports;
function getRecentNodes(client) {
  const controller = new AbortController();
  const lastTwoWeek = Math.round(Date.now() / 1e3) - 60 * 60 * 24 * 14;
  return new cancelable_promise__WEBPACK_IMPORTED_MODULE_26__.CancelablePromise(async (resolve, reject, onCancel) => {
    onCancel(() => controller.abort());
    try {
      const { data } = await client.search("/", {
        signal: controller.signal,
        details: true,
        data: (0,_nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.davGetRecentSearch)(lastTwoWeek)
      });
      const nodes = data.results.map((result) => (0,_nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.davResultToNode)(result));
      resolve(nodes);
    } catch (error) {
      reject(error);
    }
  });
}
function getNodes(client, directoryPath) {
  const controller = new AbortController();
  return new cancelable_promise__WEBPACK_IMPORTED_MODULE_26__.CancelablePromise(async (resolve, reject, onCancel) => {
    onCancel(() => controller.abort());
    try {
      const results = await client.getDirectoryContents((0,path__WEBPACK_IMPORTED_MODULE_27__.join)(_nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.davRootPath, directoryPath), {
        signal: controller.signal,
        details: true,
        includeSelf: true,
        data: (0,_nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.davGetDefaultPropfind)()
      });
      const nodes = results.data.map((result) => (0,_nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.davResultToNode)(result));
      resolve({
        contents: nodes.filter(({ path }) => path !== directoryPath),
        folder: nodes.find(({ path }) => path === directoryPath)
      });
    } catch (error) {
      reject(error);
    }
  });
}
async function getFile(client, path) {
  const { data } = await client.stat((0,path__WEBPACK_IMPORTED_MODULE_27__.join)(_nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.davRootPath, path), {
    details: true,
    data: (0,_nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.davGetDefaultPropfind)()
  });
  return (0,_nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.davResultToNode)(data);
}
const useDAVFiles = function(currentView, currentPath) {
  const client = (0,_nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.davGetClient)();
  const files = (0,vue__WEBPACK_IMPORTED_MODULE_0__.shallowRef)([]);
  const folder = (0,vue__WEBPACK_IMPORTED_MODULE_0__.shallowRef)(null);
  const isLoading = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(true);
  const promise = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
  async function createDirectory(name) {
    const path = (0,path__WEBPACK_IMPORTED_MODULE_27__.join)(currentPath.value, name);
    await client.createDirectory((0,path__WEBPACK_IMPORTED_MODULE_27__.join)(_nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.davRootPath, path));
    const directory = await getFile(client, path);
    files.value = [...files.value, directory];
    return directory;
  }
  async function loadDAVFiles() {
    if (promise.value) {
      promise.value.cancel();
    }
    isLoading.value = true;
    if (currentView.value === "favorites") {
      promise.value = (0,_nextcloud_files__WEBPACK_IMPORTED_MODULE_2__.getFavoriteNodes)(client, currentPath.value);
    } else if (currentView.value === "recent") {
      promise.value = getRecentNodes(client);
    } else {
      promise.value = getNodes(client, currentPath.value);
    }
    const content = await promise.value;
    if ("folder" in content) {
      folder.value = content.folder;
      files.value = content.contents;
    } else {
      folder.value = null;
      files.value = content;
    }
    promise.value = null;
    isLoading.value = false;
  }
  (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)([currentView, currentPath], () => loadDAVFiles());
  (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => loadDAVFiles());
  return {
    isLoading,
    files,
    folder,
    loadFiles: loadDAVFiles,
    createDirectory
  };
};
const useMimeFilter = function(allowedMIMETypes) {
  const splittedTypes = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => allowedMIMETypes.value.map((filter) => filter.split("/")));
  const isSupportedMimeType = (mime) => {
    const mimeTypeArray = mime.split("/");
    return splittedTypes.value.some(
      ([type, subtype]) => (
        // check mime type matches or is wildcard
        (mimeTypeArray[0] === type || type === "*") && (mimeTypeArray[1] === subtype || subtype === "*")
      )
    );
  };
  return {
    isSupportedMimeType
  };
};
const __default__ = {
  name: "FilePicker"
};
const _sfc_main = /* @__PURE__ */ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
  ...__default__,
  props: {
    buttons: null,
    name: null,
    allowPickDirectory: { type: Boolean, default: false },
    disabledNavigation: { type: Boolean, default: false },
    container: { default: "body" },
    filterFn: { default: void 0 },
    canPickFn: { default: void 0 },
    mimetypeFilter: { default: () => [] },
    multiselect: { type: Boolean, default: true },
    path: { default: void 0 }
  },
  emits: ["close"],
  setup(__props, { emit: emit$1 }) {
    const props = __props;
    const isOpen = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(true);
    const dialogButtons = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      const nodes = selectedFiles.value.length === 0 && props.allowPickDirectory && currentFolder.value ? [currentFolder.value] : selectedFiles.value;
      const buttons = typeof props.buttons === "function" ? props.buttons(nodes, currentPath.value, currentView.value) : props.buttons;
      return buttons.map((button) => ({
        ...button,
        disabled: button.disabled || isLoading.value,
        callback: () => {
          isHandlingCallback = true;
          handleButtonClick(button.callback, nodes);
        }
      }));
    });
    let isHandlingCallback = false;
    const handleButtonClick = async (callback, nodes) => {
      callback(nodes);
      emit$1("close", nodes);
      isHandlingCallback = false;
    };
    const currentView = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)("files");
    const viewHeadline = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => currentView.value === "favorites" ? (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)("Favorites") : currentView.value === "recent" ? (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)("Recent") : "");
    const selectedFiles = (0,vue__WEBPACK_IMPORTED_MODULE_0__.shallowRef)([]);
    const savedPath = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(window?.sessionStorage.getItem("NC.FilePicker.LastPath") || "/");
    const navigatedPath = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)("");
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)([navigatedPath], () => {
      if (props.path === void 0 && navigatedPath.value) {
        window.sessionStorage.setItem("NC.FilePicker.LastPath", navigatedPath.value);
      }
      selectedFiles.value = [];
    });
    const currentPath = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)({
      get: () => {
        return currentView.value === "files" ? navigatedPath.value || props.path || savedPath.value : "/";
      },
      set: (path) => {
        navigatedPath.value = path;
      }
    });
    const filterString = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)("");
    const { isSupportedMimeType } = useMimeFilter((0,vue__WEBPACK_IMPORTED_MODULE_0__.toRef)(props, "mimetypeFilter"));
    const {
      files,
      folder: currentFolder,
      isLoading,
      loadFiles,
      createDirectory
    } = useDAVFiles(currentView, currentPath);
    (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => loadFiles());
    const { showHiddenFiles } = useFilesSettings();
    const filteredFiles = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      let filtered = files.value;
      if (!showHiddenFiles.value) {
        filtered = filtered.filter((file) => !file.basename.startsWith("."));
      }
      if (props.mimetypeFilter.length > 0) {
        filtered = filtered.filter((file) => file.type === "folder" || file.mime && isSupportedMimeType(file.mime));
      }
      if (filterString.value) {
        filtered = filtered.filter((file) => file.basename.toLowerCase().includes(filterString.value.toLowerCase()));
      }
      if (props.filterFn) {
        filtered = filtered.filter((f) => props.filterFn(f));
      }
      return filtered;
    });
    const noFilesDescription = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(() => {
      if (currentView.value === "files") {
        return (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)("Upload some content or sync with your devices!");
      } else if (currentView.value === "recent") {
        return (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)("Files and folders you recently modified will show up here.");
      } else {
        return (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)("Files and folders you mark as favorite will show up here.");
      }
    });
    const onCreateFolder = async (name) => {
      try {
        const folder = await createDirectory(name);
        navigatedPath.value = folder.path;
        (0,_nextcloud_event_bus__WEBPACK_IMPORTED_MODULE_23__.emit)("files:node:created", files.value.filter((file) => file.basename === name)[0]);
      } catch (error) {
        console.warn("Could not create new folder", { name, error });
        (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.l)((0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t)("Could not create the new folder"));
      }
    };
    const handleClose = (open) => {
      if (!open && !isHandlingCallback) {
        emit$1("close");
      }
    };
    return { __sfc: true, props, emit: emit$1, isOpen, dialogButtons, isHandlingCallback, handleButtonClick, currentView, viewHeadline, selectedFiles, savedPath, navigatedPath, currentPath, filterString, isSupportedMimeType, files, currentFolder, isLoading, loadFiles, createDirectory, showHiddenFiles, filteredFiles, noFilesDescription, onCreateFolder, handleClose, IconFile, FileList, FilePickerBreadcrumbs, FilePickerNavigation, NcDialog: _nextcloud_vue_components_NcDialog__WEBPACK_IMPORTED_MODULE_24__["default"], NcEmptyContent: _nextcloud_vue_components_NcEmptyContent__WEBPACK_IMPORTED_MODULE_25__["default"], t: _plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.t };
  }
});
var _sfc_render = function render15() {
  var _vm = this, _c = _vm._self._c, _setup = _vm._self._setupProxy;
  return _c(_setup.NcDialog, { attrs: { "open": _setup.isOpen, "container": _vm.container, "buttons": _setup.dialogButtons, "name": _vm.name, "size": "large", "content-classes": "file-picker__content", "dialog-classes": "file-picker", "navigation-classes": "file-picker__navigation" }, on: { "update:open": [function($event) {
    _setup.isOpen = $event;
  }, _setup.handleClose] }, scopedSlots: _vm._u([{ key: "navigation", fn: function({ isCollapsed }) {
    return [_c(_setup.FilePickerNavigation, { attrs: { "current-view": _setup.currentView, "filter-string": _setup.filterString, "is-collapsed": isCollapsed, "disabled-navigation": _vm.disabledNavigation }, on: { "update:currentView": function($event) {
      _setup.currentView = $event;
    }, "update:current-view": function($event) {
      _setup.currentView = $event;
    }, "update:filterString": function($event) {
      _setup.filterString = $event;
    }, "update:filter-string": function($event) {
      _setup.filterString = $event;
    } } })];
  } }]) }, [_c("div", { staticClass: "file-picker__main" }, [_setup.currentView === "files" ? _c(_setup.FilePickerBreadcrumbs, { attrs: { "path": _setup.currentPath, "show-menu": _vm.allowPickDirectory }, on: { "update:path": function($event) {
    _setup.currentPath = $event;
  }, "create-node": _setup.onCreateFolder } }) : _c("div", { staticClass: "file-picker__view" }, [_c("h3", [_vm._v(_vm._s(_setup.viewHeadline))])]), _setup.isLoading || _setup.filteredFiles.length > 0 ? _c(_setup.FileList, { attrs: { "path": _setup.currentPath, "selected-files": _setup.selectedFiles, "allow-pick-directory": _vm.allowPickDirectory, "current-view": _setup.currentView, "files": _setup.filteredFiles, "multiselect": _vm.multiselect, "loading": _setup.isLoading, "name": _setup.viewHeadline, "can-pick": _vm.canPickFn }, on: { "update:path": [function($event) {
    _setup.currentPath = $event;
  }, function($event) {
    _setup.currentView = "files";
  }], "update:selectedFiles": function($event) {
    _setup.selectedFiles = $event;
  }, "update:selected-files": function($event) {
    _setup.selectedFiles = $event;
  } } }) : _setup.filterString ? _c(_setup.NcEmptyContent, { attrs: { "name": _setup.t("No matching files"), "description": _setup.t("No files matching your filter were found.") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c(_setup.IconFile)];
  }, proxy: true }]) }) : _c(_setup.NcEmptyContent, { attrs: { "name": _setup.t("No files in here"), "description": _setup.noFilesDescription }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c(_setup.IconFile)];
  }, proxy: true }]) })], 1)]);
};
var _sfc_staticRenderFns = [];
var __component__ = /* @__PURE__ */ (0,_plugin_vue2_normalizer_jrlE7CJU_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(
  _sfc_main,
  _sfc_render,
  _sfc_staticRenderFns,
  false,
  null,
  "dda9b42b"
);
const FilePicker = __component__.exports;

//# sourceMappingURL=FilePicker-lO8J1a0C.mjs.map


/***/ }),

/***/ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/initial-state/dist/index.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/initial-state/dist/index.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadState: () => (/* binding */ loadState)
/* harmony export */ });
/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: GPL-3.0-or-later
 */
/**
 * @param app app ID, e.g. "mail"
 * @param key name of the property
 * @param fallback optional parameter to use as default value
 * @throws if the key can't be found
 */
function loadState(app, key, fallback) {
    const selector = `#initial-state-${app}-${key}`;
    if (window._nc_initial_state?.has(selector)) {
        return window._nc_initial_state.get(selector);
    }
    else if (!window._nc_initial_state) {
        window._nc_initial_state = new Map();
    }
    const elem = document.querySelector(selector);
    if (elem === null) {
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`Could not find initial state ${key} of ${app}`);
    }
    try {
        const parsedValue = JSON.parse(atob(elem.value));
        window._nc_initial_state.set(selector, parsedValue);
        return parsedValue;
    }
    catch (error) {
        console.error('[@nextcloud/initial-state] Could not parse initial state', { key, app, error });
        if (fallback !== undefined) {
            return fallback;
        }
        throw new Error(`Could not parse initial state ${key} of ${app}`, { cause: error });
    }
}


/***/ }),

/***/ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/sharing/dist/index.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/sharing/dist/index.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShareType: () => (/* reexport safe */ _share_index_js__WEBPACK_IMPORTED_MODULE_0__.ShareType)
/* harmony export */ });
/* harmony import */ var _share_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./share/index.js */ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/sharing/dist/share/index.js");
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: GPL-3.0-or-later
 */



/***/ }),

/***/ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/sharing/dist/public.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/sharing/dist/public.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSharingToken: () => (/* binding */ getSharingToken),
/* harmony export */   isPublicShare: () => (/* binding */ isPublicShare)
/* harmony export */ });
/* harmony import */ var _nextcloud_initial_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @nextcloud/initial-state */ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/initial-state/dist/index.js");
/*!
 * SPDX-FileCopyrightText: 2024 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: GPL-3.0-or-later
 */
/**
 * @module public
 */

/**
 * Check if the current page is on a public share
 */
function isPublicShare() {
    // check both the new initial state version and fallback to legacy input
    return ((0,_nextcloud_initial_state__WEBPACK_IMPORTED_MODULE_0__.loadState)('files_sharing', 'isPublic', null)
        ?? document.querySelector('input#isPublic[type="hidden"][name="isPublic"][value="1"]') !== null);
}
/**
 * Get the sharing token for the current public share
 */
function getSharingToken() {
    return ((0,_nextcloud_initial_state__WEBPACK_IMPORTED_MODULE_0__.loadState)('files_sharing', 'sharingToken', null)
        ?? document.querySelector('input#sharingToken[type="hidden"]')?.value
        ?? null);
}


/***/ }),

/***/ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/sharing/dist/share/ShareType.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/sharing/dist/share/ShareType.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShareType: () => (/* binding */ ShareType)
/* harmony export */ });
/*!
 * SPDX-FileCopyrightText: 2025 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: GPL-3.0-or-later
 */
var ShareType;
(function (ShareType) {
    ShareType[ShareType["User"] = 0] = "User";
    ShareType[ShareType["Group"] = 1] = "Group";
    ShareType[ShareType["Link"] = 3] = "Link";
    ShareType[ShareType["Email"] = 4] = "Email";
    ShareType[ShareType["Remote"] = 6] = "Remote";
    /**
     * Was called `Circle` before Nextcloud 29
     */
    ShareType[ShareType["Team"] = 7] = "Team";
    ShareType[ShareType["Guest"] = 8] = "Guest";
    ShareType[ShareType["RemoteGroup"] = 9] = "RemoteGroup";
    ShareType[ShareType["Room"] = 10] = "Room";
    ShareType[ShareType["Deck"] = 12] = "Deck";
    /**
     * @since 26.0.0
     */
    ShareType[ShareType["FederatedGroup"] = 14] = "FederatedGroup";
    /**
     * Third party share types
     *
     * @since 25.0.0
     */
    ShareType[ShareType["ScienceMesh"] = 15] = "ScienceMesh";
})(ShareType || (ShareType = {}));


/***/ }),

/***/ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/sharing/dist/share/index.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/sharing/dist/share/index.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ShareType: () => (/* reexport safe */ _ShareType_js__WEBPACK_IMPORTED_MODULE_0__.ShareType)
/* harmony export */ });
/* harmony import */ var _ShareType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShareType.js */ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/@nextcloud/sharing/dist/share/ShareType.js");
/*!
 * SPDX-FileCopyrightText: 2025 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: GPL-3.0-or-later
 */



/***/ }),

/***/ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/p-queue/dist/index.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/p-queue/dist/index.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TimeoutError: () => (/* reexport safe */ p_timeout__WEBPACK_IMPORTED_MODULE_1__.TimeoutError),
/* harmony export */   "default": () => (/* binding */ PQueue)
/* harmony export */ });
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/@nextcloud/upload/node_modules/eventemitter3/index.mjs");
/* harmony import */ var p_timeout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-timeout */ "./node_modules/p-timeout/index.js");
/* harmony import */ var _priority_queue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./priority-queue.js */ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/p-queue/dist/priority-queue.js");



/**
Promise queue with concurrency control.
*/
class PQueue extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    #carryoverIntervalCount;
    #isIntervalIgnored;
    #intervalCount = 0;
    #intervalCap;
    #rateLimitedInInterval = false;
    #rateLimitFlushScheduled = false;
    #interval;
    #intervalEnd = 0;
    #lastExecutionTime = 0;
    #intervalId;
    #timeoutId;
    #queue;
    #queueClass;
    #pending = 0;
    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
    #concurrency;
    #isPaused;
    // Use to assign a unique identifier to a promise function, if not explicitly specified
    #idAssigner = 1n;
    // Track currently running tasks for debugging
    #runningTasks = new Map();
    /**
    Get or set the default timeout for all tasks. Can be changed at runtime.

    Operations will throw a `TimeoutError` if they don't complete within the specified time.

    The timeout begins when the operation is dequeued and starts execution, not while it's waiting in the queue.

    @example
    ```
    const queue = new PQueue({timeout: 5000});

    // Change timeout for all future tasks
    queue.timeout = 10000;
    ```
    */
    timeout;
    constructor(options) {
        super();
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        options = {
            carryoverIntervalCount: false,
            intervalCap: Number.POSITIVE_INFINITY,
            interval: 0,
            concurrency: Number.POSITIVE_INFINITY,
            autoStart: true,
            queueClass: _priority_queue_js__WEBPACK_IMPORTED_MODULE_2__["default"],
            ...options,
        };
        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {
            throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options.intervalCap?.toString() ?? ''}\` (${typeof options.intervalCap})`);
        }
        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {
            throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options.interval?.toString() ?? ''}\` (${typeof options.interval})`);
        }
        // TODO: Remove this fallback in the next major version
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        this.#carryoverIntervalCount = options.carryoverIntervalCount ?? options.carryoverConcurrencyCount ?? false;
        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;
        this.#intervalCap = options.intervalCap;
        this.#interval = options.interval;
        this.#queue = new options.queueClass();
        this.#queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        if (options.timeout !== undefined && !(Number.isFinite(options.timeout) && options.timeout > 0)) {
            throw new TypeError(`Expected \`timeout\` to be a positive finite number, got \`${options.timeout}\` (${typeof options.timeout})`);
        }
        this.timeout = options.timeout;
        this.#isPaused = options.autoStart === false;
        this.#setupRateLimitTracking();
    }
    get #doesIntervalAllowAnother() {
        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
    }
    get #doesConcurrentAllowAnother() {
        return this.#pending < this.#concurrency;
    }
    #next() {
        this.#pending--;
        if (this.#pending === 0) {
            this.emit('pendingZero');
        }
        this.#tryToStartAnother();
        this.emit('next');
    }
    #onResumeInterval() {
        this.#onInterval(); // Already schedules update
        this.#initializeIntervalIfNeeded();
        this.#timeoutId = undefined;
    }
    get #isIntervalPaused() {
        const now = Date.now();
        if (this.#intervalId === undefined) {
            const delay = this.#intervalEnd - now;
            if (delay < 0) {
                // If the interval has expired while idle, check if we should enforce the interval
                // from the last task execution. This ensures proper spacing between tasks even
                // when the queue becomes empty and then new tasks are added.
                if (this.#lastExecutionTime > 0) {
                    const timeSinceLastExecution = now - this.#lastExecutionTime;
                    if (timeSinceLastExecution < this.#interval) {
                        // Not enough time has passed since the last task execution
                        this.#createIntervalTimeout(this.#interval - timeSinceLastExecution);
                        return true;
                    }
                }
                // Enough time has passed or no previous execution, allow execution
                this.#intervalCount = (this.#carryoverIntervalCount) ? this.#pending : 0;
            }
            else {
                // Act as the interval is pending
                this.#createIntervalTimeout(delay);
                return true;
            }
        }
        return false;
    }
    #createIntervalTimeout(delay) {
        if (this.#timeoutId !== undefined) {
            return;
        }
        this.#timeoutId = setTimeout(() => {
            this.#onResumeInterval();
        }, delay);
    }
    #clearIntervalTimer() {
        if (this.#intervalId) {
            clearInterval(this.#intervalId);
            this.#intervalId = undefined;
        }
    }
    #clearTimeoutTimer() {
        if (this.#timeoutId) {
            clearTimeout(this.#timeoutId);
            this.#timeoutId = undefined;
        }
    }
    #tryToStartAnother() {
        if (this.#queue.size === 0) {
            // We can clear the interval ("pause")
            // Because we can redo it later ("resume")
            this.#clearIntervalTimer();
            this.emit('empty');
            if (this.#pending === 0) {
                // Clear timeout as well when completely idle
                this.#clearTimeoutTimer();
                this.emit('idle');
            }
            return false;
        }
        let taskStarted = false;
        if (!this.#isPaused) {
            const canInitializeInterval = !this.#isIntervalPaused;
            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
                const job = this.#queue.dequeue();
                // Increment interval count immediately to prevent race conditions
                if (!this.#isIntervalIgnored) {
                    this.#intervalCount++;
                    this.#scheduleRateLimitUpdate();
                }
                this.emit('active');
                this.#lastExecutionTime = Date.now();
                job();
                if (canInitializeInterval) {
                    this.#initializeIntervalIfNeeded();
                }
                taskStarted = true;
            }
        }
        return taskStarted;
    }
    #initializeIntervalIfNeeded() {
        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {
            return;
        }
        this.#intervalId = setInterval(() => {
            this.#onInterval();
        }, this.#interval);
        this.#intervalEnd = Date.now() + this.#interval;
    }
    #onInterval() {
        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
            this.#clearIntervalTimer();
        }
        this.#intervalCount = this.#carryoverIntervalCount ? this.#pending : 0;
        this.#processQueue();
        this.#scheduleRateLimitUpdate();
    }
    /**
    Executes all queued functions until it reaches the limit.
    */
    #processQueue() {
        // eslint-disable-next-line no-empty
        while (this.#tryToStartAnother()) { }
    }
    get concurrency() {
        return this.#concurrency;
    }
    set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {
            throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
        }
        this.#concurrency = newConcurrency;
        this.#processQueue();
    }
    async #throwOnAbort(signal) {
        return new Promise((_resolve, reject) => {
            signal.addEventListener('abort', () => {
                reject(signal.reason);
            }, { once: true });
        });
    }
    /**
    Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.

    For example, this can be used to prioritize a promise function to run earlier.

    ```js
    import PQueue from 'p-queue';

    const queue = new PQueue({concurrency: 1});

    queue.add(async () => '', {priority: 1});
    queue.add(async () => '', {priority: 0, id: ''});
    queue.add(async () => '', {priority: 1});
    queue.add(async () => '', {priority: 1});

    queue.setPriority('', 2);
    ```

    In this case, the promise function with `id: ''` runs second.

    You can also deprioritize a promise function to delay its execution:

    ```js
    import PQueue from 'p-queue';

    const queue = new PQueue({concurrency: 1});

    queue.add(async () => '', {priority: 1});
    queue.add(async () => '', {priority: 1, id: ''});
    queue.add(async () => '');
    queue.add(async () => '', {priority: 0});

    queue.setPriority('', -1);
    ```
    Here, the promise function with `id: ''` executes last.
    */
    setPriority(id, priority) {
        if (typeof priority !== 'number' || !Number.isFinite(priority)) {
            throw new TypeError(`Expected \`priority\` to be a finite number, got \`${priority}\` (${typeof priority})`);
        }
        this.#queue.setPriority(id, priority);
    }
    async add(function_, options = {}) {
        // In case `id` is not defined.
        options.id ??= (this.#idAssigner++).toString();
        options = {
            timeout: this.timeout,
            ...options,
        };
        return new Promise((resolve, reject) => {
            // Create a unique symbol for tracking this task
            const taskSymbol = Symbol(`task-${options.id}`);
            this.#queue.enqueue(async () => {
                this.#pending++;
                // Track this running task
                this.#runningTasks.set(taskSymbol, {
                    id: options.id,
                    priority: options.priority ?? 0, // Match priority-queue default
                    startTime: Date.now(),
                    timeout: options.timeout,
                });
                try {
                    // Check abort signal - if aborted, need to decrement the counter
                    // that was incremented in tryToStartAnother
                    try {
                        options.signal?.throwIfAborted();
                    }
                    catch (error) {
                        // Decrement the counter that was already incremented
                        if (!this.#isIntervalIgnored) {
                            this.#intervalCount--;
                        }
                        // Clean up tracking before throwing
                        this.#runningTasks.delete(taskSymbol);
                        throw error;
                    }
                    let operation = function_({ signal: options.signal });
                    if (options.timeout) {
                        operation = (0,p_timeout__WEBPACK_IMPORTED_MODULE_1__["default"])(Promise.resolve(operation), {
                            milliseconds: options.timeout,
                            message: `Task timed out after ${options.timeout}ms (queue has ${this.#pending} running, ${this.#queue.size} waiting)`,
                        });
                    }
                    if (options.signal) {
                        operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);
                    }
                    const result = await operation;
                    resolve(result);
                    this.emit('completed', result);
                }
                catch (error) {
                    reject(error);
                    this.emit('error', error);
                }
                finally {
                    // Remove from running tasks
                    this.#runningTasks.delete(taskSymbol);
                    // Use queueMicrotask to prevent deep recursion while maintaining timing
                    queueMicrotask(() => {
                        this.#next();
                    });
                }
            }, options);
            this.emit('add');
            this.#tryToStartAnother();
        });
    }
    async addAll(functions, options) {
        return Promise.all(functions.map(async (function_) => this.add(function_, options)));
    }
    /**
    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
    */
    start() {
        if (!this.#isPaused) {
            return this;
        }
        this.#isPaused = false;
        this.#processQueue();
        return this;
    }
    /**
    Put queue execution on hold.
    */
    pause() {
        this.#isPaused = true;
    }
    /**
    Clear the queue.
    */
    clear() {
        this.#queue = new this.#queueClass();
        // Note: We don't clear #runningTasks as those tasks are still running
        // They will be removed when they complete in the finally block
        // Force synchronous update since clear() should have immediate effect
        this.#updateRateLimitState();
    }
    /**
    Can be called multiple times. Useful if you for example add additional items at a later time.

    @returns A promise that settles when the queue becomes empty.
    */
    async onEmpty() {
        // Instantly resolve if the queue is empty
        if (this.#queue.size === 0) {
            return;
        }
        await this.#onEvent('empty');
    }
    /**
    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.

    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.

    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
    */
    async onSizeLessThan(limit) {
        // Instantly resolve if the queue is empty.
        if (this.#queue.size < limit) {
            return;
        }
        await this.#onEvent('next', () => this.#queue.size < limit);
    }
    /**
    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.

    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
    */
    async onIdle() {
        // Instantly resolve if none pending and if nothing else is queued
        if (this.#pending === 0 && this.#queue.size === 0) {
            return;
        }
        await this.#onEvent('idle');
    }
    /**
    The difference with `.onIdle` is that `.onPendingZero` only waits for currently running tasks to finish, ignoring queued tasks.

    @returns A promise that settles when all currently running tasks have completed; `queue.pending === 0`.
    */
    async onPendingZero() {
        if (this.#pending === 0) {
            return;
        }
        await this.#onEvent('pendingZero');
    }
    /**
    @returns A promise that settles when the queue becomes rate-limited due to intervalCap.
    */
    async onRateLimit() {
        if (this.isRateLimited) {
            return;
        }
        await this.#onEvent('rateLimit');
    }
    /**
    @returns A promise that settles when the queue is no longer rate-limited.
    */
    async onRateLimitCleared() {
        if (!this.isRateLimited) {
            return;
        }
        await this.#onEvent('rateLimitCleared');
    }
    /**
    @returns A promise that rejects when any task in the queue errors.

    Use with `Promise.race([queue.onError(), queue.onIdle()])` to fail fast on the first error while still resolving normally when the queue goes idle.

    Important: The promise returned by `add()` still rejects. You must handle each `add()` promise (for example, `.catch(() => {})`) to avoid unhandled rejections.

    @example
    ```
    import PQueue from 'p-queue';

    const queue = new PQueue({concurrency: 2});

    queue.add(() => fetchData(1)).catch(() => {});
    queue.add(() => fetchData(2)).catch(() => {});
    queue.add(() => fetchData(3)).catch(() => {});

    // Stop processing on first error
    try {
        await Promise.race([
            queue.onError(),
            queue.onIdle()
        ]);
    } catch (error) {
        queue.pause(); // Stop processing remaining tasks
        console.error('Queue failed:', error);
    }
    ```
    */
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    async onError() {
        return new Promise((_resolve, reject) => {
            const handleError = (error) => {
                this.off('error', handleError);
                reject(error);
            };
            this.on('error', handleError);
        });
    }
    async #onEvent(event, filter) {
        return new Promise(resolve => {
            const listener = () => {
                if (filter && !filter()) {
                    return;
                }
                this.off(event, listener);
                resolve();
            };
            this.on(event, listener);
        });
    }
    /**
    Size of the queue, the number of queued items waiting to run.
    */
    get size() {
        return this.#queue.size;
    }
    /**
    Size of the queue, filtered by the given options.

    For example, this can be used to find the number of items remaining in the queue with a specific priority level.
    */
    sizeBy(options) {
        // eslint-disable-next-line unicorn/no-array-callback-reference
        return this.#queue.filter(options).length;
    }
    /**
    Number of running items (no longer in the queue).
    */
    get pending() {
        return this.#pending;
    }
    /**
    Whether the queue is currently paused.
    */
    get isPaused() {
        return this.#isPaused;
    }
    #setupRateLimitTracking() {
        // Only schedule updates when rate limiting is enabled
        if (this.#isIntervalIgnored) {
            return;
        }
        // Wire up to lifecycle events that affect rate limit state
        // Only 'add' and 'next' can actually change rate limit state
        this.on('add', () => {
            if (this.#queue.size > 0) {
                this.#scheduleRateLimitUpdate();
            }
        });
        this.on('next', () => {
            this.#scheduleRateLimitUpdate();
        });
    }
    #scheduleRateLimitUpdate() {
        // Skip if rate limiting is not enabled or already scheduled
        if (this.#isIntervalIgnored || this.#rateLimitFlushScheduled) {
            return;
        }
        this.#rateLimitFlushScheduled = true;
        queueMicrotask(() => {
            this.#rateLimitFlushScheduled = false;
            this.#updateRateLimitState();
        });
    }
    #updateRateLimitState() {
        const previous = this.#rateLimitedInInterval;
        const shouldBeRateLimited = !this.#isIntervalIgnored
            && this.#intervalCount >= this.#intervalCap
            && this.#queue.size > 0;
        if (shouldBeRateLimited !== previous) {
            this.#rateLimitedInInterval = shouldBeRateLimited;
            this.emit(shouldBeRateLimited ? 'rateLimit' : 'rateLimitCleared');
        }
    }
    /**
    Whether the queue is currently rate-limited due to intervalCap.
    */
    get isRateLimited() {
        return this.#rateLimitedInInterval;
    }
    /**
    Whether the queue is saturated. Returns `true` when:
    - All concurrency slots are occupied and tasks are waiting, OR
    - The queue is rate-limited and tasks are waiting

    Useful for detecting backpressure and potential hanging tasks.

    ```js
    import PQueue from 'p-queue';

    const queue = new PQueue({concurrency: 2});

    // Backpressure handling
    if (queue.isSaturated) {
        console.log('Queue is saturated, waiting for capacity...');
        await queue.onSizeLessThan(queue.concurrency);
    }

    // Monitoring for stuck tasks
    setInterval(() => {
        if (queue.isSaturated) {
            console.warn(`Queue saturated: ${queue.pending} running, ${queue.size} waiting`);
        }
    }, 60000);
    ```
    */
    get isSaturated() {
        return (this.#pending === this.#concurrency && this.#queue.size > 0)
            || (this.isRateLimited && this.#queue.size > 0);
    }
    /**
    The tasks currently being executed. Each task includes its `id`, `priority`, `startTime`, and `timeout` (if set).

    Returns an array of task info objects.

    ```js
    import PQueue from 'p-queue';

    const queue = new PQueue({concurrency: 2});

    // Add tasks with IDs for better debugging
    queue.add(() => fetchUser(123), {id: 'user-123'});
    queue.add(() => fetchPosts(456), {id: 'posts-456', priority: 1});

    // Check what's running
    console.log(queue.runningTasks);
    // => [{
    //   id: 'user-123',
    //   priority: 0,
    //   startTime: 1759253001716,
    //   timeout: undefined
    // }, {
    //   id: 'posts-456',
    //   priority: 1,
    //   startTime: 1759253001916,
    //   timeout: undefined
    // }]
    ```
    */
    get runningTasks() {
        // Return fresh array with fresh objects to prevent mutations
        return [...this.#runningTasks.values()].map(task => ({ ...task }));
    }
}
/**
Error thrown when a task times out.

@example
```
import PQueue, {TimeoutError} from 'p-queue';

const queue = new PQueue({timeout: 1000});

try {
    await queue.add(() => someTask());
} catch (error) {
    if (error instanceof TimeoutError) {
        console.log('Task timed out');
    }
}
```
*/



/***/ }),

/***/ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/p-queue/dist/lower-bound.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/p-queue/dist/lower-bound.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lowerBound)
/* harmony export */ });
// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound
// Used to compute insertion index to keep queue sorted after insertion
function lowerBound(array, value, comparator) {
    let first = 0;
    let count = array.length;
    while (count > 0) {
        const step = Math.trunc(count / 2);
        let it = first + step;
        if (comparator(array[it], value) <= 0) {
            first = ++it;
            count -= step + 1;
        }
        else {
            count = step;
        }
    }
    return first;
}


/***/ }),

/***/ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/p-queue/dist/priority-queue.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/p-queue/dist/priority-queue.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PriorityQueue)
/* harmony export */ });
/* harmony import */ var _lower_bound_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lower-bound.js */ "./node_modules/@nextcloud/upload/node_modules/@nextcloud/dialogs/node_modules/p-queue/dist/lower-bound.js");

class PriorityQueue {
    #queue = [];
    enqueue(run, options) {
        const { priority = 0, id, } = options ?? {};
        const element = {
            priority,
            id,
            run,
        };
        if (this.size === 0 || this.#queue[this.size - 1].priority >= priority) {
            this.#queue.push(element);
            return;
        }
        const index = (0,_lower_bound_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this.#queue, element, (a, b) => b.priority - a.priority);
        this.#queue.splice(index, 0, element);
    }
    setPriority(id, priority) {
        const index = this.#queue.findIndex((element) => element.id === id);
        if (index === -1) {
            throw new ReferenceError(`No promise function with the id "${id}" exists in the queue.`);
        }
        const [item] = this.#queue.splice(index, 1);
        this.enqueue(item.run, { priority, id });
    }
    dequeue() {
        const item = this.#queue.shift();
        return item?.run;
    }
    filter(options) {
        return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);
    }
    get size() {
        return this.#queue.length;
    }
}


/***/ }),

/***/ "./node_modules/@nextcloud/vue/dist/Components/NcBreadcrumb.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@nextcloud/vue/dist/Components/NcBreadcrumb.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _chunks_NcBreadcrumb_CcKJsew_mjs__WEBPACK_IMPORTED_MODULE_0__.N)
/* harmony export */ });
/* harmony import */ var _chunks_NcBreadcrumb_CcKJsew_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunks/NcBreadcrumb-CcKJsew_.mjs */ "./node_modules/@nextcloud/vue/dist/chunks/NcBreadcrumb-CcKJsew_.mjs");


//# sourceMappingURL=NcBreadcrumb.mjs.map


/***/ }),

/***/ "./node_modules/@nextcloud/vue/dist/Components/NcBreadcrumbs.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@nextcloud/vue/dist/Components/NcBreadcrumbs.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _chunks_NcBreadcrumbs_bDlnNcz1_mjs__WEBPACK_IMPORTED_MODULE_0__.N)
/* harmony export */ });
/* harmony import */ var _chunks_NcBreadcrumbs_bDlnNcz1_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunks/NcBreadcrumbs-bDlnNcz1.mjs */ "./node_modules/@nextcloud/vue/dist/chunks/NcBreadcrumbs-bDlnNcz1.mjs");


//# sourceMappingURL=NcBreadcrumbs.mjs.map


/***/ })

}]);
//# sourceMappingURL=node_modules_nextcloud_upload_node_modules_nextcloud_dialogs_dist_chunks_FilePicker-lO8J1a0C_mjs-node_modules_nextcloud_upload_node_modules_nextcloud_dialogs_dist_chunks_FilePicker-lO8J1a0C_mjs.js.map?v=baa0f178daf97b0f5844