/*! third party licenses: dist/vendor.LICENSE.txt */
function c(e){const t=new Uint8Array(e);let n="";for(const a of t)n+=String.fromCharCode(a);return btoa(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function p(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),n=(4-t.length%4)%4,a=t.padEnd(t.length+n,"="),o=atob(a),r=new ArrayBuffer(o.length),d=new Uint8Array(r);for(let l=0;l<o.length;l++)d[l]=o.charCodeAt(l);return r}function f(){return(window==null?void 0:window.PublicKeyCredential)!==void 0&&typeof window.PublicKeyCredential=="function"}function g(e){const{id:t}=e;return{...e,id:p(t),transports:e.transports}}function m(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class i extends Error{constructor({message:t,code:n,cause:a,name:o}){super(t,{cause:a}),this.name=o!=null?o:a.name,this.code=n}}function _({error:e,options:t}){var a,o;const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new i({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(((a=n.authenticatorSelection)==null?void 0:a.requireResidentKey)===!0)return new i({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(((o=n.authenticatorSelection)==null?void 0:o.userVerification)==="required")return new i({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new i({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new i({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return n.pubKeyCredParams.filter(r=>r.type==="public-key").length===0?new i({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new i({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const r=window.location.hostname;if(m(r)){if(n.rp.id!==r)return new i({message:'The RP ID "'.concat(n.rp.id,'" is invalid for this domain'),code:"ERROR_INVALID_RP_ID",cause:e})}else return new i({message:"".concat(window.location.hostname," is an invalid domain"),code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(n.user.id.byteLength<1||n.user.id.byteLength>64)return new i({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new i({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}class O{createNewAbortSignal(){if(this.controller){const n=new Error("Cancelling existing WebAuthn API call for new one");n.name="AbortError",this.controller.abort(n)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const A=new O,I=["cross-platform","platform"];function b(e){if(e&&!(I.indexOf(e)<0))return e}async function C(e){var R;if(!f())throw new Error("WebAuthn is not supported in this browser");const t={publicKey:{...e,challenge:p(e.challenge),user:{...e.user,id:p(e.user.id)},excludeCredentials:(R=e.excludeCredentials)==null?void 0:R.map(g)}};t.signal=A.createNewAbortSignal();let n;try{n=await navigator.credentials.create(t)}catch(s){throw _({error:s,options:t})}if(!n)throw new Error("Registration was not completed");const{id:a,rawId:o,response:r,type:d}=n;let l;typeof r.getTransports=="function"&&(l=r.getTransports());let u;if(typeof r.getPublicKeyAlgorithm=="function")try{u=r.getPublicKeyAlgorithm()}catch(s){E("getPublicKeyAlgorithm()",s)}let w;if(typeof r.getPublicKey=="function")try{const s=r.getPublicKey();s!==null&&(w=c(s))}catch(s){E("getPublicKey()",s)}let h;if(typeof r.getAuthenticatorData=="function")try{h=c(r.getAuthenticatorData())}catch(s){E("getAuthenticatorData()",s)}return{id:a,rawId:c(o),response:{attestationObject:c(r.attestationObject),clientDataJSON:c(r.clientDataJSON),transports:l,publicKeyAlgorithm:u,publicKey:w,authenticatorData:h},type:d,clientExtensionResults:n.getClientExtensionResults(),authenticatorAttachment:b(n.authenticatorAttachment)}}function E(e,t){console.warn("The browser extension that intercepted this WebAuthn API call incorrectly implemented ".concat(e,". You should report this error to them.\n"),t)}function T(){if(!f())return new Promise(t=>t(!1));const e=window.PublicKeyCredential;return e.isConditionalMediationAvailable===void 0?new Promise(t=>t(!1)):e.isConditionalMediationAvailable()}function S({error:e,options:t}){const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new i({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new i({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const a=window.location.hostname;if(m(a)){if(n.rpId!==a)return new i({message:'The RP ID "'.concat(n.rpId,'" is invalid for this domain'),code:"ERROR_INVALID_RP_ID",cause:e})}else return new i({message:"".concat(window.location.hostname," is an invalid domain"),code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new i({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function P(e,t=!1){var R,s;if(!f())throw new Error("WebAuthn is not supported in this browser");let n;((R=e.allowCredentials)==null?void 0:R.length)!==0&&(n=(s=e.allowCredentials)==null?void 0:s.map(g));const a={...e,challenge:p(e.challenge),allowCredentials:n},o={};if(t){if(!await T())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');o.mediation="conditional",a.allowCredentials=[]}o.publicKey=a,o.signal=A.createNewAbortSignal();let r;try{r=await navigator.credentials.get(o)}catch(y){throw S({error:y,options:o})}if(!r)throw new Error("Authentication was not completed");const{id:d,rawId:l,response:u,type:w}=r;let h;return u.userHandle&&(h=c(u.userHandle)),{id:d,rawId:c(l),response:{authenticatorData:c(u.authenticatorData),clientDataJSON:c(u.clientDataJSON),signature:c(u.signature),userHandle:h},type:w,clientExtensionResults:r.getClientExtensionResults(),authenticatorAttachment:b(r.authenticatorAttachment)}}export{C as a,f as b,P as s};
