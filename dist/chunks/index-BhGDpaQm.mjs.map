{"version":3,"file":"index-BhGDpaQm.mjs","sources":["../../node_modules/yocto-queue/index.js","../../node_modules/p-limit/index.js"],"sourcesContent":["/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n\tvalue;\n\tnext;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n}\n\nexport default class Queue {\n\t#head;\n\t#tail;\n\t#size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this.#head) {\n\t\t\tthis.#tail.next = node;\n\t\t\tthis.#tail = node;\n\t\t} else {\n\t\t\tthis.#head = node;\n\t\t\tthis.#tail = node;\n\t\t}\n\n\t\tthis.#size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this.#head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#head = this.#head.next;\n\t\tthis.#size--;\n\t\treturn current.value;\n\t}\n\n\tclear() {\n\t\tthis.#head = undefined;\n\t\tthis.#tail = undefined;\n\t\tthis.#size = 0;\n\t}\n\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this.#head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n}\n","import Queue from 'yocto-queue';\n\nexport default function pLimit(concurrency) {\n\tif (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.size > 0) {\n\t\t\tqueue.dequeue()();\n\t\t}\n\t};\n\n\tconst run = async (fn, resolve, args) => {\n\t\tactiveCount++;\n\n\t\tconst result = (async () => fn(...args))();\n\n\t\tresolve(result);\n\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\tnext();\n\t};\n\n\tconst enqueue = (fn, resolve, args) => {\n\t\tqueue.enqueue(run.bind(undefined, fn, resolve, args));\n\n\t\t(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// when the run function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve();\n\n\t\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\t\tqueue.dequeue()();\n\t\t\t}\n\t\t})();\n\t};\n\n\tconst generator = (fn, ...args) => new Promise(resolve => {\n\t\tenqueue(fn, resolve, args);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount,\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size,\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue: () => {\n\t\t\t\tqueue.clear();\n\t\t\t},\n\t\t},\n\t});\n\n\treturn generator;\n}\n"],"names":["Node","value","__publicField","Queue","#head","#tail","#size","node","__privateGet","__privateSet","__privateWrapper","current","pLimit","concurrency","queue","activeCount","next","run","fn","resolve","args","result","enqueue","generator"],"mappings":";8iBAKA,MAAMA,CAAK,CAIV,YAAYC,EAAO,CAHnBC,EAAA,cACAA,EAAA,aAGC,KAAK,MAAQD,CACb,CACF,WAEe,MAAME,CAAM,CAK1B,aAAc,CAJdC,EAAAA,KAAAA,GACAC,EAAAA,KAAAA,GACAC,EAAAA,KAAAA,GAGC,KAAK,MAAK,CACV,CAED,QAAQL,EAAO,CACd,MAAMM,EAAO,IAAIP,EAAKC,CAAK,EAEvBO,EAAA,KAAKJ,IACRI,EAAA,KAAKH,GAAM,KAAOE,EAClBE,EAAA,KAAKJ,EAAQE,KAEbE,EAAA,KAAKL,EAAQG,GACbE,EAAA,KAAKJ,EAAQE,IAGdG,EAAA,KAAKJ,GAAL,GACA,CAED,SAAU,CACT,MAAMK,EAAUH,EAAA,KAAKJ,GACrB,GAAKO,EAIL,OAAAF,EAAA,KAAKL,EAAQI,EAAA,KAAKJ,GAAM,MACxBM,EAAA,KAAKJ,GAAL,IACOK,EAAQ,KACf,CAED,OAAQ,CACPF,EAAA,KAAKL,EAAQ,QACbK,EAAA,KAAKJ,EAAQ,QACbI,EAAA,KAAKH,EAAQ,EACb,CAED,IAAI,MAAO,CACV,OAAOE,EAAA,KAAKF,EACZ,CAED,EAAG,OAAO,QAAQ,GAAI,CACrB,IAAIK,EAAUH,EAAA,KAAKJ,GAEnB,KAAOO,GACN,MAAMA,EAAQ,MACdA,EAAUA,EAAQ,IAEnB,CACF,CAnDCP,EAAAA,YACAC,EAAAA,YACAC,EAAAA,YCfc,SAASM,EAAOC,EAAa,CAC3C,GAAI,GAAG,OAAO,UAAUA,CAAW,GAAKA,IAAgB,OAAO,oBAAsBA,EAAc,GAClG,MAAM,IAAI,UAAU,qDAAqD,EAG1E,MAAMC,EAAQ,IAAIX,EAClB,IAAIY,EAAc,EAElB,MAAMC,EAAO,IAAM,CAClBD,IAEID,EAAM,KAAO,GAChBA,EAAM,QAAO,GAEhB,EAEOG,EAAM,MAAOC,EAAIC,EAASC,IAAS,CACxCL,IAEA,MAAMM,GAAU,SAAYH,EAAG,GAAGE,CAAI,GAAC,EAEvCD,EAAQE,CAAM,EAEd,GAAI,CACH,MAAMA,CACN,MAAO,CAAE,CAEVL,GACF,EAEOM,EAAU,CAACJ,EAAIC,EAASC,IAAS,CACtCN,EAAM,QAAQG,EAAI,KAAK,OAAWC,EAAIC,EAASC,CAAI,CAAC,GAEnD,UAKA,MAAM,QAAQ,UAEVL,EAAcF,GAAeC,EAAM,KAAO,GAC7CA,EAAM,QAAO,MAGjB,CAAA,EAEOS,EAAY,CAACL,KAAOE,IAAS,IAAI,QAAQD,GAAW,CACzDG,EAAQJ,EAAIC,EAASC,CAAI,CAC3B,CAAE,EAED,OAAO,OAAA,iBAAiBG,EAAW,CAClC,YAAa,CACZ,IAAK,IAAMR,CACX,EACD,aAAc,CACb,IAAK,IAAMD,EAAM,IACjB,EACD,WAAY,CACX,MAAO,IAAM,CACZA,EAAM,MAAK,CACX,CACD,CACH,CAAE,EAEMS,CACR","x_google_ignoreList":[0,1]}