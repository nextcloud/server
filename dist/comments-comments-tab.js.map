{"version":3,"file":"comments-comments-tab.js?v=a12372395549953c0876","mappings":"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","sources":["webpack:///nextcloud/webpack/runtime/chunk loaded","webpack:///nextcloud/webpack/runtime/load script","webpack:///nextcloud/node_modules/webdav/node_modules/minimatch/dist/esm/assert-valid-pattern.js","webpack:///nextcloud/node_modules/webdav/node_modules/minimatch/dist/esm/brace-expressions.js","webpack:///nextcloud/node_modules/webdav/node_modules/minimatch/dist/esm/unescape.js","webpack:///nextcloud/node_modules/webdav/node_modules/minimatch/dist/esm/ast.js","webpack:///nextcloud/node_modules/webdav/node_modules/minimatch/dist/esm/index.js","webpack:///nextcloud/node_modules/webdav/dist/node/tools/headers.js","webpack:///nextcloud/node_modules/webdav/node_modules/minimatch/dist/esm/escape.js","webpack:///nextcloud/node_modules/webdav/dist/node/tools/dav.js","webpack:///nextcloud/node_modules/layerr/dist/layerr.js","webpack:///nextcloud/apps/comments/src/services/GetComments.ts","webpack:///nextcloud/apps/comments/src/comments-activity-tab.ts","webpack:///nextcloud/apps/comments/src/comments-tab.js","webpack:///nextcloud/node_modules/webdav/dist/node/response.js","webpack:///nextcloud/apps/comments/src/logger.js","webpack:///nextcloud/apps/comments/src/services/DavClient.js","webpack:///nextcloud/apps/comments/src/utils/davUtils.js","webpack:///nextcloud/node_modules/balanced-match/index.js","webpack:///nextcloud/node_modules/brace-expansion/index.js","webpack:///nextcloud/node_modules/fast-xml-parser/src/fxp.js","webpack:///nextcloud/node_modules/nested-property/dist/nested-property.js","webpack:///nextcloud/node_modules/path-posix/index.js","webpack:///nextcloud/node_modules/pinia/dist/pinia.mjs","webpack:///nextcloud/webpack/bootstrap","webpack:///nextcloud/webpack/runtime/compat get default export","webpack:///nextcloud/webpack/runtime/define property getters","webpack:///nextcloud/webpack/runtime/ensure chunk","webpack:///nextcloud/webpack/runtime/get javascript chunk filename","webpack:///nextcloud/webpack/runtime/global","webpack:///nextcloud/webpack/runtime/hasOwnProperty shorthand","webpack:///nextcloud/webpack/runtime/make namespace object","webpack:///nextcloud/webpack/runtime/node module decorator","webpack:///nextcloud/webpack/runtime/runtimeId","webpack:///nextcloud/webpack/runtime/publicPath","webpack:///nextcloud/webpack/runtime/jsonp chunk loading","webpack:///nextcloud/webpack/runtime/nonce","webpack:///nextcloud/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var inProgress = {};\nvar dataWebpackPrefix = \"nextcloud:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","const MAX_PATTERN_LENGTH = 1024 * 64;\nexport const assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\n//# sourceMappingURL=assert-valid-pattern.js.map","// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\n//# sourceMappingURL=brace-expressions.js.map","/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n        : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\n//# sourceMappingURL=unescape.js.map","// parse a single path portion\nimport { parseClass } from './brace-expressions.js';\nimport { unescape } from './unescape.js';\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nexport class AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                unescape(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, unescape(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            unescape(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = parseClass(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, unescape(glob), !!hasMagic, uflag];\n    }\n}\n//# sourceMappingURL=ast.js.map","import expand from 'brace-expansion';\nimport { assertValidPattern } from './assert-valid-pattern.js';\nimport { AST } from './ast.js';\nimport { escape } from './escape.js';\nimport { unescape } from './unescape.js';\nexport const minimatch = (p, pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nminimatch.sep = sep;\nexport const GLOBSTAR = Symbol('globstar **');\nminimatch.GLOBSTAR = GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nexport const filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);\nminimatch.filter = filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nexport const defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: GLOBSTAR,\n    });\n};\nminimatch.defaults = defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return expand(pattern);\n};\nminimatch.braceExpand = braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nexport const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nminimatch.makeRe = makeRe;\nexport const match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nminimatch.match = match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nexport class Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        assertValidPattern(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern) {\n        assertValidPattern(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === 'object') {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, 'test', { value: fastTest });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === GLOBSTAR\n                        ? GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== GLOBSTAR || prev === GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js';\nexport { escape } from './escape.js';\nexport { unescape } from './unescape.js';\n/* c8 ignore stop */\nminimatch.AST = AST;\nminimatch.Minimatch = Minimatch;\nminimatch.escape = escape;\nminimatch.unescape = unescape;\n//# sourceMappingURL=index.js.map","export function convertResponseHeaders(headers) {\n    const output = {};\n    for (const key of headers.keys()) {\n        output[key] = headers.get(key);\n    }\n    return output;\n}\nexport function mergeHeaders(...headerPayloads) {\n    if (headerPayloads.length === 0)\n        return {};\n    const headerKeys = {};\n    return headerPayloads.reduce((output, headers) => {\n        Object.keys(headers).forEach(header => {\n            const lowerHeader = header.toLowerCase();\n            if (headerKeys.hasOwnProperty(lowerHeader)) {\n                output[headerKeys[lowerHeader]] = headers[header];\n            }\n            else {\n                headerKeys[lowerHeader] = header;\n                output[header] = headers[header];\n            }\n        });\n        return output;\n    }, {});\n}\n","/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\n//# sourceMappingURL=escape.js.map","import path from \"path-posix\";\nimport { XMLParser } from \"fast-xml-parser\";\nimport nestedProp from \"nested-property\";\nimport { encodePath, normalisePath } from \"./path.js\";\nvar PropertyType;\n(function (PropertyType) {\n    PropertyType[\"Array\"] = \"array\";\n    PropertyType[\"Object\"] = \"object\";\n    PropertyType[\"Original\"] = \"original\";\n})(PropertyType || (PropertyType = {}));\nfunction getParser() {\n    return new XMLParser({\n        removeNSPrefix: true,\n        numberParseOptions: {\n            hex: true,\n            leadingZeros: false\n        }\n        // We don't use the processors here as decoding is done manually\n        // later on - decoding early would break some path checks.\n    });\n}\nfunction getPropertyOfType(obj, prop, type = PropertyType.Original) {\n    const val = nestedProp.get(obj, prop);\n    if (type === \"array\" && Array.isArray(val) === false) {\n        return [val];\n    }\n    else if (type === \"object\" && Array.isArray(val)) {\n        return val[0];\n    }\n    return val;\n}\nfunction normaliseResponse(response) {\n    const output = Object.assign({}, response);\n    // Only either status OR propstat is allowed\n    if (output.status) {\n        nestedProp.set(output, \"status\", getPropertyOfType(output, \"status\", PropertyType.Object));\n    }\n    else {\n        nestedProp.set(output, \"propstat\", getPropertyOfType(output, \"propstat\", PropertyType.Object));\n        nestedProp.set(output, \"propstat.prop\", getPropertyOfType(output, \"propstat.prop\", PropertyType.Object));\n    }\n    return output;\n}\nfunction normaliseResult(result) {\n    const { multistatus } = result;\n    if (multistatus === \"\") {\n        return {\n            multistatus: {\n                response: []\n            }\n        };\n    }\n    if (!multistatus) {\n        throw new Error(\"Invalid response: No root multistatus found\");\n    }\n    const output = {\n        multistatus: Array.isArray(multistatus) ? multistatus[0] : multistatus\n    };\n    nestedProp.set(output, \"multistatus.response\", getPropertyOfType(output, \"multistatus.response\", PropertyType.Array));\n    nestedProp.set(output, \"multistatus.response\", nestedProp.get(output, \"multistatus.response\").map(response => normaliseResponse(response)));\n    return output;\n}\n/**\n * Parse an XML response from a WebDAV service,\n *  converting it to an internal DAV result\n * @param xml The raw XML string\n * @returns A parsed and processed DAV result\n */\nexport function parseXML(xml) {\n    return new Promise(resolve => {\n        const result = getParser().parse(xml);\n        resolve(normaliseResult(result));\n    });\n}\n/**\n * Get a file stat result from given DAV properties\n * @param props DAV properties\n * @param filename The filename for the file stat\n * @param isDetailed Whether or not the raw props of the resource should be returned\n * @returns A file stat result\n */\nexport function prepareFileFromProps(props, filename, isDetailed = false) {\n    // Last modified time, raw size, item type and mime\n    const { getlastmodified: lastMod = null, getcontentlength: rawSize = \"0\", resourcetype: resourceType = null, getcontenttype: mimeType = null, getetag: etag = null } = props;\n    const type = resourceType &&\n        typeof resourceType === \"object\" &&\n        typeof resourceType.collection !== \"undefined\"\n        ? \"directory\"\n        : \"file\";\n    const stat = {\n        filename,\n        basename: path.basename(filename),\n        lastmod: lastMod,\n        size: parseInt(rawSize, 10),\n        type,\n        etag: typeof etag === \"string\" ? etag.replace(/\"/g, \"\") : null\n    };\n    if (type === \"file\") {\n        stat.mime = mimeType && typeof mimeType === \"string\" ? mimeType.split(\";\")[0] : \"\";\n    }\n    if (isDetailed) {\n        // The XML parser tries to interpret values, but the display name is required to be a string\n        if (typeof props.displayname !== \"undefined\") {\n            props.displayname = String(props.displayname);\n        }\n        stat.props = props;\n    }\n    return stat;\n}\n/**\n * Parse a DAV result for file stats\n * @param result The resulting DAV response\n * @param filename The filename that was stat'd\n * @param isDetailed Whether or not the raw props of\n *  the resource should be returned\n * @returns A file stat result\n */\nexport function parseStat(result, filename, isDetailed = false) {\n    let responseItem = null;\n    try {\n        // should be a propstat response, if not the if below will throw an error\n        if (result.multistatus.response[0].propstat) {\n            responseItem = result.multistatus.response[0];\n        }\n    }\n    catch (e) {\n        /* ignore */\n    }\n    if (!responseItem) {\n        throw new Error(\"Failed getting item stat: bad response\");\n    }\n    const { propstat: { prop: props, status: statusLine } } = responseItem;\n    // As defined in https://tools.ietf.org/html/rfc2068#section-6.1\n    const [_, statusCodeStr, statusText] = statusLine.split(\" \", 3);\n    const statusCode = parseInt(statusCodeStr, 10);\n    if (statusCode >= 400) {\n        const err = new Error(`Invalid response: ${statusCode} ${statusText}`);\n        err.status = statusCode;\n        throw err;\n    }\n    const filePath = normalisePath(filename);\n    return prepareFileFromProps(props, filePath, isDetailed);\n}\n/**\n * Parse a DAV result for a search request\n *\n * @param result The resulting DAV response\n * @param searchArbiter The collection path that was searched\n * @param isDetailed Whether or not the raw props of the resource should be returned\n */\nexport function parseSearch(result, searchArbiter, isDetailed) {\n    const response = {\n        truncated: false,\n        results: []\n    };\n    response.truncated = result.multistatus.response.some(v => {\n        return ((v.status || v.propstat?.status).split(\" \", 3)?.[1] === \"507\" &&\n            v.href.replace(/\\/$/, \"\").endsWith(encodePath(searchArbiter).replace(/\\/$/, \"\")));\n    });\n    result.multistatus.response.forEach(result => {\n        if (result.propstat === undefined) {\n            return;\n        }\n        const filename = result.href.split(\"/\").map(decodeURIComponent).join(\"/\");\n        response.results.push(prepareFileFromProps(result.propstat.prop, filename, isDetailed));\n    });\n    return response;\n}\n/**\n * Translate a disk quota indicator to a recognised\n *  value (includes \"unlimited\" and \"unknown\")\n * @param value The quota indicator, eg. \"-3\"\n * @returns The value in bytes, or another indicator\n */\nexport function translateDiskSpace(value) {\n    switch (String(value)) {\n        case \"-3\":\n            return \"unlimited\";\n        case \"-2\":\n        /* falls-through */\n        case \"-1\":\n            // -1 is non-computed\n            return \"unknown\";\n        default:\n            return parseInt(String(value), 10);\n    }\n}\n","import { assertError, isError } from \"./error.js\";\nimport { getGlobalName } from \"./global.js\";\nimport { parseArguments } from \"./tools.js\";\nexport class Layerr extends Error {\n    constructor(errorOptionsOrMessage, messageText) {\n        const args = [...arguments];\n        const { options, shortMessage } = parseArguments(args);\n        let message = shortMessage;\n        if (options.cause) {\n            message = `${message}: ${options.cause.message}`;\n        }\n        super(message);\n        this.message = message;\n        if (options.name && typeof options.name === \"string\") {\n            this.name = options.name;\n        }\n        else {\n            this.name = getGlobalName();\n        }\n        if (options.cause) {\n            Object.defineProperty(this, \"_cause\", { value: options.cause });\n        }\n        Object.defineProperty(this, \"_info\", { value: {} });\n        if (options.info && typeof options.info === \"object\") {\n            Object.assign(this._info, options.info);\n        }\n        if (Error.captureStackTrace) {\n            const ctor = options.constructorOpt || this.constructor;\n            Error.captureStackTrace(this, ctor);\n        }\n    }\n    static cause(err) {\n        assertError(err);\n        if (!err._cause)\n            return null;\n        return isError(err._cause)\n            ? err._cause\n            : null;\n    }\n    static fullStack(err) {\n        assertError(err);\n        const cause = Layerr.cause(err);\n        if (cause) {\n            return `${err.stack}\\ncaused by: ${Layerr.fullStack(cause)}`;\n        }\n        return err.stack ?? \"\";\n    }\n    static info(err) {\n        assertError(err);\n        const output = {};\n        const cause = Layerr.cause(err);\n        if (cause) {\n            Object.assign(output, Layerr.info(cause));\n        }\n        if (err._info) {\n            Object.assign(output, err._info);\n        }\n        return output;\n    }\n    toString() {\n        let output = this.name ||\n            this.constructor.name ||\n            this.constructor.prototype.name;\n        if (this.message) {\n            output = `${output}: ${this.message}`;\n        }\n        return output;\n    }\n}\n","/**\n * @copyright Copyright (c) 2020 John Molakvoæ <skjnldsv@protonmail.com>\n *\n * @author John Molakvoæ <skjnldsv@protonmail.com>\n *\n * @license AGPL-3.0-or-later\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\nimport { parseXML } from 'webdav';\n// https://github.com/perry-mitchell/webdav-client/issues/339\nimport { processResponsePayload } from 'webdav/dist/node/response.js';\nimport { prepareFileFromProps } from 'webdav/dist/node/tools/dav.js';\nimport client from './DavClient.js';\nexport const DEFAULT_LIMIT = 20;\n/**\n * Retrieve the comments list\n *\n * @param {object} data destructuring object\n * @param {string} data.resourceType the resource type\n * @param {number} data.resourceId the resource ID\n * @param {object} [options] optional options for axios\n * @param {number} [options.offset] the pagination offset\n * @param {number} [options.limit] the pagination limit, defaults to 20\n * @param {Date} [options.datetime] optional date to query\n * @return {{data: object[]}} the comments list\n */\nexport const getComments = async function ({ resourceType, resourceId }, options) {\n    const resourcePath = ['', resourceType, resourceId].join('/');\n    const datetime = options.datetime ? `<oc:datetime>${options.datetime.toISOString()}</oc:datetime>` : '';\n    const response = await client.customRequest(resourcePath, Object.assign({\n        method: 'REPORT',\n        data: `<?xml version=\"1.0\"?>\n\t\t\t<oc:filter-comments\n\t\t\t\txmlns:d=\"DAV:\"\n\t\t\t\txmlns:oc=\"http://owncloud.org/ns\"\n\t\t\t\txmlns:nc=\"http://nextcloud.org/ns\"\n\t\t\t\txmlns:ocs=\"http://open-collaboration-services.org/ns\">\n\t\t\t\t<oc:limit>${options.limit ?? DEFAULT_LIMIT}</oc:limit>\n\t\t\t\t<oc:offset>${options.offset || 0}</oc:offset>\n\t\t\t\t${datetime}\n\t\t\t</oc:filter-comments>`,\n    }, options));\n    const responseData = await response.text();\n    const result = await parseXML(responseData);\n    const stat = getDirectoryFiles(result, true);\n    return processResponsePayload(response, stat, true);\n};\n// https://github.com/perry-mitchell/webdav-client/blob/8d9694613c978ce7404e26a401c39a41f125f87f/source/operations/directoryContents.ts\nconst getDirectoryFiles = function (result, isDetailed = false) {\n    // Extract the response items (directory contents)\n    const { multistatus: { response: responseItems }, } = result;\n    // Map all items to a consistent output structure (results)\n    return responseItems.map(item => {\n        // Each item should contain a stat object\n        const props = item.propstat.prop;\n        return prepareFileFromProps(props, props.id.toString(), isDetailed);\n    });\n};\n","/**\n * SPDX-FileCopyrightText: 2023 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nimport moment from '@nextcloud/moment';\nimport Vue, {} from 'vue';\nimport logger from './logger.js';\nimport { getComments } from './services/GetComments.js';\nimport { PiniaVuePlugin, createPinia } from 'pinia';\nVue.use(PiniaVuePlugin);\nlet ActivityTabPluginView;\nlet ActivityTabPluginInstance;\n/**\n * Register the comments plugins for the Activity sidebar\n */\nexport function registerCommentsPlugins() {\n    window.OCA.Activity.registerSidebarAction({\n        mount: async (el, { context, fileInfo, reload }) => {\n            const pinia = createPinia();\n            if (!ActivityTabPluginView) {\n                const { default: ActivityCommentAction } = await import('./views/ActivityCommentAction.vue');\n                /** @ts-expect-error Types are broken for Vue2 */\n                ActivityTabPluginView = Vue.extend(ActivityCommentAction);\n            }\n            ActivityTabPluginInstance = new ActivityTabPluginView({\n                el,\n                parent: context,\n                pinia,\n                propsData: {\n                    reloadCallback: reload,\n                    resourceId: fileInfo.id,\n                },\n            });\n            logger.info('Comments plugin mounted in Activity sidebar action', { fileInfo });\n        },\n        unmount: () => {\n            // destroy previous instance if available\n            if (ActivityTabPluginInstance) {\n                ActivityTabPluginInstance.$destroy();\n            }\n        },\n    });\n    window.OCA.Activity.registerSidebarEntries(async ({ fileInfo, limit, offset }) => {\n        const { data: comments } = await getComments({ resourceType: 'files', resourceId: fileInfo.id }, { limit, offset });\n        logger.debug('Loaded comments', { fileInfo, comments });\n        const { default: CommentView } = await import('./views/ActivityCommentEntry.vue');\n        /** @ts-expect-error Types are broken for Vue2 */\n        const CommentsViewObject = Vue.extend(CommentView);\n        return comments.map((comment) => ({\n            _CommentsViewInstance: undefined,\n            timestamp: moment(comment.props?.creationDateTime).toDate().getTime(),\n            mount(element, { context, reload }) {\n                this._CommentsViewInstance = new CommentsViewObject({\n                    el: element,\n                    parent: context,\n                    propsData: {\n                        comment,\n                        resourceId: fileInfo.id,\n                        reloadCallback: reload,\n                    },\n                });\n            },\n            unmount() {\n                this._CommentsViewInstance?.$destroy();\n            },\n        }));\n    });\n    window.OCA.Activity.registerSidebarFilter((activity) => activity.type !== 'comments');\n    logger.info('Comments plugin registered for Activity sidebar action');\n}\n","/**\n * @copyright Copyright (c) 2020 John Molakvoæ <skjnldsv@protonmail.com>\n *\n * @author John Molakvoæ <skjnldsv@protonmail.com>\n *\n * @license AGPL-3.0-or-later\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n// eslint-disable-next-line n/no-missing-import, import/no-unresolved\nimport MessageReplyText from '@mdi/svg/svg/message-reply-text.svg?raw'\nimport { getRequestToken } from '@nextcloud/auth'\nimport { loadState } from '@nextcloud/initial-state'\nimport { registerCommentsPlugins } from './comments-activity-tab.ts'\n\n// @ts-expect-error __webpack_nonce__ is injected by webpack\n__webpack_nonce__ = btoa(getRequestToken())\n\nif (loadState('comments', 'activityEnabled', false) && OCA?.Activity?.registerSidebarAction !== undefined) {\n\t// Do not mount own tab but mount into activity\n\twindow.addEventListener('DOMContentLoaded', function() {\n\t\tregisterCommentsPlugins()\n\t})\n} else {\n\t// Init Comments tab component\n\tlet TabInstance = null\n\tconst commentTab = new OCA.Files.Sidebar.Tab({\n\t\tid: 'comments',\n\t\tname: t('comments', 'Comments'),\n\t\ticonSvg: MessageReplyText,\n\n\t\tasync mount(el, fileInfo, context) {\n\t\t\tif (TabInstance) {\n\t\t\t\tTabInstance.$destroy()\n\t\t\t}\n\t\t\tTabInstance = new OCA.Comments.View('files', {\n\t\t\t\t// Better integration with vue parent component\n\t\t\t\tparent: context,\n\t\t\t\tpropsData: {\n\t\t\t\t\tresourceId: fileInfo.id,\n\t\t\t\t},\n\t\t\t})\n\t\t\t// Only mount after we have all the info we need\n\t\t\tawait TabInstance.update(fileInfo.id)\n\t\t\tTabInstance.$mount(el)\n\t\t},\n\t\tupdate(fileInfo) {\n\t\t\tTabInstance.update(fileInfo.id)\n\t\t},\n\t\tdestroy() {\n\t\t\tTabInstance.$destroy()\n\t\t\tTabInstance = null\n\t\t},\n\t\tscrollBottomReached() {\n\t\t\tTabInstance.onScrollBottomReached()\n\t\t},\n\t})\n\n\twindow.addEventListener('DOMContentLoaded', function() {\n\t\tif (OCA.Files && OCA.Files.Sidebar) {\n\t\t\tOCA.Files.Sidebar.registerTab(commentTab)\n\t\t}\n\t})\n}\n","import { minimatch } from \"minimatch\";\nimport { convertResponseHeaders } from \"./tools/headers.js\";\nexport function createErrorFromResponse(response, prefix = \"\") {\n    const err = new Error(`${prefix}Invalid response: ${response.status} ${response.statusText}`);\n    err.status = response.status;\n    err.response = response;\n    return err;\n}\nexport function handleResponseCode(context, response) {\n    const { status } = response;\n    if (status === 401 && context.digest)\n        return response;\n    if (status >= 400) {\n        const err = createErrorFromResponse(response);\n        throw err;\n    }\n    return response;\n}\nexport function processGlobFilter(files, glob) {\n    return files.filter(file => minimatch(file.filename, glob, { matchBase: true }));\n}\n/**\n * Process a response payload (eg. from `customRequest`) and\n *  prepare it for further processing. Exposed for custom\n *  request handling.\n * @param response The response for a request\n * @param data The data returned\n * @param isDetailed Whether or not a detailed result is\n *  requested\n * @returns The response data, or a detailed response object\n *  if required\n */\nexport function processResponsePayload(response, data, isDetailed = false) {\n    return isDetailed\n        ? {\n            data,\n            headers: response.headers ? convertResponseHeaders(response.headers) : {},\n            status: response.status,\n            statusText: response.statusText\n        }\n        : data;\n}\n","/**\n * @copyright Copyright (c) 2023 Lucas Azevedo <lhs_azevedo@hotmail.com>\n *\n * @author Lucas Azevedo <lhs_azevedo@hotmail.com>\n *\n * @license AGPL-3.0-or-later\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\nimport { getLoggerBuilder } from '@nextcloud/logger'\n\nexport default getLoggerBuilder()\n\t.setApp('comments')\n\t.detectUser()\n\t.build()\n","/**\n * @copyright Copyright (c) 2021 John Molakvoæ <skjnldsv@protonmail.com>\n *\n * @author John Molakvoæ <skjnldsv@protonmail.com>\n *\n * @license AGPL-3.0-or-later\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\nimport { createClient } from 'webdav'\nimport { getRootPath } from '../utils/davUtils.js'\nimport { getRequestToken, onRequestTokenUpdate } from '@nextcloud/auth'\n\n// init webdav client\nconst client = createClient(getRootPath())\n\n// set CSRF token header\nconst setHeaders = (token) => {\n  client.setHeaders({\n    // Add this so the server knows it is an request from the browser\n    'X-Requested-With': 'XMLHttpRequest',\n    // Inject user auth\n    requesttoken: token ?? '',\n  })\n}\n\n// refresh headers when request token changes\nonRequestTokenUpdate(setHeaders)\nsetHeaders(getRequestToken())\n\nexport default client\n","/**\n * @copyright Copyright (c) 2020 John Molakvoæ <skjnldsv@protonmail.com>\n *\n * @author John Molakvoæ <skjnldsv@protonmail.com>\n *\n * @license AGPL-3.0-or-later\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\nimport { generateRemoteUrl } from '@nextcloud/router'\n\nconst getRootPath = function() {\n\treturn generateRemoteUrl('dav/comments')\n}\n\nexport { getRootPath }\n","'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","var balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  if (/\\$$/.test(m.pre)) {    \n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre+ '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function(p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length)\n      var incr = n.length == 3\n        ? Math.abs(numeric(n[2]))\n        : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\')\n            c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0)\n                c = '-' + z + c.slice(1);\n              else\n                c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion)\n          expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}\n\n","'use strict';\n\nconst validator = require('./validator');\nconst XMLParser = require('./xmlparser/XMLParser');\nconst XMLBuilder = require('./xmlbuilder/json2xml');\n\nmodule.exports = {\n  XMLParser: XMLParser,\n  XMLValidator: validator,\n  XMLBuilder: XMLBuilder\n}","/**\n* @license nested-property https://github.com/cosmosio/nested-property\n*\n* The MIT License (MIT)\n*\n* Copyright (c) 2014-2020 Olivier Scherrer <pode.fr@gmail.com>\n*/\n\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar ARRAY_WILDCARD = \"+\";\nvar PATH_DELIMITER = \".\";\n\nvar ObjectPrototypeMutationError = /*#__PURE__*/function (_Error) {\n  _inherits(ObjectPrototypeMutationError, _Error);\n\n  function ObjectPrototypeMutationError(params) {\n    var _this;\n\n    _classCallCheck(this, ObjectPrototypeMutationError);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ObjectPrototypeMutationError).call(this, params));\n    _this.name = \"ObjectPrototypeMutationError\";\n    return _this;\n  }\n\n  return ObjectPrototypeMutationError;\n}(_wrapNativeSuper(Error));\n\nmodule.exports = {\n  set: setNestedProperty,\n  get: getNestedProperty,\n  has: hasNestedProperty,\n  hasOwn: function hasOwn(object, property, options) {\n    return this.has(object, property, options || {\n      own: true\n    });\n  },\n  isIn: isInNestedProperty,\n  ObjectPrototypeMutationError: ObjectPrototypeMutationError\n};\n/**\n * Get the property of an object nested in one or more objects or array\n * Given an object such as a.b.c.d = 5, getNestedProperty(a, \"b.c.d\") will return 5.\n * It also works through arrays. Given a nested array such as a[0].b = 5, getNestedProperty(a, \"0.b\") will return 5.\n * For accessing nested properties through all items in an array, you may use the array wildcard \"+\".\n * For instance, getNestedProperty([{a:1}, {a:2}, {a:3}], \"+.a\") will return [1, 2, 3]\n * @param {Object} object the object to get the property from\n * @param {String} property the path to the property as a string\n * @returns the object or the the property value if found\n */\n\nfunction getNestedProperty(object, property) {\n  if (_typeof(object) != \"object\" || object === null) {\n    return object;\n  }\n\n  if (typeof property == \"undefined\") {\n    return object;\n  }\n\n  if (typeof property == \"number\") {\n    return object[property];\n  }\n\n  try {\n    return traverse(object, property, function _getNestedProperty(currentObject, currentProperty) {\n      return currentObject[currentProperty];\n    });\n  } catch (err) {\n    return object;\n  }\n}\n/**\n * Tell if a nested object has a given property (or array a given index)\n * given an object such as a.b.c.d = 5, hasNestedProperty(a, \"b.c.d\") will return true.\n * It also returns true if the property is in the prototype chain.\n * @param {Object} object the object to get the property from\n * @param {String} property the path to the property as a string\n * @param {Object} options:\n *  - own: set to reject properties from the prototype\n * @returns true if has (property in object), false otherwise\n */\n\n\nfunction hasNestedProperty(object, property) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (_typeof(object) != \"object\" || object === null) {\n    return false;\n  }\n\n  if (typeof property == \"undefined\") {\n    return false;\n  }\n\n  if (typeof property == \"number\") {\n    return property in object;\n  }\n\n  try {\n    var has = false;\n    traverse(object, property, function _hasNestedProperty(currentObject, currentProperty, segments, index) {\n      if (isLastSegment(segments, index)) {\n        if (options.own) {\n          has = currentObject.hasOwnProperty(currentProperty);\n        } else {\n          has = currentProperty in currentObject;\n        }\n      } else {\n        return currentObject && currentObject[currentProperty];\n      }\n    });\n    return has;\n  } catch (err) {\n    return false;\n  }\n}\n/**\n * Set the property of an object nested in one or more objects\n * If the property doesn't exist, it gets created.\n * @param {Object} object\n * @param {String} property\n * @param value the value to set\n * @returns object if no assignment was made or the value if the assignment was made\n */\n\n\nfunction setNestedProperty(object, property, value) {\n  if (_typeof(object) != \"object\" || object === null) {\n    return object;\n  }\n\n  if (typeof property == \"undefined\") {\n    return object;\n  }\n\n  if (typeof property == \"number\") {\n    object[property] = value;\n    return object[property];\n  }\n\n  try {\n    return traverse(object, property, function _setNestedProperty(currentObject, currentProperty, segments, index) {\n      if (currentObject === Reflect.getPrototypeOf({})) {\n        throw new ObjectPrototypeMutationError(\"Attempting to mutate Object.prototype\");\n      }\n\n      if (!currentObject[currentProperty]) {\n        var nextPropIsNumber = Number.isInteger(Number(segments[index + 1]));\n        var nextPropIsArrayWildcard = segments[index + 1] === ARRAY_WILDCARD;\n\n        if (nextPropIsNumber || nextPropIsArrayWildcard) {\n          currentObject[currentProperty] = [];\n        } else {\n          currentObject[currentProperty] = {};\n        }\n      }\n\n      if (isLastSegment(segments, index)) {\n        currentObject[currentProperty] = value;\n      }\n\n      return currentObject[currentProperty];\n    });\n  } catch (err) {\n    if (err instanceof ObjectPrototypeMutationError) {\n      // rethrow\n      throw err;\n    } else {\n      return object;\n    }\n  }\n}\n/**\n * Tell if an object is on the path to a nested property\n * If the object is on the path, and the path exists, it returns true, and false otherwise.\n * @param {Object} object to get the nested property from\n * @param {String} property name of the nested property\n * @param {Object} objectInPath the object to check\n * @param {Object} options:\n *  - validPath: return false if the path is invalid, even if the object is in the path\n * @returns {boolean} true if the object is on the path\n */\n\n\nfunction isInNestedProperty(object, property, objectInPath) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (_typeof(object) != \"object\" || object === null) {\n    return false;\n  }\n\n  if (typeof property == \"undefined\") {\n    return false;\n  }\n\n  try {\n    var isIn = false,\n        pathExists = false;\n    traverse(object, property, function _isInNestedProperty(currentObject, currentProperty, segments, index) {\n      isIn = isIn || currentObject === objectInPath || !!currentObject && currentObject[currentProperty] === objectInPath;\n      pathExists = isLastSegment(segments, index) && _typeof(currentObject) === \"object\" && currentProperty in currentObject;\n      return currentObject && currentObject[currentProperty];\n    });\n\n    if (options.validPath) {\n      return isIn && pathExists;\n    } else {\n      return isIn;\n    }\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction traverse(object, path) {\n  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n  var segments = path.split(PATH_DELIMITER);\n  var length = segments.length;\n\n  var _loop = function _loop(idx) {\n    var currentSegment = segments[idx];\n\n    if (!object) {\n      return {\n        v: void 0\n      };\n    }\n\n    if (currentSegment === ARRAY_WILDCARD) {\n      if (Array.isArray(object)) {\n        return {\n          v: object.map(function (value, index) {\n            var remainingSegments = segments.slice(idx + 1);\n\n            if (remainingSegments.length > 0) {\n              return traverse(value, remainingSegments.join(PATH_DELIMITER), callback);\n            } else {\n              return callback(object, index, segments, idx);\n            }\n          })\n        };\n      } else {\n        var pathToHere = segments.slice(0, idx).join(PATH_DELIMITER);\n        throw new Error(\"Object at wildcard (\".concat(pathToHere, \") is not an array\"));\n      }\n    } else {\n      object = callback(object, currentSegment, segments, idx);\n    }\n  };\n\n  for (var idx = 0; idx < length; idx++) {\n    var _ret = _loop(idx);\n\n    if (_typeof(_ret) === \"object\") return _ret.v;\n  }\n\n  return object;\n}\n\nfunction isLastSegment(segments, index) {\n  return segments.length === index + 1;\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\nvar util = require('util');\nvar isString = function (x) {\n  return typeof x === 'string';\n};\n\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  var res = [];\n  for (var i = 0; i < parts.length; i++) {\n    var p = parts[i];\n\n    // ignore empty parts\n    if (!p || p === '.')\n      continue;\n\n    if (p === '..') {\n      if (res.length && res[res.length - 1] !== '..') {\n        res.pop();\n      } else if (allowAboveRoot) {\n        res.push('..');\n      }\n    } else {\n      res.push(p);\n    }\n  }\n\n  return res;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar posix = {};\n\n\nfunction posixSplitPath(filename) {\n  return splitPathRe.exec(filename).slice(1);\n}\n\n\n// path.resolve([from ...], to)\n// posix version\nposix.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (!isString(path)) {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(resolvedPath.split('/'),\n                                !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nposix.normalize = function(path) {\n  var isAbsolute = posix.isAbsolute(path),\n      trailingSlash = path.substr(-1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(path.split('/'), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nposix.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nposix.join = function() {\n  var path = '';\n  for (var i = 0; i < arguments.length; i++) {\n    var segment = arguments[i];\n    if (!isString(segment)) {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    if (segment) {\n      if (!path) {\n        path += segment;\n      } else {\n        path += '/' + segment;\n      }\n    }\n  }\n  return posix.normalize(path);\n};\n\n\n// path.relative(from, to)\n// posix version\nposix.relative = function(from, to) {\n  from = posix.resolve(from).substr(1);\n  to = posix.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\n\nposix._makeLong = function(path) {\n  return path;\n};\n\n\nposix.dirname = function(path) {\n  var result = posixSplitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nposix.basename = function(path, ext) {\n  var f = posixSplitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nposix.extname = function(path) {\n  return posixSplitPath(path)[3];\n};\n\n\nposix.format = function(pathObject) {\n  if (!util.isObject(pathObject)) {\n    throw new TypeError(\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\n    );\n  }\n\n  var root = pathObject.root || '';\n\n  if (!isString(root)) {\n    throw new TypeError(\n        \"'pathObject.root' must be a string or undefined, not \" +\n        typeof pathObject.root\n    );\n  }\n\n  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';\n  var base = pathObject.base || '';\n  return dir + base;\n};\n\n\nposix.parse = function(pathString) {\n  if (!isString(pathString)) {\n    throw new TypeError(\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\n    );\n  }\n  var allParts = posixSplitPath(pathString);\n  if (!allParts || allParts.length !== 4) {\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\n  }\n  allParts[1] = allParts[1] || '';\n  allParts[2] = allParts[2] || '';\n  allParts[3] = allParts[3] || '';\n\n  return {\n    root: allParts[0],\n    dir: allParts[0] + allParts[1].slice(0, allParts[1].length - 1),\n    base: allParts[2],\n    ext: allParts[3],\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\n  };\n};\n\n\nposix.sep = '/';\nposix.delimiter = ':';\n\n  module.exports = posix;\n","/*!\n * pinia v2.2.8\n * (c) 2024 Eduardo San Martin Morote\n * @license MIT\n */\nimport { hasInjectionContext, inject, toRaw, watch, unref, markRaw, effectScope, ref, isVue2, isRef, isReactive, set, getCurrentScope, onScopeDispose, getCurrentInstance, reactive, toRef, del, nextTick, computed, toRefs } from 'vue-demi';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\n/**\n * setActivePinia must be called to handle SSR at the top of functions like\n * `fetch`, `setup`, `serverPrefetch` and others\n */\nlet activePinia;\n/**\n * Sets or unsets the active pinia. Used in SSR and internally when calling\n * actions and getters\n *\n * @param pinia - Pinia instance\n */\n// @ts-expect-error: cannot constrain the type of the return\nconst setActivePinia = (pinia) => (activePinia = pinia);\n/**\n * Get the currently active pinia if there is any.\n */\nconst getActivePinia = () => (hasInjectionContext() && inject(piniaSymbol)) || activePinia;\nconst piniaSymbol = ((process.env.NODE_ENV !== 'production') ? Symbol('pinia') : /* istanbul ignore next */ Symbol());\n\nfunction isPlainObject(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\no) {\n    return (o &&\n        typeof o === 'object' &&\n        Object.prototype.toString.call(o) === '[object Object]' &&\n        typeof o.toJSON !== 'function');\n}\n// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }\n// TODO: can we change these to numbers?\n/**\n * Possible types for SubscriptionCallback\n */\nvar MutationType;\n(function (MutationType) {\n    /**\n     * Direct mutation of the state:\n     *\n     * - `store.name = 'new name'`\n     * - `store.$state.name = 'new name'`\n     * - `store.list.push('new item')`\n     */\n    MutationType[\"direct\"] = \"direct\";\n    /**\n     * Mutated the state with `$patch` and an object\n     *\n     * - `store.$patch({ name: 'newName' })`\n     */\n    MutationType[\"patchObject\"] = \"patch object\";\n    /**\n     * Mutated the state with `$patch` and a function\n     *\n     * - `store.$patch(state => state.name = 'newName')`\n     */\n    MutationType[\"patchFunction\"] = \"patch function\";\n    // maybe reset? for $state = {} and $reset\n})(MutationType || (MutationType = {}));\n\nconst IS_CLIENT = typeof window !== 'undefined';\n\n/*\n * FileSaver.js A saveAs() FileSaver implementation.\n *\n * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin\n * Morote.\n *\n * License : MIT\n */\n// The one and only way of getting global scope in all environments\n// https://stackoverflow.com/q/3277182/1008999\nconst _global = /*#__PURE__*/ (() => typeof window === 'object' && window.window === window\n    ? window\n    : typeof self === 'object' && self.self === self\n        ? self\n        : typeof global === 'object' && global.global === global\n            ? global\n            : typeof globalThis === 'object'\n                ? globalThis\n                : { HTMLElement: null })();\nfunction bom(blob, { autoBom = false } = {}) {\n    // prepend BOM for UTF-8 XML and text/* types (including HTML)\n    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n    if (autoBom &&\n        /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n        return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });\n    }\n    return blob;\n}\nfunction download(url, name, opts) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.responseType = 'blob';\n    xhr.onload = function () {\n        saveAs(xhr.response, name, opts);\n    };\n    xhr.onerror = function () {\n        console.error('could not download file');\n    };\n    xhr.send();\n}\nfunction corsEnabled(url) {\n    const xhr = new XMLHttpRequest();\n    // use sync to avoid popup blocker\n    xhr.open('HEAD', url, false);\n    try {\n        xhr.send();\n    }\n    catch (e) { }\n    return xhr.status >= 200 && xhr.status <= 299;\n}\n// `a.click()` doesn't work for all browsers (#465)\nfunction click(node) {\n    try {\n        node.dispatchEvent(new MouseEvent('click'));\n    }\n    catch (e) {\n        const evt = document.createEvent('MouseEvents');\n        evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\n        node.dispatchEvent(evt);\n    }\n}\nconst _navigator = typeof navigator === 'object' ? navigator : { userAgent: '' };\n// Detect WebView inside a native macOS app by ruling out all browsers\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\nconst isMacOSWebView = /*#__PURE__*/ (() => /Macintosh/.test(_navigator.userAgent) &&\n    /AppleWebKit/.test(_navigator.userAgent) &&\n    !/Safari/.test(_navigator.userAgent))();\nconst saveAs = !IS_CLIENT\n    ? () => { } // noop\n    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program\n        typeof HTMLAnchorElement !== 'undefined' &&\n            'download' in HTMLAnchorElement.prototype &&\n            !isMacOSWebView\n            ? downloadSaveAs\n            : // Use msSaveOrOpenBlob as a second approach\n                'msSaveOrOpenBlob' in _navigator\n                    ? msSaveAs\n                    : // Fallback to using FileReader and a popup\n                        fileSaverSaveAs;\nfunction downloadSaveAs(blob, name = 'download', opts) {\n    const a = document.createElement('a');\n    a.download = name;\n    a.rel = 'noopener'; // tabnabbing\n    // TODO: detect chrome extensions & packaged apps\n    // a.target = '_blank'\n    if (typeof blob === 'string') {\n        // Support regular links\n        a.href = blob;\n        if (a.origin !== location.origin) {\n            if (corsEnabled(a.href)) {\n                download(blob, name, opts);\n            }\n            else {\n                a.target = '_blank';\n                click(a);\n            }\n        }\n        else {\n            click(a);\n        }\n    }\n    else {\n        // Support blobs\n        a.href = URL.createObjectURL(blob);\n        setTimeout(function () {\n            URL.revokeObjectURL(a.href);\n        }, 4e4); // 40s\n        setTimeout(function () {\n            click(a);\n        }, 0);\n    }\n}\nfunction msSaveAs(blob, name = 'download', opts) {\n    if (typeof blob === 'string') {\n        if (corsEnabled(blob)) {\n            download(blob, name, opts);\n        }\n        else {\n            const a = document.createElement('a');\n            a.href = blob;\n            a.target = '_blank';\n            setTimeout(function () {\n                click(a);\n            });\n        }\n    }\n    else {\n        // @ts-ignore: works on windows\n        navigator.msSaveOrOpenBlob(bom(blob, opts), name);\n    }\n}\nfunction fileSaverSaveAs(blob, name, opts, popup) {\n    // Open a popup immediately do go around popup blocker\n    // Mostly only available on user interaction and the fileReader is async so...\n    popup = popup || open('', '_blank');\n    if (popup) {\n        popup.document.title = popup.document.body.innerText = 'downloading...';\n    }\n    if (typeof blob === 'string')\n        return download(blob, name, opts);\n    const force = blob.type === 'application/octet-stream';\n    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;\n    const isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent);\n    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) &&\n        typeof FileReader !== 'undefined') {\n        // Safari doesn't allow downloading of blob URLs\n        const reader = new FileReader();\n        reader.onloadend = function () {\n            let url = reader.result;\n            if (typeof url !== 'string') {\n                popup = null;\n                throw new Error('Wrong reader.result type');\n            }\n            url = isChromeIOS\n                ? url\n                : url.replace(/^data:[^;]*;/, 'data:attachment/file;');\n            if (popup) {\n                popup.location.href = url;\n            }\n            else {\n                location.assign(url);\n            }\n            popup = null; // reverse-tabnabbing #460\n        };\n        reader.readAsDataURL(blob);\n    }\n    else {\n        const url = URL.createObjectURL(blob);\n        if (popup)\n            popup.location.assign(url);\n        else\n            location.href = url;\n        popup = null; // reverse-tabnabbing #460\n        setTimeout(function () {\n            URL.revokeObjectURL(url);\n        }, 4e4); // 40s\n    }\n}\n\n/**\n * Shows a toast or console.log\n *\n * @param message - message to log\n * @param type - different color of the tooltip\n */\nfunction toastMessage(message, type) {\n    const piniaMessage = '🍍 ' + message;\n    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {\n        // No longer available :(\n        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);\n    }\n    else if (type === 'error') {\n        console.error(piniaMessage);\n    }\n    else if (type === 'warn') {\n        console.warn(piniaMessage);\n    }\n    else {\n        console.log(piniaMessage);\n    }\n}\nfunction isPinia(o) {\n    return '_a' in o && 'install' in o;\n}\n\n/**\n * This file contain devtools actions, they are not Pinia actions.\n */\n// ---\nfunction checkClipboardAccess() {\n    if (!('clipboard' in navigator)) {\n        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');\n        return true;\n    }\n}\nfunction checkNotFocusedError(error) {\n    if (error instanceof Error &&\n        error.message.toLowerCase().includes('document is not focused')) {\n        toastMessage('You need to activate the \"Emulate a focused page\" setting in the \"Rendering\" panel of devtools.', 'warn');\n        return true;\n    }\n    return false;\n}\nasync function actionGlobalCopyState(pinia) {\n    if (checkClipboardAccess())\n        return;\n    try {\n        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));\n        toastMessage('Global state copied to clipboard.');\n    }\n    catch (error) {\n        if (checkNotFocusedError(error))\n            return;\n        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nasync function actionGlobalPasteState(pinia) {\n    if (checkClipboardAccess())\n        return;\n    try {\n        loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));\n        toastMessage('Global state pasted from clipboard.');\n    }\n    catch (error) {\n        if (checkNotFocusedError(error))\n            return;\n        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nasync function actionGlobalSaveState(pinia) {\n    try {\n        saveAs(new Blob([JSON.stringify(pinia.state.value)], {\n            type: 'text/plain;charset=utf-8',\n        }), 'pinia-state.json');\n    }\n    catch (error) {\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nlet fileInput;\nfunction getFileOpener() {\n    if (!fileInput) {\n        fileInput = document.createElement('input');\n        fileInput.type = 'file';\n        fileInput.accept = '.json';\n    }\n    function openFile() {\n        return new Promise((resolve, reject) => {\n            fileInput.onchange = async () => {\n                const files = fileInput.files;\n                if (!files)\n                    return resolve(null);\n                const file = files.item(0);\n                if (!file)\n                    return resolve(null);\n                return resolve({ text: await file.text(), file });\n            };\n            // @ts-ignore: TODO: changed from 4.3 to 4.4\n            fileInput.oncancel = () => resolve(null);\n            fileInput.onerror = reject;\n            fileInput.click();\n        });\n    }\n    return openFile;\n}\nasync function actionGlobalOpenStateFile(pinia) {\n    try {\n        const open = getFileOpener();\n        const result = await open();\n        if (!result)\n            return;\n        const { text, file } = result;\n        loadStoresState(pinia, JSON.parse(text));\n        toastMessage(`Global state imported from \"${file.name}\".`);\n    }\n    catch (error) {\n        toastMessage(`Failed to import the state from JSON. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nfunction loadStoresState(pinia, state) {\n    for (const key in state) {\n        const storeState = pinia.state.value[key];\n        // store is already instantiated, patch it\n        if (storeState) {\n            Object.assign(storeState, state[key]);\n        }\n        else {\n            // store is not instantiated, set the initial state\n            pinia.state.value[key] = state[key];\n        }\n    }\n}\n\nfunction formatDisplay(display) {\n    return {\n        _custom: {\n            display,\n        },\n    };\n}\nconst PINIA_ROOT_LABEL = '🍍 Pinia (root)';\nconst PINIA_ROOT_ID = '_root';\nfunction formatStoreForInspectorTree(store) {\n    return isPinia(store)\n        ? {\n            id: PINIA_ROOT_ID,\n            label: PINIA_ROOT_LABEL,\n        }\n        : {\n            id: store.$id,\n            label: store.$id,\n        };\n}\nfunction formatStoreForInspectorState(store) {\n    if (isPinia(store)) {\n        const storeNames = Array.from(store._s.keys());\n        const storeMap = store._s;\n        const state = {\n            state: storeNames.map((storeId) => ({\n                editable: true,\n                key: storeId,\n                value: store.state.value[storeId],\n            })),\n            getters: storeNames\n                .filter((id) => storeMap.get(id)._getters)\n                .map((id) => {\n                const store = storeMap.get(id);\n                return {\n                    editable: false,\n                    key: id,\n                    value: store._getters.reduce((getters, key) => {\n                        getters[key] = store[key];\n                        return getters;\n                    }, {}),\n                };\n            }),\n        };\n        return state;\n    }\n    const state = {\n        state: Object.keys(store.$state).map((key) => ({\n            editable: true,\n            key,\n            value: store.$state[key],\n        })),\n    };\n    // avoid adding empty getters\n    if (store._getters && store._getters.length) {\n        state.getters = store._getters.map((getterName) => ({\n            editable: false,\n            key: getterName,\n            value: store[getterName],\n        }));\n    }\n    if (store._customProperties.size) {\n        state.customProperties = Array.from(store._customProperties).map((key) => ({\n            editable: true,\n            key,\n            value: store[key],\n        }));\n    }\n    return state;\n}\nfunction formatEventData(events) {\n    if (!events)\n        return {};\n    if (Array.isArray(events)) {\n        // TODO: handle add and delete for arrays and objects\n        return events.reduce((data, event) => {\n            data.keys.push(event.key);\n            data.operations.push(event.type);\n            data.oldValue[event.key] = event.oldValue;\n            data.newValue[event.key] = event.newValue;\n            return data;\n        }, {\n            oldValue: {},\n            keys: [],\n            operations: [],\n            newValue: {},\n        });\n    }\n    else {\n        return {\n            operation: formatDisplay(events.type),\n            key: formatDisplay(events.key),\n            oldValue: events.oldValue,\n            newValue: events.newValue,\n        };\n    }\n}\nfunction formatMutationType(type) {\n    switch (type) {\n        case MutationType.direct:\n            return 'mutation';\n        case MutationType.patchFunction:\n            return '$patch';\n        case MutationType.patchObject:\n            return '$patch';\n        default:\n            return 'unknown';\n    }\n}\n\n// timeline can be paused when directly changing the state\nlet isTimelineActive = true;\nconst componentStateTypes = [];\nconst MUTATIONS_LAYER_ID = 'pinia:mutations';\nconst INSPECTOR_ID = 'pinia';\nconst { assign: assign$1 } = Object;\n/**\n * Gets the displayed name of a store in devtools\n *\n * @param id - id of the store\n * @returns a formatted string\n */\nconst getStoreType = (id) => '🍍 ' + id;\n/**\n * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab\n * as soon as it is added to the application.\n *\n * @param app - Vue application\n * @param pinia - pinia instance\n */\nfunction registerPiniaDevtools(app, pinia) {\n    setupDevtoolsPlugin({\n        id: 'dev.esm.pinia',\n        label: 'Pinia 🍍',\n        logo: 'https://pinia.vuejs.org/logo.svg',\n        packageName: 'pinia',\n        homepage: 'https://pinia.vuejs.org',\n        componentStateTypes,\n        app,\n    }, (api) => {\n        if (typeof api.now !== 'function') {\n            toastMessage('You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');\n        }\n        api.addTimelineLayer({\n            id: MUTATIONS_LAYER_ID,\n            label: `Pinia 🍍`,\n            color: 0xe5df88,\n        });\n        api.addInspector({\n            id: INSPECTOR_ID,\n            label: 'Pinia 🍍',\n            icon: 'storage',\n            treeFilterPlaceholder: 'Search stores',\n            actions: [\n                {\n                    icon: 'content_copy',\n                    action: () => {\n                        actionGlobalCopyState(pinia);\n                    },\n                    tooltip: 'Serialize and copy the state',\n                },\n                {\n                    icon: 'content_paste',\n                    action: async () => {\n                        await actionGlobalPasteState(pinia);\n                        api.sendInspectorTree(INSPECTOR_ID);\n                        api.sendInspectorState(INSPECTOR_ID);\n                    },\n                    tooltip: 'Replace the state with the content of your clipboard',\n                },\n                {\n                    icon: 'save',\n                    action: () => {\n                        actionGlobalSaveState(pinia);\n                    },\n                    tooltip: 'Save the state as a JSON file',\n                },\n                {\n                    icon: 'folder_open',\n                    action: async () => {\n                        await actionGlobalOpenStateFile(pinia);\n                        api.sendInspectorTree(INSPECTOR_ID);\n                        api.sendInspectorState(INSPECTOR_ID);\n                    },\n                    tooltip: 'Import the state from a JSON file',\n                },\n            ],\n            nodeActions: [\n                {\n                    icon: 'restore',\n                    tooltip: 'Reset the state (with \"$reset\")',\n                    action: (nodeId) => {\n                        const store = pinia._s.get(nodeId);\n                        if (!store) {\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it wasn't found.`, 'warn');\n                        }\n                        else if (typeof store.$reset !== 'function') {\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it doesn't have a \"$reset\" method implemented.`, 'warn');\n                        }\n                        else {\n                            store.$reset();\n                            toastMessage(`Store \"${nodeId}\" reset.`);\n                        }\n                    },\n                },\n            ],\n        });\n        api.on.inspectComponent((payload, ctx) => {\n            const proxy = (payload.componentInstance &&\n                payload.componentInstance.proxy);\n            if (proxy && proxy._pStores) {\n                const piniaStores = payload.componentInstance.proxy._pStores;\n                Object.values(piniaStores).forEach((store) => {\n                    payload.instanceData.state.push({\n                        type: getStoreType(store.$id),\n                        key: 'state',\n                        editable: true,\n                        value: store._isOptionsAPI\n                            ? {\n                                _custom: {\n                                    value: toRaw(store.$state),\n                                    actions: [\n                                        {\n                                            icon: 'restore',\n                                            tooltip: 'Reset the state of this store',\n                                            action: () => store.$reset(),\n                                        },\n                                    ],\n                                },\n                            }\n                            : // NOTE: workaround to unwrap transferred refs\n                                Object.keys(store.$state).reduce((state, key) => {\n                                    state[key] = store.$state[key];\n                                    return state;\n                                }, {}),\n                    });\n                    if (store._getters && store._getters.length) {\n                        payload.instanceData.state.push({\n                            type: getStoreType(store.$id),\n                            key: 'getters',\n                            editable: false,\n                            value: store._getters.reduce((getters, key) => {\n                                try {\n                                    getters[key] = store[key];\n                                }\n                                catch (error) {\n                                    // @ts-expect-error: we just want to show it in devtools\n                                    getters[key] = error;\n                                }\n                                return getters;\n                            }, {}),\n                        });\n                    }\n                });\n            }\n        });\n        api.on.getInspectorTree((payload) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                let stores = [pinia];\n                stores = stores.concat(Array.from(pinia._s.values()));\n                payload.rootNodes = (payload.filter\n                    ? stores.filter((store) => '$id' in store\n                        ? store.$id\n                            .toLowerCase()\n                            .includes(payload.filter.toLowerCase())\n                        : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))\n                    : stores).map(formatStoreForInspectorTree);\n            }\n        });\n        // Expose pinia instance as $pinia to window\n        globalThis.$pinia = pinia;\n        api.on.getInspectorState((payload) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\n                    ? pinia\n                    : pinia._s.get(payload.nodeId);\n                if (!inspectedStore) {\n                    // this could be the selected store restored for a different project\n                    // so it's better not to say anything here\n                    return;\n                }\n                if (inspectedStore) {\n                    // Expose selected store as $store to window\n                    if (payload.nodeId !== PINIA_ROOT_ID)\n                        globalThis.$store = toRaw(inspectedStore);\n                    payload.state = formatStoreForInspectorState(inspectedStore);\n                }\n            }\n        });\n        api.on.editInspectorState((payload, ctx) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\n                    ? pinia\n                    : pinia._s.get(payload.nodeId);\n                if (!inspectedStore) {\n                    return toastMessage(`store \"${payload.nodeId}\" not found`, 'error');\n                }\n                const { path } = payload;\n                if (!isPinia(inspectedStore)) {\n                    // access only the state\n                    if (path.length !== 1 ||\n                        !inspectedStore._customProperties.has(path[0]) ||\n                        path[0] in inspectedStore.$state) {\n                        path.unshift('$state');\n                    }\n                }\n                else {\n                    // Root access, we can omit the `.value` because the devtools API does it for us\n                    path.unshift('state');\n                }\n                isTimelineActive = false;\n                payload.set(inspectedStore, path, payload.state.value);\n                isTimelineActive = true;\n            }\n        });\n        api.on.editComponentState((payload) => {\n            if (payload.type.startsWith('🍍')) {\n                const storeId = payload.type.replace(/^🍍\\s*/, '');\n                const store = pinia._s.get(storeId);\n                if (!store) {\n                    return toastMessage(`store \"${storeId}\" not found`, 'error');\n                }\n                const { path } = payload;\n                if (path[0] !== 'state') {\n                    return toastMessage(`Invalid path for store \"${storeId}\":\\n${path}\\nOnly state can be modified.`);\n                }\n                // rewrite the first entry to be able to directly set the state as\n                // well as any other path\n                path[0] = '$state';\n                isTimelineActive = false;\n                payload.set(store, path, payload.state.value);\n                isTimelineActive = true;\n            }\n        });\n    });\n}\nfunction addStoreToDevtools(app, store) {\n    if (!componentStateTypes.includes(getStoreType(store.$id))) {\n        componentStateTypes.push(getStoreType(store.$id));\n    }\n    setupDevtoolsPlugin({\n        id: 'dev.esm.pinia',\n        label: 'Pinia 🍍',\n        logo: 'https://pinia.vuejs.org/logo.svg',\n        packageName: 'pinia',\n        homepage: 'https://pinia.vuejs.org',\n        componentStateTypes,\n        app,\n        settings: {\n            logStoreChanges: {\n                label: 'Notify about new/deleted stores',\n                type: 'boolean',\n                defaultValue: true,\n            },\n            // useEmojis: {\n            //   label: 'Use emojis in messages ⚡️',\n            //   type: 'boolean',\n            //   defaultValue: true,\n            // },\n        },\n    }, (api) => {\n        // gracefully handle errors\n        const now = typeof api.now === 'function' ? api.now.bind(api) : Date.now;\n        store.$onAction(({ after, onError, name, args }) => {\n            const groupId = runningActionId++;\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: {\n                    time: now(),\n                    title: '🛫 ' + name,\n                    subtitle: 'start',\n                    data: {\n                        store: formatDisplay(store.$id),\n                        action: formatDisplay(name),\n                        args,\n                    },\n                    groupId,\n                },\n            });\n            after((result) => {\n                activeAction = undefined;\n                api.addTimelineEvent({\n                    layerId: MUTATIONS_LAYER_ID,\n                    event: {\n                        time: now(),\n                        title: '🛬 ' + name,\n                        subtitle: 'end',\n                        data: {\n                            store: formatDisplay(store.$id),\n                            action: formatDisplay(name),\n                            args,\n                            result,\n                        },\n                        groupId,\n                    },\n                });\n            });\n            onError((error) => {\n                activeAction = undefined;\n                api.addTimelineEvent({\n                    layerId: MUTATIONS_LAYER_ID,\n                    event: {\n                        time: now(),\n                        logType: 'error',\n                        title: '💥 ' + name,\n                        subtitle: 'end',\n                        data: {\n                            store: formatDisplay(store.$id),\n                            action: formatDisplay(name),\n                            args,\n                            error,\n                        },\n                        groupId,\n                    },\n                });\n            });\n        }, true);\n        store._customProperties.forEach((name) => {\n            watch(() => unref(store[name]), (newValue, oldValue) => {\n                api.notifyComponentUpdate();\n                api.sendInspectorState(INSPECTOR_ID);\n                if (isTimelineActive) {\n                    api.addTimelineEvent({\n                        layerId: MUTATIONS_LAYER_ID,\n                        event: {\n                            time: now(),\n                            title: 'Change',\n                            subtitle: name,\n                            data: {\n                                newValue,\n                                oldValue,\n                            },\n                            groupId: activeAction,\n                        },\n                    });\n                }\n            }, { deep: true });\n        });\n        store.$subscribe(({ events, type }, state) => {\n            api.notifyComponentUpdate();\n            api.sendInspectorState(INSPECTOR_ID);\n            if (!isTimelineActive)\n                return;\n            // rootStore.state[store.id] = state\n            const eventData = {\n                time: now(),\n                title: formatMutationType(type),\n                data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),\n                groupId: activeAction,\n            };\n            if (type === MutationType.patchFunction) {\n                eventData.subtitle = '⤵️';\n            }\n            else if (type === MutationType.patchObject) {\n                eventData.subtitle = '🧩';\n            }\n            else if (events && !Array.isArray(events)) {\n                eventData.subtitle = events.type;\n            }\n            if (events) {\n                eventData.data['rawEvent(s)'] = {\n                    _custom: {\n                        display: 'DebuggerEvent',\n                        type: 'object',\n                        tooltip: 'raw DebuggerEvent[]',\n                        value: events,\n                    },\n                };\n            }\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: eventData,\n            });\n        }, { detached: true, flush: 'sync' });\n        const hotUpdate = store._hotUpdate;\n        store._hotUpdate = markRaw((newStore) => {\n            hotUpdate(newStore);\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: {\n                    time: now(),\n                    title: '🔥 ' + store.$id,\n                    subtitle: 'HMR update',\n                    data: {\n                        store: formatDisplay(store.$id),\n                        info: formatDisplay(`HMR update`),\n                    },\n                },\n            });\n            // update the devtools too\n            api.notifyComponentUpdate();\n            api.sendInspectorTree(INSPECTOR_ID);\n            api.sendInspectorState(INSPECTOR_ID);\n        });\n        const { $dispose } = store;\n        store.$dispose = () => {\n            $dispose();\n            api.notifyComponentUpdate();\n            api.sendInspectorTree(INSPECTOR_ID);\n            api.sendInspectorState(INSPECTOR_ID);\n            api.getSettings().logStoreChanges &&\n                toastMessage(`Disposed \"${store.$id}\" store 🗑`);\n        };\n        // trigger an update so it can display new registered stores\n        api.notifyComponentUpdate();\n        api.sendInspectorTree(INSPECTOR_ID);\n        api.sendInspectorState(INSPECTOR_ID);\n        api.getSettings().logStoreChanges &&\n            toastMessage(`\"${store.$id}\" store installed 🆕`);\n    });\n}\nlet runningActionId = 0;\nlet activeAction;\n/**\n * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the\n * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state\n * mutation to the action.\n *\n * @param store - store to patch\n * @param actionNames - list of actionst to patch\n */\nfunction patchActionForGrouping(store, actionNames, wrapWithProxy) {\n    // original actions of the store as they are given by pinia. We are going to override them\n    const actions = actionNames.reduce((storeActions, actionName) => {\n        // use toRaw to avoid tracking #541\n        storeActions[actionName] = toRaw(store)[actionName];\n        return storeActions;\n    }, {});\n    for (const actionName in actions) {\n        store[actionName] = function () {\n            // the running action id is incremented in a before action hook\n            const _actionId = runningActionId;\n            const trackedStore = wrapWithProxy\n                ? new Proxy(store, {\n                    get(...args) {\n                        activeAction = _actionId;\n                        return Reflect.get(...args);\n                    },\n                    set(...args) {\n                        activeAction = _actionId;\n                        return Reflect.set(...args);\n                    },\n                })\n                : store;\n            // For Setup Stores we need https://github.com/tc39/proposal-async-context\n            activeAction = _actionId;\n            const retValue = actions[actionName].apply(trackedStore, arguments);\n            // this is safer as async actions in Setup Stores would associate mutations done outside of the action\n            activeAction = undefined;\n            return retValue;\n        };\n    }\n}\n/**\n * pinia.use(devtoolsPlugin)\n */\nfunction devtoolsPlugin({ app, store, options }) {\n    // HMR module\n    if (store.$id.startsWith('__hot:')) {\n        return;\n    }\n    // detect option api vs setup api\n    store._isOptionsAPI = !!options.state;\n    // Do not overwrite actions mocked by @pinia/testing (#2298)\n    if (!store._p._testing) {\n        patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);\n        // Upgrade the HMR to also update the new actions\n        const originalHotUpdate = store._hotUpdate;\n        toRaw(store)._hotUpdate = function (newStore) {\n            originalHotUpdate.apply(this, arguments);\n            patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);\n        };\n    }\n    addStoreToDevtools(app, \n    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?\n    store);\n}\n\n/**\n * Creates a Pinia instance to be used by the application\n */\nfunction createPinia() {\n    const scope = effectScope(true);\n    // NOTE: here we could check the window object for a state and directly set it\n    // if there is anything like it with Vue 3 SSR\n    const state = scope.run(() => ref({}));\n    let _p = [];\n    // plugins added before calling app.use(pinia)\n    let toBeInstalled = [];\n    const pinia = markRaw({\n        install(app) {\n            // this allows calling useStore() outside of a component setup after\n            // installing pinia's plugin\n            setActivePinia(pinia);\n            if (!isVue2) {\n                pinia._a = app;\n                app.provide(piniaSymbol, pinia);\n                app.config.globalProperties.$pinia = pinia;\n                /* istanbul ignore else */\n                if ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT) {\n                    registerPiniaDevtools(app, pinia);\n                }\n                toBeInstalled.forEach((plugin) => _p.push(plugin));\n                toBeInstalled = [];\n            }\n        },\n        use(plugin) {\n            if (!this._a && !isVue2) {\n                toBeInstalled.push(plugin);\n            }\n            else {\n                _p.push(plugin);\n            }\n            return this;\n        },\n        _p,\n        // it's actually undefined here\n        // @ts-expect-error\n        _a: null,\n        _e: scope,\n        _s: new Map(),\n        state,\n    });\n    // pinia devtools rely on dev only features so they cannot be forced unless\n    // the dev build of Vue is used. Avoid old browsers like IE11.\n    if ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT && typeof Proxy !== 'undefined') {\n        pinia.use(devtoolsPlugin);\n    }\n    return pinia;\n}\n/**\n * Dispose a Pinia instance by stopping its effectScope and removing the state, plugins and stores. This is mostly\n * useful in tests, with both a testing pinia or a regular pinia and in applications that use multiple pinia instances.\n * Once disposed, the pinia instance cannot be used anymore.\n *\n * @param pinia - pinia instance\n */\nfunction disposePinia(pinia) {\n    pinia._e.stop();\n    pinia._s.clear();\n    pinia._p.splice(0);\n    pinia.state.value = {};\n    // @ts-expect-error: non valid\n    pinia._a = null;\n}\n\n/**\n * Checks if a function is a `StoreDefinition`.\n *\n * @param fn - object to test\n * @returns true if `fn` is a StoreDefinition\n */\nconst isUseStore = (fn) => {\n    return typeof fn === 'function' && typeof fn.$id === 'string';\n};\n/**\n * Mutates in place `newState` with `oldState` to _hot update_ it. It will\n * remove any key not existing in `newState` and recursively merge plain\n * objects.\n *\n * @param newState - new state object to be patched\n * @param oldState - old state that should be used to patch newState\n * @returns - newState\n */\nfunction patchObject(newState, oldState) {\n    // no need to go through symbols because they cannot be serialized anyway\n    for (const key in oldState) {\n        const subPatch = oldState[key];\n        // skip the whole sub tree\n        if (!(key in newState)) {\n            continue;\n        }\n        const targetValue = newState[key];\n        if (isPlainObject(targetValue) &&\n            isPlainObject(subPatch) &&\n            !isRef(subPatch) &&\n            !isReactive(subPatch)) {\n            newState[key] = patchObject(targetValue, subPatch);\n        }\n        else {\n            // objects are either a bit more complex (e.g. refs) or primitives, so we\n            // just set the whole thing\n            if (isVue2) {\n                set(newState, key, subPatch);\n            }\n            else {\n                newState[key] = subPatch;\n            }\n        }\n    }\n    return newState;\n}\n/**\n * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.\n *\n * @example\n * ```js\n * const useUser = defineStore(...)\n * if (import.meta.hot) {\n *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))\n * }\n * ```\n *\n * @param initialUseStore - return of the defineStore to hot update\n * @param hot - `import.meta.hot`\n */\nfunction acceptHMRUpdate(initialUseStore, hot) {\n    // strip as much as possible from iife.prod\n    if (!(process.env.NODE_ENV !== 'production')) {\n        return () => { };\n    }\n    return (newModule) => {\n        const pinia = hot.data.pinia || initialUseStore._pinia;\n        if (!pinia) {\n            // this store is still not used\n            return;\n        }\n        // preserve the pinia instance across loads\n        hot.data.pinia = pinia;\n        // console.log('got data', newStore)\n        for (const exportName in newModule) {\n            const useStore = newModule[exportName];\n            // console.log('checking for', exportName)\n            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {\n                // console.log('Accepting update for', useStore.$id)\n                const id = useStore.$id;\n                if (id !== initialUseStore.$id) {\n                    console.warn(`The id of the store changed from \"${initialUseStore.$id}\" to \"${id}\". Reloading.`);\n                    // return import.meta.hot.invalidate()\n                    return hot.invalidate();\n                }\n                const existingStore = pinia._s.get(id);\n                if (!existingStore) {\n                    console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);\n                    return;\n                }\n                useStore(pinia, existingStore);\n            }\n        }\n    };\n}\n\nconst noop = () => { };\nfunction addSubscription(subscriptions, callback, detached, onCleanup = noop) {\n    subscriptions.push(callback);\n    const removeSubscription = () => {\n        const idx = subscriptions.indexOf(callback);\n        if (idx > -1) {\n            subscriptions.splice(idx, 1);\n            onCleanup();\n        }\n    };\n    if (!detached && getCurrentScope()) {\n        onScopeDispose(removeSubscription);\n    }\n    return removeSubscription;\n}\nfunction triggerSubscriptions(subscriptions, ...args) {\n    subscriptions.slice().forEach((callback) => {\n        callback(...args);\n    });\n}\n\nconst fallbackRunWithContext = (fn) => fn();\n/**\n * Marks a function as an action for `$onAction`\n * @internal\n */\nconst ACTION_MARKER = Symbol();\n/**\n * Action name symbol. Allows to add a name to an action after defining it\n * @internal\n */\nconst ACTION_NAME = Symbol();\nfunction mergeReactiveObjects(target, patchToApply) {\n    // Handle Map instances\n    if (target instanceof Map && patchToApply instanceof Map) {\n        patchToApply.forEach((value, key) => target.set(key, value));\n    }\n    else if (target instanceof Set && patchToApply instanceof Set) {\n        // Handle Set instances\n        patchToApply.forEach(target.add, target);\n    }\n    // no need to go through symbols because they cannot be serialized anyway\n    for (const key in patchToApply) {\n        if (!patchToApply.hasOwnProperty(key))\n            continue;\n        const subPatch = patchToApply[key];\n        const targetValue = target[key];\n        if (isPlainObject(targetValue) &&\n            isPlainObject(subPatch) &&\n            target.hasOwnProperty(key) &&\n            !isRef(subPatch) &&\n            !isReactive(subPatch)) {\n            // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might\n            // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that\n            // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.\n            target[key] = mergeReactiveObjects(targetValue, subPatch);\n        }\n        else {\n            // @ts-expect-error: subPatch is a valid value\n            target[key] = subPatch;\n        }\n    }\n    return target;\n}\nconst skipHydrateSymbol = (process.env.NODE_ENV !== 'production')\n    ? Symbol('pinia:skipHydration')\n    : /* istanbul ignore next */ Symbol();\nconst skipHydrateMap = /*#__PURE__*/ new WeakMap();\n/**\n * Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a\n * stateful object in the store but it isn't really state. e.g. returning a router instance in a setup store.\n *\n * @param obj - target object\n * @returns obj\n */\nfunction skipHydrate(obj) {\n    return isVue2\n        ? // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...\n            /* istanbul ignore next */ skipHydrateMap.set(obj, 1) && obj\n        : Object.defineProperty(obj, skipHydrateSymbol, {});\n}\n/**\n * Returns whether a value should be hydrated\n *\n * @param obj - target variable\n * @returns true if `obj` should be hydrated\n */\nfunction shouldHydrate(obj) {\n    return isVue2\n        ? /* istanbul ignore next */ !skipHydrateMap.has(obj)\n        : !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);\n}\nconst { assign } = Object;\nfunction isComputed(o) {\n    return !!(isRef(o) && o.effect);\n}\nfunction createOptionsStore(id, options, pinia, hot) {\n    const { state, actions, getters } = options;\n    const initialState = pinia.state.value[id];\n    let store;\n    function setup() {\n        if (!initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\n            /* istanbul ignore if */\n            if (isVue2) {\n                set(pinia.state.value, id, state ? state() : {});\n            }\n            else {\n                pinia.state.value[id] = state ? state() : {};\n            }\n        }\n        // avoid creating a state in pinia.state.value\n        const localState = (process.env.NODE_ENV !== 'production') && hot\n            ? // use ref() to unwrap refs inside state TODO: check if this is still necessary\n                toRefs(ref(state ? state() : {}).value)\n            : toRefs(pinia.state.value[id]);\n        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {\n            if ((process.env.NODE_ENV !== 'production') && name in localState) {\n                console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with \"${name}\" in store \"${id}\".`);\n            }\n            computedGetters[name] = markRaw(computed(() => {\n                setActivePinia(pinia);\n                // it was created just before\n                const store = pinia._s.get(id);\n                // allow cross using stores\n                /* istanbul ignore if */\n                if (isVue2 && !store._r)\n                    return;\n                // @ts-expect-error\n                // return getters![name].call(context, context)\n                // TODO: avoid reading the getter while assigning with a global variable\n                return getters[name].call(store, store);\n            }));\n            return computedGetters;\n        }, {}));\n    }\n    store = createSetupStore(id, setup, options, pinia, hot, true);\n    return store;\n}\nfunction createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {\n    let scope;\n    const optionsForPlugin = assign({ actions: {} }, options);\n    /* istanbul ignore if */\n    if ((process.env.NODE_ENV !== 'production') && !pinia._e.active) {\n        throw new Error('Pinia destroyed');\n    }\n    // watcher options for $subscribe\n    const $subscribeOptions = { deep: true };\n    /* istanbul ignore else */\n    if ((process.env.NODE_ENV !== 'production') && !isVue2) {\n        $subscribeOptions.onTrigger = (event) => {\n            /* istanbul ignore else */\n            if (isListening) {\n                debuggerEvents = event;\n                // avoid triggering this while the store is being built and the state is being set in pinia\n            }\n            else if (isListening == false && !store._hotUpdating) {\n                // let patch send all the events together later\n                /* istanbul ignore else */\n                if (Array.isArray(debuggerEvents)) {\n                    debuggerEvents.push(event);\n                }\n                else {\n                    console.error('🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.');\n                }\n            }\n        };\n    }\n    // internal state\n    let isListening; // set to true at the end\n    let isSyncListening; // set to true at the end\n    let subscriptions = [];\n    let actionSubscriptions = [];\n    let debuggerEvents;\n    const initialState = pinia.state.value[$id];\n    // avoid setting the state for option stores if it is set\n    // by the setup\n    if (!isOptionsStore && !initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\n        /* istanbul ignore if */\n        if (isVue2) {\n            set(pinia.state.value, $id, {});\n        }\n        else {\n            pinia.state.value[$id] = {};\n        }\n    }\n    const hotState = ref({});\n    // avoid triggering too many listeners\n    // https://github.com/vuejs/pinia/issues/1129\n    let activeListener;\n    function $patch(partialStateOrMutator) {\n        let subscriptionMutation;\n        isListening = isSyncListening = false;\n        // reset the debugger events since patches are sync\n        /* istanbul ignore else */\n        if ((process.env.NODE_ENV !== 'production')) {\n            debuggerEvents = [];\n        }\n        if (typeof partialStateOrMutator === 'function') {\n            partialStateOrMutator(pinia.state.value[$id]);\n            subscriptionMutation = {\n                type: MutationType.patchFunction,\n                storeId: $id,\n                events: debuggerEvents,\n            };\n        }\n        else {\n            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);\n            subscriptionMutation = {\n                type: MutationType.patchObject,\n                payload: partialStateOrMutator,\n                storeId: $id,\n                events: debuggerEvents,\n            };\n        }\n        const myListenerId = (activeListener = Symbol());\n        nextTick().then(() => {\n            if (activeListener === myListenerId) {\n                isListening = true;\n            }\n        });\n        isSyncListening = true;\n        // because we paused the watcher, we need to manually call the subscriptions\n        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);\n    }\n    const $reset = isOptionsStore\n        ? function $reset() {\n            const { state } = options;\n            const newState = state ? state() : {};\n            // we use a patch to group all changes into one single subscription\n            this.$patch(($state) => {\n                // @ts-expect-error: FIXME: shouldn't error?\n                assign($state, newState);\n            });\n        }\n        : /* istanbul ignore next */\n            (process.env.NODE_ENV !== 'production')\n                ? () => {\n                    throw new Error(`🍍: Store \"${$id}\" is built using the setup syntax and does not implement $reset().`);\n                }\n                : noop;\n    function $dispose() {\n        scope.stop();\n        subscriptions = [];\n        actionSubscriptions = [];\n        pinia._s.delete($id);\n    }\n    /**\n     * Helper that wraps function so it can be tracked with $onAction\n     * @param fn - action to wrap\n     * @param name - name of the action\n     */\n    const action = (fn, name = '') => {\n        if (ACTION_MARKER in fn) {\n            fn[ACTION_NAME] = name;\n            return fn;\n        }\n        const wrappedAction = function () {\n            setActivePinia(pinia);\n            const args = Array.from(arguments);\n            const afterCallbackList = [];\n            const onErrorCallbackList = [];\n            function after(callback) {\n                afterCallbackList.push(callback);\n            }\n            function onError(callback) {\n                onErrorCallbackList.push(callback);\n            }\n            // @ts-expect-error\n            triggerSubscriptions(actionSubscriptions, {\n                args,\n                name: wrappedAction[ACTION_NAME],\n                store,\n                after,\n                onError,\n            });\n            let ret;\n            try {\n                ret = fn.apply(this && this.$id === $id ? this : store, args);\n                // handle sync errors\n            }\n            catch (error) {\n                triggerSubscriptions(onErrorCallbackList, error);\n                throw error;\n            }\n            if (ret instanceof Promise) {\n                return ret\n                    .then((value) => {\n                    triggerSubscriptions(afterCallbackList, value);\n                    return value;\n                })\n                    .catch((error) => {\n                    triggerSubscriptions(onErrorCallbackList, error);\n                    return Promise.reject(error);\n                });\n            }\n            // trigger after callbacks\n            triggerSubscriptions(afterCallbackList, ret);\n            return ret;\n        };\n        wrappedAction[ACTION_MARKER] = true;\n        wrappedAction[ACTION_NAME] = name; // will be set later\n        // @ts-expect-error: we are intentionally limiting the returned type to just Fn\n        // because all the added properties are internals that are exposed through `$onAction()` only\n        return wrappedAction;\n    };\n    const _hmrPayload = /*#__PURE__*/ markRaw({\n        actions: {},\n        getters: {},\n        state: [],\n        hotState,\n    });\n    const partialStore = {\n        _p: pinia,\n        // _s: scope,\n        $id,\n        $onAction: addSubscription.bind(null, actionSubscriptions),\n        $patch,\n        $reset,\n        $subscribe(callback, options = {}) {\n            const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());\n            const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {\n                if (options.flush === 'sync' ? isSyncListening : isListening) {\n                    callback({\n                        storeId: $id,\n                        type: MutationType.direct,\n                        events: debuggerEvents,\n                    }, state);\n                }\n            }, assign({}, $subscribeOptions, options)));\n            return removeSubscription;\n        },\n        $dispose,\n    };\n    /* istanbul ignore if */\n    if (isVue2) {\n        // start as non ready\n        partialStore._r = false;\n    }\n    const store = reactive((process.env.NODE_ENV !== 'production') || ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT)\n        ? assign({\n            _hmrPayload,\n            _customProperties: markRaw(new Set()), // devtools custom properties\n        }, partialStore\n        // must be added later\n        // setupStore\n        )\n        : partialStore);\n    // store the partial store now so the setup of stores can instantiate each other before they are finished without\n    // creating infinite loops.\n    pinia._s.set($id, store);\n    const runWithContext = (pinia._a && pinia._a.runWithContext) || fallbackRunWithContext;\n    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped\n    const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup({ action }))));\n    // overwrite existing actions to support $onAction\n    for (const key in setupStore) {\n        const prop = setupStore[key];\n        if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {\n            // mark it as a piece of state to be serialized\n            if ((process.env.NODE_ENV !== 'production') && hot) {\n                set(hotState.value, key, toRef(setupStore, key));\n                // createOptionStore directly sets the state in pinia.state.value so we\n                // can just skip that\n            }\n            else if (!isOptionsStore) {\n                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created\n                if (initialState && shouldHydrate(prop)) {\n                    if (isRef(prop)) {\n                        prop.value = initialState[key];\n                    }\n                    else {\n                        // probably a reactive object, lets recursively assign\n                        // @ts-expect-error: prop is unknown\n                        mergeReactiveObjects(prop, initialState[key]);\n                    }\n                }\n                // transfer the ref to the pinia state to keep everything in sync\n                /* istanbul ignore if */\n                if (isVue2) {\n                    set(pinia.state.value[$id], key, prop);\n                }\n                else {\n                    pinia.state.value[$id][key] = prop;\n                }\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                _hmrPayload.state.push(key);\n            }\n            // action\n        }\n        else if (typeof prop === 'function') {\n            const actionValue = (process.env.NODE_ENV !== 'production') && hot ? prop : action(prop, key);\n            // this a hot module replacement store because the hotUpdate method needs\n            // to do it with the right context\n            /* istanbul ignore if */\n            if (isVue2) {\n                set(setupStore, key, actionValue);\n            }\n            else {\n                // @ts-expect-error\n                setupStore[key] = actionValue;\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                _hmrPayload.actions[key] = prop;\n            }\n            // list actions so they can be used in plugins\n            // @ts-expect-error\n            optionsForPlugin.actions[key] = prop;\n        }\n        else if ((process.env.NODE_ENV !== 'production')) {\n            // add getters for devtools\n            if (isComputed(prop)) {\n                _hmrPayload.getters[key] = isOptionsStore\n                    ? // @ts-expect-error\n                        options.getters[key]\n                    : prop;\n                if (IS_CLIENT) {\n                    const getters = setupStore._getters ||\n                        // @ts-expect-error: same\n                        (setupStore._getters = markRaw([]));\n                    getters.push(key);\n                }\n            }\n        }\n    }\n    // add the state, getters, and action properties\n    /* istanbul ignore if */\n    if (isVue2) {\n        Object.keys(setupStore).forEach((key) => {\n            set(store, key, setupStore[key]);\n        });\n    }\n    else {\n        assign(store, setupStore);\n        // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.\n        // Make `storeToRefs()` work with `reactive()` #799\n        assign(toRaw(store), setupStore);\n    }\n    // use this instead of a computed with setter to be able to create it anywhere\n    // without linking the computed lifespan to wherever the store is first\n    // created.\n    Object.defineProperty(store, '$state', {\n        get: () => ((process.env.NODE_ENV !== 'production') && hot ? hotState.value : pinia.state.value[$id]),\n        set: (state) => {\n            /* istanbul ignore if */\n            if ((process.env.NODE_ENV !== 'production') && hot) {\n                throw new Error('cannot set hotState');\n            }\n            $patch(($state) => {\n                // @ts-expect-error: FIXME: shouldn't error?\n                assign($state, state);\n            });\n        },\n    });\n    // add the hotUpdate before plugins to allow them to override it\n    /* istanbul ignore else */\n    if ((process.env.NODE_ENV !== 'production')) {\n        store._hotUpdate = markRaw((newStore) => {\n            store._hotUpdating = true;\n            newStore._hmrPayload.state.forEach((stateKey) => {\n                if (stateKey in store.$state) {\n                    const newStateTarget = newStore.$state[stateKey];\n                    const oldStateSource = store.$state[stateKey];\n                    if (typeof newStateTarget === 'object' &&\n                        isPlainObject(newStateTarget) &&\n                        isPlainObject(oldStateSource)) {\n                        patchObject(newStateTarget, oldStateSource);\n                    }\n                    else {\n                        // transfer the ref\n                        newStore.$state[stateKey] = oldStateSource;\n                    }\n                }\n                // patch direct access properties to allow store.stateProperty to work as\n                // store.$state.stateProperty\n                set(store, stateKey, toRef(newStore.$state, stateKey));\n            });\n            // remove deleted state properties\n            Object.keys(store.$state).forEach((stateKey) => {\n                if (!(stateKey in newStore.$state)) {\n                    del(store, stateKey);\n                }\n            });\n            // avoid devtools logging this as a mutation\n            isListening = false;\n            isSyncListening = false;\n            pinia.state.value[$id] = toRef(newStore._hmrPayload, 'hotState');\n            isSyncListening = true;\n            nextTick().then(() => {\n                isListening = true;\n            });\n            for (const actionName in newStore._hmrPayload.actions) {\n                const actionFn = newStore[actionName];\n                set(store, actionName, action(actionFn, actionName));\n            }\n            // TODO: does this work in both setup and option store?\n            for (const getterName in newStore._hmrPayload.getters) {\n                const getter = newStore._hmrPayload.getters[getterName];\n                const getterValue = isOptionsStore\n                    ? // special handling of options api\n                        computed(() => {\n                            setActivePinia(pinia);\n                            return getter.call(store, store);\n                        })\n                    : getter;\n                set(store, getterName, getterValue);\n            }\n            // remove deleted getters\n            Object.keys(store._hmrPayload.getters).forEach((key) => {\n                if (!(key in newStore._hmrPayload.getters)) {\n                    del(store, key);\n                }\n            });\n            // remove old actions\n            Object.keys(store._hmrPayload.actions).forEach((key) => {\n                if (!(key in newStore._hmrPayload.actions)) {\n                    del(store, key);\n                }\n            });\n            // update the values used in devtools and to allow deleting new properties later on\n            store._hmrPayload = newStore._hmrPayload;\n            store._getters = newStore._getters;\n            store._hotUpdating = false;\n        });\n    }\n    if ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT) {\n        const nonEnumerable = {\n            writable: true,\n            configurable: true,\n            // avoid warning on devtools trying to display this property\n            enumerable: false,\n        };\n        ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach((p) => {\n            Object.defineProperty(store, p, assign({ value: store[p] }, nonEnumerable));\n        });\n    }\n    /* istanbul ignore if */\n    if (isVue2) {\n        // mark the store as ready before plugins\n        store._r = true;\n    }\n    // apply all plugins\n    pinia._p.forEach((extender) => {\n        /* istanbul ignore else */\n        if ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT) {\n            const extensions = scope.run(() => extender({\n                store: store,\n                app: pinia._a,\n                pinia,\n                options: optionsForPlugin,\n            }));\n            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));\n            assign(store, extensions);\n        }\n        else {\n            assign(store, scope.run(() => extender({\n                store: store,\n                app: pinia._a,\n                pinia,\n                options: optionsForPlugin,\n            })));\n        }\n    });\n    if ((process.env.NODE_ENV !== 'production') &&\n        store.$state &&\n        typeof store.$state === 'object' &&\n        typeof store.$state.constructor === 'function' &&\n        !store.$state.constructor.toString().includes('[native code]')) {\n        console.warn(`[🍍]: The \"state\" must be a plain object. It cannot be\\n` +\n            `\\tstate: () => new MyClass()\\n` +\n            `Found in store \"${store.$id}\".`);\n    }\n    // only apply hydrate to option stores with an initial state in pinia\n    if (initialState &&\n        isOptionsStore &&\n        options.hydrate) {\n        options.hydrate(store.$state, initialState);\n    }\n    isListening = true;\n    isSyncListening = true;\n    return store;\n}\n// allows unused stores to be tree shaken\n/*! #__NO_SIDE_EFFECTS__ */\nfunction defineStore(\n// TODO: add proper types from above\nidOrOptions, setup, setupOptions) {\n    let id;\n    let options;\n    const isSetupStore = typeof setup === 'function';\n    if (typeof idOrOptions === 'string') {\n        id = idOrOptions;\n        // the option store setup will contain the actual options in this case\n        options = isSetupStore ? setupOptions : setup;\n    }\n    else {\n        options = idOrOptions;\n        id = idOrOptions.id;\n        if ((process.env.NODE_ENV !== 'production') && typeof id !== 'string') {\n            throw new Error(`[🍍]: \"defineStore()\" must be passed a store id as its first argument.`);\n        }\n    }\n    function useStore(pinia, hot) {\n        const hasContext = hasInjectionContext();\n        pinia =\n            // in test mode, ignore the argument provided as we can always retrieve a\n            // pinia instance with getActivePinia()\n            ((process.env.NODE_ENV === 'test') && activePinia && activePinia._testing ? null : pinia) ||\n                (hasContext ? inject(piniaSymbol, null) : null);\n        if (pinia)\n            setActivePinia(pinia);\n        if ((process.env.NODE_ENV !== 'production') && !activePinia) {\n            throw new Error(`[🍍]: \"getActivePinia()\" was called but there was no active Pinia. Are you trying to use a store before calling \"app.use(pinia)\"?\\n` +\n                `See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.\\n` +\n                `This will fail in production.`);\n        }\n        pinia = activePinia;\n        if (!pinia._s.has(id)) {\n            // creating the store registers it in `pinia._s`\n            if (isSetupStore) {\n                createSetupStore(id, setup, options, pinia);\n            }\n            else {\n                createOptionsStore(id, options, pinia);\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                // @ts-expect-error: not the right inferred type\n                useStore._pinia = pinia;\n            }\n        }\n        const store = pinia._s.get(id);\n        if ((process.env.NODE_ENV !== 'production') && hot) {\n            const hotId = '__hot:' + id;\n            const newStore = isSetupStore\n                ? createSetupStore(hotId, setup, options, pinia, true)\n                : createOptionsStore(hotId, assign({}, options), pinia, true);\n            hot._hotUpdate(newStore);\n            // cleanup the state properties and the store from the cache\n            delete pinia.state.value[hotId];\n            pinia._s.delete(hotId);\n        }\n        if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {\n            const currentInstance = getCurrentInstance();\n            // save stores in instances to access them devtools\n            if (currentInstance &&\n                currentInstance.proxy &&\n                // avoid adding stores that are just built for hot module replacement\n                !hot) {\n                const vm = currentInstance.proxy;\n                const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});\n                cache[id] = store;\n            }\n        }\n        // StoreGeneric cannot be casted towards Store\n        return store;\n    }\n    useStore.$id = id;\n    return useStore;\n}\n\nlet mapStoreSuffix = 'Store';\n/**\n * Changes the suffix added by `mapStores()`. Can be set to an empty string.\n * Defaults to `\"Store\"`. Make sure to extend the MapStoresCustomization\n * interface if you are using TypeScript.\n *\n * @param suffix - new suffix\n */\nfunction setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS\n) {\n    mapStoreSuffix = suffix;\n}\n/**\n * Allows using stores without the composition API (`setup()`) by generating an\n * object to be spread in the `computed` field of a component. It accepts a list\n * of store definitions.\n *\n * @example\n * ```js\n * export default {\n *   computed: {\n *     // other computed properties\n *     ...mapStores(useUserStore, useCartStore)\n *   },\n *\n *   created() {\n *     this.userStore // store with id \"user\"\n *     this.cartStore // store with id \"cart\"\n *   }\n * }\n * ```\n *\n * @param stores - list of stores to map to an object\n */\nfunction mapStores(...stores) {\n    if ((process.env.NODE_ENV !== 'production') && Array.isArray(stores[0])) {\n        console.warn(`[🍍]: Directly pass all stores to \"mapStores()\" without putting them in an array:\\n` +\n            `Replace\\n` +\n            `\\tmapStores([useAuthStore, useCartStore])\\n` +\n            `with\\n` +\n            `\\tmapStores(useAuthStore, useCartStore)\\n` +\n            `This will fail in production if not fixed.`);\n        stores = stores[0];\n    }\n    return stores.reduce((reduced, useStore) => {\n        // @ts-expect-error: $id is added by defineStore\n        reduced[useStore.$id + mapStoreSuffix] = function () {\n            return useStore(this.$pinia);\n        };\n        return reduced;\n    }, {});\n}\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapState(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            reduced[key] = function () {\n                // @ts-expect-error: FIXME: should work?\n                return useStore(this.$pinia)[key];\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function () {\n                const store = useStore(this.$pinia);\n                const storeKey = keysOrMapper[key];\n                // for some reason TS is unable to infer the type of storeKey to be a\n                // function\n                return typeof storeKey === 'function'\n                    ? storeKey.call(this, store)\n                    : // @ts-expect-error: FIXME: should work?\n                        store[storeKey];\n            };\n            return reduced;\n        }, {});\n}\n/**\n * Alias for `mapState()`. You should use `mapState()` instead.\n * @deprecated use `mapState()` instead.\n */\nconst mapGetters = mapState;\n/**\n * Allows directly using actions from your store without using the composition\n * API (`setup()`) by generating an object to be spread in the `methods` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapActions(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function (...args) {\n                // @ts-expect-error: FIXME: should work?\n                return useStore(this.$pinia)[key](...args);\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function (...args) {\n                // @ts-expect-error: FIXME: should work?\n                return useStore(this.$pinia)[keysOrMapper[key]](...args);\n            };\n            return reduced;\n        }, {});\n}\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapWritableState(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            // @ts-ignore\n            reduced[key] = {\n                get() {\n                    // @ts-expect-error: FIXME: should work?\n                    return useStore(this.$pinia)[key];\n                },\n                set(value) {\n                    // @ts-expect-error: FIXME: should work?\n                    return (useStore(this.$pinia)[key] = value);\n                },\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-ignore\n            reduced[key] = {\n                get() {\n                    // @ts-expect-error: FIXME: should work?\n                    return useStore(this.$pinia)[keysOrMapper[key]];\n                },\n                set(value) {\n                    // @ts-expect-error: FIXME: should work?\n                    return (useStore(this.$pinia)[keysOrMapper[key]] = value);\n                },\n            };\n            return reduced;\n        }, {});\n}\n\n/**\n * Creates an object of references with all the state, getters, and plugin-added\n * state properties of the store. Similar to `toRefs()` but specifically\n * designed for Pinia stores so methods and non reactive properties are\n * completely ignored.\n *\n * @param store - store to extract the refs from\n */\nfunction storeToRefs(store) {\n    // See https://github.com/vuejs/pinia/issues/852\n    // It's easier to just use toRefs() even if it includes more stuff\n    if (isVue2) {\n        // @ts-expect-error: toRefs include methods and others\n        return toRefs(store);\n    }\n    else {\n        const rawStore = toRaw(store);\n        const refs = {};\n        for (const key in rawStore) {\n            const value = rawStore[key];\n            // There is no native method to check for a computed\n            // https://github.com/vuejs/core/pull/4165\n            if (value.effect) {\n                // @ts-expect-error: too hard to type correctly\n                refs[key] =\n                    // ...\n                    computed({\n                        get: () => store[key],\n                        set(value) {\n                            store[key] = value;\n                        },\n                    });\n            }\n            else if (isRef(value) || isReactive(value)) {\n                // @ts-expect-error: the key is state or getter\n                refs[key] =\n                    // ---\n                    toRef(store, key);\n            }\n        }\n        return refs;\n    }\n}\n\n/**\n * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need\n * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:\n * https://pinia.vuejs.org/ssr/nuxt.html.\n *\n * @example\n * ```js\n * import Vue from 'vue'\n * import { PiniaVuePlugin, createPinia } from 'pinia'\n *\n * Vue.use(PiniaVuePlugin)\n * const pinia = createPinia()\n *\n * new Vue({\n *   el: '#app',\n *   // ...\n *   pinia,\n * })\n * ```\n *\n * @param _Vue - `Vue` imported from 'vue'.\n */\nconst PiniaVuePlugin = function (_Vue) {\n    // Equivalent of\n    // app.config.globalProperties.$pinia = pinia\n    _Vue.mixin({\n        beforeCreate() {\n            const options = this.$options;\n            if (options.pinia) {\n                const pinia = options.pinia;\n                // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/main/src/apis/inject.ts#L31\n                /* istanbul ignore else */\n                if (!this._provided) {\n                    const provideCache = {};\n                    Object.defineProperty(this, '_provided', {\n                        get: () => provideCache,\n                        set: (v) => Object.assign(provideCache, v),\n                    });\n                }\n                this._provided[piniaSymbol] = pinia;\n                // propagate the pinia instance in an SSR friendly way\n                // avoid adding it to nuxt twice\n                /* istanbul ignore else */\n                if (!this.$pinia) {\n                    this.$pinia = pinia;\n                }\n                pinia._a = this;\n                if (IS_CLIENT) {\n                    // this allows calling useStore() outside of a component setup after\n                    // installing pinia's plugin\n                    setActivePinia(pinia);\n                }\n                if ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT) {\n                    registerPiniaDevtools(pinia._a, pinia);\n                }\n            }\n            else if (!this.$pinia && options.parent && options.parent.$pinia) {\n                this.$pinia = options.parent.$pinia;\n            }\n        },\n        destroyed() {\n            delete this._pStores;\n        },\n    });\n};\n\nexport { MutationType, PiniaVuePlugin, acceptHMRUpdate, createPinia, defineStore, disposePinia, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, shouldHydrate, skipHydrate, storeToRefs };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \"-\" + chunkId + \".js?v=\" + {\"1241\":\"a4187792299da984916c\",\"1957\":\"96a4d042dd15d21b005b\",\"2913\":\"1ccb2adaaea884424d3c\",\"4473\":\"6009e669b1a0737a2378\",\"5528\":\"231caad2efb966b857ef\",\"7462\":\"98761c488f4b8f24f170\"}[chunkId] + \"\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.j = 2122;","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t2122: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunknextcloud\"] = self[\"webpackChunknextcloud\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","__webpack_require__.nc = undefined;","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [4208], () => (__webpack_require__(24167)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","inProgress","dataWebpackPrefix","assertValidPattern","pattern","TypeError","length","posixClasses","braceEscape","s","replace","rangesToString","ranges","join","parseClass","glob","position","pos","charAt","Error","negs","i","sawStart","uflag","escaping","negate","endPos","rangeStart","WHILE","c","cls","unip","u","neg","Object","entries","startsWith","push","test","slice","sranges","snegs","windowsPathsNoEscape","types","Set","isExtglobType","has","startNoDot","addPatternStart","justDots","reSpecials","qmark","star","starNoEmpty","AST","type","constructor","parent","options","this","hasMagic","undefined","p","toString","map","String","n","pop","pp","part","copyIn","parts","toJSON","ret","isStart","unshift","isEnd","pl","clone","str","ast","opt","inBrace","braceStart","braceNeg","acc","noext","ext","substring","fromGlob","toMMPattern","re","body","toRegExpSource","nocase","nocaseMagicOnly","toUpperCase","toLowerCase","flags","assign","RegExp","_src","_glob","allowDot","dot","noEmpty","src","_","start","aps","needNoTrav","needNoDot","end","repeated","bodyDotAllowed","final","_hasMagic","filter","needUflag","consumed","magic","nocomment","Minimatch","match","starDotExtRE","starDotExtTest","f","endsWith","starDotExtTestDot","starDotExtTestNocase","starDotExtTestNocaseDot","starDotStarRE","starDotStarTest","includes","starDotStarTestDot","dotStarRE","dotStarTest","starRE","starTest","starTestDot","qmarksRE","qmarksTestNocase","$0","qmarksTestNoExt","qmarksTestNocaseDot","qmarksTestNoExtDot","qmarksTestDot","qmarksTest","len","defaultPlatform","process","env","__MINIMATCH_TESTING_PLATFORM__","platform","sep","GLOBSTAR","Symbol","a","b","defaults","def","keys","orig","super","unescape","escape","makeRe","braceExpand","list","nobrace","mm","nonull","globMagic","set","nonegate","comment","empty","preserveMultipleSlashes","partial","globSet","globParts","isWindows","windowsNoMagicRoot","regexp","allowWindowsEscape","make","magicalBraces","debug","parseNegate","args","console","error","rawGlobParts","slashSplit","preprocess","__","isUNC","isDrive","ss","parse","indexOf","noglobstar","j","optimizationLevel","firstPhasePreProcess","secondPhasePreProcess","levelOneOptimize","adjascentGlobstarOptimize","gs","splice","reduce","prev","levelTwoFileOptimize","Array","isArray","didSomething","dd","gss","next","p2","other","splin","matched","partsMatch","emptyGSMatch","ai","bi","result","which","negateOffset","matchOne","file","fileDrive","fileUNC","patternDrive","fdi","pdi","fd","pd","fi","pi","fl","fr","pr","swallowee","hit","m","fastTest","Reflect","defineProperty","value","twoStar","split","add","forEach","open","close","ex","ff","filename","matchBase","flipNegate","convertResponseHeaders","headers","output","key","get","PropertyType","getDirectoryFiles","isDetailed","arguments","multistatus","response","responseItems","item","props","propstat","prop","getlastmodified","lastMod","getcontentlength","rawSize","resourcetype","resourceType","getcontenttype","mimeType","getetag","etag","collection","stat","basename","lastmod","size","parseInt","mime","displayname","prepareFileFromProps","id","ActivityTabPluginView","ActivityTabPluginInstance","Vue","use","PiniaVuePlugin","__webpack_nonce__","btoa","getRequestToken","loadState","_OCA","OCA","Activity","registerSidebarAction","window","addEventListener","mount","async","el","_ref","context","fileInfo","reload","pinia","createPinia","default","ActivityCommentAction","extend","propsData","reloadCallback","resourceId","logger","info","unmount","$destroy","registerSidebarEntries","limit","offset","_ref2","data","comments","_options$limit","resourcePath","datetime","concat","toISOString","client","customRequest","method","responseData","text","parseXML","status","statusText","processResponsePayload","getComments","CommentView","CommentsViewObject","_comment$props","_CommentsViewInstance","timestamp","moment","creationDateTime","toDate","getTime","element","_ref3","_this$_CommentsViewIn","registerSidebarFilter","activity","TabInstance","commentTab","Files","Sidebar","Tab","name","t","iconSvg","Comments","View","update","$mount","destroy","scrollBottomReached","onScrollBottomReached","registerTab","getLoggerBuilder","setApp","detectUser","build","createClient","getRootPath","setHeaders","token","requesttoken","onRequestTokenUpdate","generateRemoteUrl","balanced","maybeMatch","r","range","pre","post","reg","begs","beg","left","right","module","exports","substr","expand","escSlash","escOpen","escClose","escComma","escPeriod","escapeBraces","unescapeBraces","Math","random","numeric","charCodeAt","parseCommaParts","postParts","shift","apply","embrace","isPadded","lte","y","gte","isTop","expansions","k","expansion","N","isNumericSequence","isAlphaSequence","isSequence","isOptions","x","width","max","incr","abs","pad","some","fromCharCode","need","z","validator","XMLParser","XMLBuilder","XMLValidator","_typeof","obj","iterator","prototype","_wrapNativeSuper","Class","_cache","Map","fn","Function","call","Wrapper","_construct","_getPrototypeOf","create","enumerable","writable","configurable","_setPrototypeOf","Parent","construct","sham","Proxy","Date","e","_isNativeReflectConstruct","instance","bind","o","setPrototypeOf","__proto__","getPrototypeOf","ObjectPrototypeMutationError","_Error","params","_this","Constructor","_classCallCheck","self","ReferenceError","_assertThisInitialized","_possibleConstructorReturn","subClass","superClass","_inherits","traverse","object","path","callback","segments","_loop","idx","currentSegment","v","index","remainingSegments","pathToHere","_ret","isLastSegment","property","currentObject","currentProperty","nextPropIsNumber","Number","isInteger","nextPropIsArrayWildcard","err","own","hasOwnProperty","hasOwn","isIn","objectInPath","pathExists","validPath","util","isString","normalizeArray","allowAboveRoot","res","splitPathRe","posix","posixSplitPath","exec","resolve","resolvedPath","resolvedAbsolute","cwd","normalize","isAbsolute","trailingSlash","segment","relative","from","to","trim","arr","fromParts","toParts","min","samePartsLength","outputParts","_makeLong","dirname","root","dir","extname","format","pathObject","isObject","base","pathString","allParts","delimiter","activePinia","setActivePinia","piniaSymbol","isPlainObject","MutationType","IS_CLIENT","_global","global","globalThis","HTMLElement","download","url","opts","xhr","XMLHttpRequest","responseType","onload","saveAs","onerror","send","corsEnabled","click","node","dispatchEvent","MouseEvent","evt","document","createEvent","initMouseEvent","_navigator","navigator","userAgent","isMacOSWebView","HTMLAnchorElement","blob","createElement","rel","href","origin","location","target","URL","createObjectURL","setTimeout","revokeObjectURL","msSaveOrOpenBlob","autoBom","Blob","bom","popup","title","innerText","force","isSafari","isChromeIOS","FileReader","reader","onloadend","readAsDataURL","toastMessage","message","piniaMessage","__VUE_DEVTOOLS_TOAST__","warn","log","isPinia","checkClipboardAccess","checkNotFocusedError","fileInput","loadStoresState","state","storeState","formatDisplay","display","_custom","PINIA_ROOT_LABEL","PINIA_ROOT_ID","formatStoreForInspectorTree","store","label","$id","formatEventData","events","event","operations","oldValue","newValue","operation","formatMutationType","direct","patchFunction","patchObject","isTimelineActive","componentStateTypes","MUTATIONS_LAYER_ID","INSPECTOR_ID","assign$1","getStoreType","registerPiniaDevtools","app","logo","packageName","homepage","api","now","addTimelineLayer","color","addInspector","icon","treeFilterPlaceholder","actions","action","clipboard","writeText","JSON","stringify","actionGlobalCopyState","tooltip","readText","actionGlobalPasteState","sendInspectorTree","sendInspectorState","actionGlobalSaveState","accept","Promise","reject","onchange","files","oncancel","actionGlobalOpenStateFile","nodeActions","nodeId","_s","$reset","on","inspectComponent","payload","ctx","proxy","componentInstance","_pStores","piniaStores","values","instanceData","editable","_isOptionsAPI","$state","_getters","getters","getInspectorTree","inspectorId","stores","rootNodes","$pinia","getInspectorState","inspectedStore","$store","storeNames","storeMap","storeId","getterName","_customProperties","customProperties","formatStoreForInspectorState","editInspectorState","editComponentState","activeAction","runningActionId","patchActionForGrouping","actionNames","wrapWithProxy","storeActions","actionName","_actionId","trackedStore","retValue","devtoolsPlugin","_p","_testing","originalHotUpdate","_hotUpdate","newStore","_hmrPayload","settings","logStoreChanges","defaultValue","$onAction","after","onError","groupId","addTimelineEvent","layerId","time","subtitle","logType","notifyComponentUpdate","deep","$subscribe","eventData","detached","flush","hotUpdate","$dispose","getSettings","addStoreToDevtools","scope","run","toBeInstalled","install","_a","provide","config","globalProperties","__VUE_PROD_DEVTOOLS__","plugin","_e","noop","addSubscription","subscriptions","onCleanup","removeSubscription","triggerSubscriptions","fallbackRunWithContext","ACTION_MARKER","ACTION_NAME","mergeReactiveObjects","patchToApply","subPatch","targetValue","skipHydrateSymbol","skipHydrateMap","WeakMap","createSetupStore","setup","hot","isOptionsStore","optionsForPlugin","$subscribeOptions","isListening","isSyncListening","debuggerEvents","actionSubscriptions","initialState","hotState","activeListener","$patch","partialStateOrMutator","subscriptionMutation","myListenerId","then","newState","wrappedAction","afterCallbackList","onErrorCallbackList","catch","partialStore","stopWatcher","stop","delete","_r","setupStore","runWithContext","effect","actionValue","nonEnumerable","extender","extensions","hydrate","defineStore","idOrOptions","setupOptions","isSetupStore","useStore","hasContext","localState","computedGetters","createOptionsStore","mapStoreSuffix","mapStores","reduced","_Vue","mixin","beforeCreate","$options","_provided","provideCache","destroyed","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","loaded","__webpack_modules__","O","chunkIds","priority","notFulfilled","Infinity","fulfilled","every","getter","__esModule","d","definition","chunkId","all","promises","g","l","done","script","needAttach","scripts","getElementsByTagName","getAttribute","charset","timeout","nc","setAttribute","onScriptComplete","clearTimeout","doneFns","parentNode","removeChild","head","appendChild","toStringTag","nmd","paths","children","scriptUrl","importScripts","currentScript","tagName","baseURI","installedChunks","installedChunkData","promise","errorType","realSrc","request","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","chunkLoadingGlobal","__webpack_exports__"],"sourceRoot":""}