{"version":3,"file":"index-iRkXcDud.chunk.mjs","sources":["../node_modules/@nextcloud/l10n/dist/index.mjs","../node_modules/@nextcloud/vue/dist/chunks/useNcActions-BzPO2c4h.mjs","../node_modules/@nextcloud/vue/dist/chunks/focusTrap-HJQ4pqHV.mjs","../node_modules/@nextcloud/vue/dist/chunks/useTrapStackControl-B6cEicto.mjs","../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../node_modules/floating-vue/node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs","../node_modules/floating-vue/dist/floating-vue.mjs","../node_modules/tabbable/dist/index.esm.js","../node_modules/focus-trap/dist/focus-trap.esm.js","../node_modules/@nextcloud/vue/dist/chunks/rtl-v0UOPAM7.mjs","../node_modules/@nextcloud/vue/dist/chunks/NcPopover-OqcYrWOx.mjs","../node_modules/@nextcloud/vue/dist/chunks/NcActions-BWDsG06k.mjs","../node_modules/@vueuse/core/node_modules/@vueuse/shared/dist/index.js","../node_modules/@vueuse/core/dist/index.js","../node_modules/@nextcloud/vue/dist/composables/useIsMobile/index.mjs","../node_modules/@nextcloud/vue/dist/chunks/NcDialogButton.vue_vue_type_script_setup_true_lang-DABuSwSR.mjs","../node_modules/@nextcloud/vue/dist/composables/useFormatDateTime/index.mjs","../node_modules/@nextcloud/vue/dist/chunks/platform-CC2ecGvV.mjs","../node_modules/@nextcloud/vue/dist/composables/useHotKey/index.mjs","../node_modules/@nextcloud/vue/dist/functions/isDarkTheme/index.mjs","../node_modules/@nextcloud/vue/dist/composables/useIsFullscreen/index.mjs","../node_modules/@nextcloud/vue/dist/chunks/NcModal-DHryP_87.mjs","../node_modules/@nextcloud/vue/dist/chunks/NcDialog-BG9t4Psg.mjs","../node_modules/@nextcloud/vue/dist/functions/dialog/index.mjs"],"sourcesContent":["import { g as getCanonicalLocale, a as getLanguage } from \"./chunks/translation-DoG5ZELJ.mjs\";\nimport { b, e, i, l, d, r, c, s, t, t as t2, d as d2, u } from \"./chunks/translation-DoG5ZELJ.mjs\";\n/*!\n * SPDX-FileCopyrightText: 2022 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: GPL-3.0-or-later\n */\nfunction getFirstDay() {\n  if (typeof globalThis.firstDay !== \"undefined\") {\n    return globalThis.firstDay;\n  }\n  const intl = new Intl.Locale(getCanonicalLocale());\n  const weekInfo = intl.getWeekInfo?.() ?? intl.weekInfo;\n  if (weekInfo) {\n    return weekInfo.firstDay % 7;\n  }\n  return 1;\n}\nfunction getDayNames() {\n  if (typeof globalThis.dayNames !== \"undefined\") {\n    return globalThis.dayNames;\n  }\n  const locale = getCanonicalLocale();\n  return [\n    new Date(1970, 0, 4).toLocaleDateString(locale, { weekday: \"long\" }),\n    new Date(1970, 0, 5).toLocaleDateString(locale, { weekday: \"long\" }),\n    new Date(1970, 0, 6).toLocaleDateString(locale, { weekday: \"long\" }),\n    new Date(1970, 0, 7).toLocaleDateString(locale, { weekday: \"long\" }),\n    new Date(1970, 0, 8).toLocaleDateString(locale, { weekday: \"long\" }),\n    new Date(1970, 0, 9).toLocaleDateString(locale, { weekday: \"long\" }),\n    new Date(1970, 0, 10).toLocaleDateString(locale, { weekday: \"long\" })\n  ];\n}\nfunction getDayNamesShort() {\n  if (typeof globalThis.dayNamesShort !== \"undefined\") {\n    return globalThis.dayNamesShort;\n  }\n  const locale = getCanonicalLocale();\n  return [\n    new Date(1970, 0, 4).toLocaleDateString(locale, { weekday: \"short\" }),\n    new Date(1970, 0, 5).toLocaleDateString(locale, { weekday: \"short\" }),\n    new Date(1970, 0, 6).toLocaleDateString(locale, { weekday: \"short\" }),\n    new Date(1970, 0, 7).toLocaleDateString(locale, { weekday: \"short\" }),\n    new Date(1970, 0, 8).toLocaleDateString(locale, { weekday: \"short\" }),\n    new Date(1970, 0, 9).toLocaleDateString(locale, { weekday: \"short\" }),\n    new Date(1970, 0, 10).toLocaleDateString(locale, { weekday: \"short\" })\n  ];\n}\nfunction getDayNamesMin() {\n  if (typeof globalThis.dayNamesMin !== \"undefined\") {\n    return globalThis.dayNamesMin;\n  }\n  const locale = getCanonicalLocale();\n  return [\n    new Date(1970, 0, 4).toLocaleDateString(locale, { weekday: \"narrow\" }),\n    new Date(1970, 0, 5).toLocaleDateString(locale, { weekday: \"narrow\" }),\n    new Date(1970, 0, 6).toLocaleDateString(locale, { weekday: \"narrow\" }),\n    new Date(1970, 0, 7).toLocaleDateString(locale, { weekday: \"narrow\" }),\n    new Date(1970, 0, 8).toLocaleDateString(locale, { weekday: \"narrow\" }),\n    new Date(1970, 0, 9).toLocaleDateString(locale, { weekday: \"narrow\" }),\n    new Date(1970, 0, 10).toLocaleDateString(locale, { weekday: \"narrow\" })\n  ];\n}\nfunction getMonthNames() {\n  if (typeof globalThis.monthNames !== \"undefined\") {\n    return globalThis.monthNames;\n  }\n  const locale = getCanonicalLocale();\n  return [\n    new Date(1970, 0).toLocaleDateString(locale, { month: \"long\" }),\n    new Date(1970, 1).toLocaleDateString(locale, { month: \"long\" }),\n    new Date(1970, 2).toLocaleDateString(locale, { month: \"long\" }),\n    new Date(1970, 3).toLocaleDateString(locale, { month: \"long\" }),\n    new Date(1970, 4).toLocaleDateString(locale, { month: \"long\" }),\n    new Date(1970, 5).toLocaleDateString(locale, { month: \"long\" }),\n    new Date(1970, 6).toLocaleDateString(locale, { month: \"long\" }),\n    new Date(1970, 7).toLocaleDateString(locale, { month: \"long\" }),\n    new Date(1970, 8).toLocaleDateString(locale, { month: \"long\" }),\n    new Date(1970, 9).toLocaleDateString(locale, { month: \"long\" }),\n    new Date(1970, 10).toLocaleDateString(locale, { month: \"long\" }),\n    new Date(1970, 11).toLocaleDateString(locale, { month: \"long\" })\n  ];\n}\nfunction getMonthNamesShort() {\n  if (typeof globalThis.monthNamesShort !== \"undefined\") {\n    return globalThis.monthNamesShort;\n  }\n  const locale = getCanonicalLocale();\n  return [\n    new Date(1970, 0).toLocaleDateString(locale, { month: \"short\" }),\n    new Date(1970, 1).toLocaleDateString(locale, { month: \"short\" }),\n    new Date(1970, 2).toLocaleDateString(locale, { month: \"short\" }),\n    new Date(1970, 3).toLocaleDateString(locale, { month: \"short\" }),\n    new Date(1970, 4).toLocaleDateString(locale, { month: \"short\" }),\n    new Date(1970, 5).toLocaleDateString(locale, { month: \"short\" }),\n    new Date(1970, 6).toLocaleDateString(locale, { month: \"short\" }),\n    new Date(1970, 7).toLocaleDateString(locale, { month: \"short\" }),\n    new Date(1970, 8).toLocaleDateString(locale, { month: \"short\" }),\n    new Date(1970, 9).toLocaleDateString(locale, { month: \"short\" }),\n    new Date(1970, 10).toLocaleDateString(locale, { month: \"short\" }),\n    new Date(1970, 11).toLocaleDateString(locale, { month: \"short\" })\n  ];\n}\n/*!\n * SPDX-FileCopyrightText: 2025 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: GPL-3.0-or-later\n */\nfunction formatRelativeTime(timestamp = Date.now(), opts = {}) {\n  const options = {\n    ignoreSeconds: false,\n    language: getLanguage(),\n    relativeTime: \"long\",\n    ...opts\n  };\n  const date = new Date(timestamp);\n  const formatter = new Intl.RelativeTimeFormat([options.language, getLanguage()], { numeric: \"auto\", style: options.relativeTime });\n  const diff = date.getTime() - Date.now();\n  const seconds = diff / 1e3;\n  if (Math.abs(seconds) < 59.5) {\n    return options.ignoreSeconds || formatter.format(Math.round(seconds), \"second\");\n  }\n  const minutes = seconds / 60;\n  if (Math.abs(minutes) <= 59) {\n    return formatter.format(Math.round(minutes), \"minute\");\n  }\n  const hours = minutes / 60;\n  if (Math.abs(hours) < 23.5) {\n    return formatter.format(Math.round(hours), \"hour\");\n  }\n  const days = hours / 24;\n  if (Math.abs(days) < 6.5) {\n    return formatter.format(Math.round(days), \"day\");\n  }\n  if (Math.abs(days) < 27.5) {\n    const weeks = days / 7;\n    return formatter.format(Math.round(weeks), \"week\");\n  }\n  const months = days / 30;\n  const format = Math.abs(months) < 11 ? { month: options.relativeTime, day: \"numeric\" } : { year: options.relativeTime === \"narrow\" ? \"2-digit\" : \"numeric\", month: options.relativeTime };\n  const dateTimeFormatter = new Intl.DateTimeFormat([options.language, getLanguage()], format);\n  return dateTimeFormatter.format(date);\n}\nexport {\n  formatRelativeTime,\n  getCanonicalLocale,\n  getDayNames,\n  getDayNamesMin,\n  getDayNamesShort,\n  getFirstDay,\n  getLanguage,\n  b as getLocale,\n  getMonthNames,\n  getMonthNamesShort,\n  e as getPlural,\n  i as isRTL,\n  l as loadTranslations,\n  d as n,\n  r as register,\n  c as setLanguage,\n  s as setLocale,\n  t,\n  t2 as translate,\n  d2 as translatePlural,\n  u as unregister\n};\n//# sourceMappingURL=index.mjs.map\n","const NC_ACTIONS_IS_SEMANTIC_MENU = /* @__PURE__ */ Symbol.for(\"NcActions:isSemanticMenu\");\nconst NC_ACTIONS_CLOSE_MENU = /* @__PURE__ */ Symbol.for(\"NcActions:closeMenu\");\nexport {\n  NC_ACTIONS_CLOSE_MENU as N,\n  NC_ACTIONS_IS_SEMANTIC_MENU as a\n};\n//# sourceMappingURL=useNcActions-BzPO2c4h.mjs.map\n","function getTrapStack() {\n  window._nc_focus_trap ??= [];\n  return window._nc_focus_trap;\n}\nfunction createTrapStackController() {\n  let pausedStack = [];\n  return {\n    /**\n     * Pause the current focus-trap stack\n     */\n    pause() {\n      pausedStack = [...getTrapStack()];\n      for (const trap of pausedStack) {\n        trap.pause();\n      }\n    },\n    /**\n     * Unpause the paused focus trap stack\n     * If the actual stack is different from the paused one, ignore unpause.\n     */\n    unpause() {\n      if (pausedStack.length === getTrapStack().length) {\n        for (const trap of pausedStack) {\n          trap.unpause();\n        }\n      }\n      pausedStack = [];\n    }\n  };\n}\nexport {\n  createTrapStackController as c,\n  getTrapStack as g\n};\n//# sourceMappingURL=focusTrap-HJQ4pqHV.mjs.map\n","import { watch, toValue, onUnmounted } from \"vue\";\nimport { c as createTrapStackController } from \"./focusTrap-HJQ4pqHV.mjs\";\nfunction useTrapStackControl(shouldPause, options = {}) {\n  const trapStackController = createTrapStackController();\n  watch(shouldPause, () => {\n    if (toValue(options.disabled)) {\n      return;\n    }\n    if (toValue(shouldPause)) {\n      trapStackController.pause();\n    } else {\n      trapStackController.unpause();\n    }\n  });\n  onUnmounted(() => {\n    trapStackController.unpause();\n  });\n}\nexport {\n  useTrapStackControl as u\n};\n//# sourceMappingURL=useTrapStackControl-B6cEicto.mjs.map\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    var _platform$detectOverf;\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform: {\n        ...platform,\n        detectOverflow: (_platform$detectOverf = platform.detectOverflow) != null ? _platform$detectOverf : detectOverflow\n      },\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await platform.detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await platform.detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects,\n        platform\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await platform.detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await platform.detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        platform\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await platform.detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await platform.detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","import{rectToClientRect as t,computePosition as e}from\"@floating-ui/core\";export{arrow,autoPlacement,detectOverflow,flip,hide,inline,limitShift,offset,shift,size}from\"@floating-ui/core\";function n(t){var e;return(null==(e=t.ownerDocument)?void 0:e.defaultView)||window}function o(t){return n(t).getComputedStyle(t)}const i=Math.min,r=Math.max,l=Math.round;function c(t){const e=o(t);let n=parseFloat(e.width),i=parseFloat(e.height);const r=t.offsetWidth,c=t.offsetHeight,s=l(n)!==r||l(i)!==c;return s&&(n=r,i=c),{width:n,height:i,fallback:s}}function s(t){return h(t)?(t.nodeName||\"\").toLowerCase():\"\"}let f;function u(){if(f)return f;const t=navigator.userAgentData;return t&&Array.isArray(t.brands)?(f=t.brands.map((t=>t.brand+\"/\"+t.version)).join(\" \"),f):navigator.userAgent}function a(t){return t instanceof n(t).HTMLElement}function d(t){return t instanceof n(t).Element}function h(t){return t instanceof n(t).Node}function p(t){if(\"undefined\"==typeof ShadowRoot)return!1;return t instanceof n(t).ShadowRoot||t instanceof ShadowRoot}function g(t){const{overflow:e,overflowX:n,overflowY:i,display:r}=o(t);return/auto|scroll|overlay|hidden|clip/.test(e+i+n)&&![\"inline\",\"contents\"].includes(r)}function m(t){return[\"table\",\"td\",\"th\"].includes(s(t))}function y(t){const e=/firefox/i.test(u()),n=o(t),i=n.backdropFilter||n.WebkitBackdropFilter;return\"none\"!==n.transform||\"none\"!==n.perspective||!!i&&\"none\"!==i||e&&\"filter\"===n.willChange||e&&!!n.filter&&\"none\"!==n.filter||[\"transform\",\"perspective\"].some((t=>n.willChange.includes(t)))||[\"paint\",\"layout\",\"strict\",\"content\"].some((t=>{const e=n.contain;return null!=e&&e.includes(t)}))}function x(){return!/^((?!chrome|android).)*safari/i.test(u())}function w(t){return[\"html\",\"body\",\"#document\"].includes(s(t))}function v(t){return d(t)?t:t.contextElement}const b={x:1,y:1};function L(t){const e=v(t);if(!a(e))return b;const n=e.getBoundingClientRect(),{width:o,height:i,fallback:r}=c(e);let s=(r?l(n.width):n.width)/o,f=(r?l(n.height):n.height)/i;return s&&Number.isFinite(s)||(s=1),f&&Number.isFinite(f)||(f=1),{x:s,y:f}}function E(t,e,o,i){var r,l;void 0===e&&(e=!1),void 0===o&&(o=!1);const c=t.getBoundingClientRect(),s=v(t);let f=b;e&&(i?d(i)&&(f=L(i)):f=L(t));const u=s?n(s):window,a=!x()&&o;let h=(c.left+(a&&(null==(r=u.visualViewport)?void 0:r.offsetLeft)||0))/f.x,p=(c.top+(a&&(null==(l=u.visualViewport)?void 0:l.offsetTop)||0))/f.y,g=c.width/f.x,m=c.height/f.y;if(s){const t=n(s),e=i&&d(i)?n(i):i;let o=t.frameElement;for(;o&&i&&e!==t;){const t=L(o),e=o.getBoundingClientRect(),i=getComputedStyle(o);e.x+=(o.clientLeft+parseFloat(i.paddingLeft))*t.x,e.y+=(o.clientTop+parseFloat(i.paddingTop))*t.y,h*=t.x,p*=t.y,g*=t.x,m*=t.y,h+=e.x,p+=e.y,o=n(o).frameElement}}return{width:g,height:m,top:p,right:h+g,bottom:p+m,left:h,x:h,y:p}}function R(t){return((h(t)?t.ownerDocument:t.document)||window.document).documentElement}function T(t){return d(t)?{scrollLeft:t.scrollLeft,scrollTop:t.scrollTop}:{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function C(t){return E(R(t)).left+T(t).scrollLeft}function F(t){if(\"html\"===s(t))return t;const e=t.assignedSlot||t.parentNode||p(t)&&t.host||R(t);return p(e)?e.host:e}function W(t){const e=F(t);return w(e)?e.ownerDocument.body:a(e)&&g(e)?e:W(e)}function D(t,e){var o;void 0===e&&(e=[]);const i=W(t),r=i===(null==(o=t.ownerDocument)?void 0:o.body),l=n(i);return r?e.concat(l,l.visualViewport||[],g(i)?i:[]):e.concat(i,D(i))}function S(e,i,l){return\"viewport\"===i?t(function(t,e){const o=n(t),i=R(t),r=o.visualViewport;let l=i.clientWidth,c=i.clientHeight,s=0,f=0;if(r){l=r.width,c=r.height;const t=x();(t||!t&&\"fixed\"===e)&&(s=r.offsetLeft,f=r.offsetTop)}return{width:l,height:c,x:s,y:f}}(e,l)):d(i)?t(function(t,e){const n=E(t,!0,\"fixed\"===e),o=n.top+t.clientTop,i=n.left+t.clientLeft,r=a(t)?L(t):{x:1,y:1};return{width:t.clientWidth*r.x,height:t.clientHeight*r.y,x:i*r.x,y:o*r.y}}(i,l)):t(function(t){const e=R(t),n=T(t),i=t.ownerDocument.body,l=r(e.scrollWidth,e.clientWidth,i.scrollWidth,i.clientWidth),c=r(e.scrollHeight,e.clientHeight,i.scrollHeight,i.clientHeight);let s=-n.scrollLeft+C(t);const f=-n.scrollTop;return\"rtl\"===o(i).direction&&(s+=r(e.clientWidth,i.clientWidth)-l),{width:l,height:c,x:s,y:f}}(R(e)))}function A(t){return a(t)&&\"fixed\"!==o(t).position?t.offsetParent:null}function H(t){const e=n(t);let i=A(t);for(;i&&m(i)&&\"static\"===o(i).position;)i=A(i);return i&&(\"html\"===s(i)||\"body\"===s(i)&&\"static\"===o(i).position&&!y(i))?e:i||function(t){let e=F(t);for(;a(e)&&!w(e);){if(y(e))return e;e=F(e)}return null}(t)||e}function O(t,e,n){const o=a(e),i=R(e),r=E(t,!0,\"fixed\"===n,e);let l={scrollLeft:0,scrollTop:0};const c={x:0,y:0};if(o||!o&&\"fixed\"!==n)if((\"body\"!==s(e)||g(i))&&(l=T(e)),a(e)){const t=E(e,!0);c.x=t.x+e.clientLeft,c.y=t.y+e.clientTop}else i&&(c.x=C(i));return{x:r.left+l.scrollLeft-c.x,y:r.top+l.scrollTop-c.y,width:r.width,height:r.height}}const P={getClippingRect:function(t){let{element:e,boundary:n,rootBoundary:l,strategy:c}=t;const f=\"clippingAncestors\"===n?function(t,e){const n=e.get(t);if(n)return n;let i=D(t).filter((t=>d(t)&&\"body\"!==s(t))),r=null;const l=\"fixed\"===o(t).position;let c=l?F(t):t;for(;d(c)&&!w(c);){const t=o(c),e=y(c);(l?e||r:e||\"static\"!==t.position||!r||![\"absolute\",\"fixed\"].includes(r.position))?r=t:i=i.filter((t=>t!==c)),c=F(c)}return e.set(t,i),i}(e,this._c):[].concat(n),u=[...f,l],a=u[0],h=u.reduce(((t,n)=>{const o=S(e,n,c);return t.top=r(o.top,t.top),t.right=i(o.right,t.right),t.bottom=i(o.bottom,t.bottom),t.left=r(o.left,t.left),t}),S(e,a,c));return{width:h.right-h.left,height:h.bottom-h.top,x:h.left,y:h.top}},convertOffsetParentRelativeRectToViewportRelativeRect:function(t){let{rect:e,offsetParent:n,strategy:o}=t;const i=a(n),r=R(n);if(n===r)return e;let l={scrollLeft:0,scrollTop:0},c={x:1,y:1};const f={x:0,y:0};if((i||!i&&\"fixed\"!==o)&&((\"body\"!==s(n)||g(r))&&(l=T(n)),a(n))){const t=E(n);c=L(n),f.x=t.x+n.clientLeft,f.y=t.y+n.clientTop}return{width:e.width*c.x,height:e.height*c.y,x:e.x*c.x-l.scrollLeft*c.x+f.x,y:e.y*c.y-l.scrollTop*c.y+f.y}},isElement:d,getDimensions:function(t){return a(t)?c(t):t.getBoundingClientRect()},getOffsetParent:H,getDocumentElement:R,getScale:L,async getElementRects(t){let{reference:e,floating:n,strategy:o}=t;const i=this.getOffsetParent||H,r=this.getDimensions;return{reference:O(e,await i(n),o),floating:{x:0,y:0,...await r(n)}}},getClientRects:t=>Array.from(t.getClientRects()),isRTL:t=>\"rtl\"===o(t).direction};function z(t,e,n,o){void 0===o&&(o={});const{ancestorScroll:i=!0,ancestorResize:r=!0,elementResize:l=!0,animationFrame:c=!1}=o,s=i&&!c,f=s||r?[...d(t)?D(t):t.contextElement?D(t.contextElement):[],...D(e)]:[];f.forEach((t=>{s&&t.addEventListener(\"scroll\",n,{passive:!0}),r&&t.addEventListener(\"resize\",n)}));let u,a=null;if(l){let o=!0;a=new ResizeObserver((()=>{o||n(),o=!1})),d(t)&&!c&&a.observe(t),d(t)||!t.contextElement||c||a.observe(t.contextElement),a.observe(e)}let h=c?E(t):null;return c&&function e(){const o=E(t);!h||o.x===h.x&&o.y===h.y&&o.width===h.width&&o.height===h.height||n();h=o,u=requestAnimationFrame(e)}(),n(),()=>{var t;f.forEach((t=>{s&&t.removeEventListener(\"scroll\",n),r&&t.removeEventListener(\"resize\",n)})),null==(t=a)||t.disconnect(),a=null,c&&cancelAnimationFrame(u)}}const B=(t,n,o)=>{const i=new Map,r={platform:P,...o},l={...r.platform,_c:i};return e(t,n,{...r,platform:l})};export{z as autoUpdate,B as computePosition,D as getOverflowAncestors,P as platform};\n","import { defineComponent as O, openBlock as f, createElementBlock as T, normalizeClass as J, renderSlot as A, normalizeProps as ke, guardReactiveProps as Le, pushScopeId as De, popScopeId as Ie, nextTick as Fe, createBlock as M, withScopeId as Re, resolveComponent as P, normalizeStyle as W, withKeys as je, createElementVNode as w, Fragment as Ve, createCommentVNode as se, mergeProps as $e, withCtx as N, createVNode as ve, toDisplayString as We, ref as U, createApp as Ge, h as qe } from \"vue\";\nimport { offset as xe, autoPlacement as Ue, shift as Ye, flip as Xe, arrow as Ke, size as Je, computePosition as Qe, getOverflowAncestors as ne } from \"@floating-ui/dom\";\nfunction ye(e, t) {\n  for (const o in t)\n    Object.prototype.hasOwnProperty.call(t, o) && (typeof t[o] == \"object\" && e[o] ? ye(e[o], t[o]) : e[o] = t[o]);\n}\nconst h = {\n  // Disable popper components\n  disabled: !1,\n  // Default position offset along main axis (px)\n  distance: 5,\n  // Default position offset along cross axis (px)\n  skidding: 0,\n  // Default container where the tooltip will be appended\n  container: \"body\",\n  // Element used to compute position and size boundaries\n  boundary: void 0,\n  // Skip delay & CSS transitions when another popper is shown, so that the popper appear to instanly move to the new position.\n  instantMove: !1,\n  // Auto destroy tooltip DOM nodes (ms)\n  disposeTimeout: 150,\n  // Triggers on the popper itself\n  popperTriggers: [],\n  // Positioning strategy\n  strategy: \"absolute\",\n  // Prevent overflow\n  preventOverflow: !0,\n  // Flip to the opposite placement if needed\n  flip: !0,\n  // Shift on the cross axis to prevent the popper from overflowing\n  shift: !0,\n  // Overflow padding (px)\n  overflowPadding: 0,\n  // Arrow padding (px)\n  arrowPadding: 0,\n  // Compute arrow overflow (useful to hide it)\n  arrowOverflow: !0,\n  /**\n   * By default, compute autohide on 'click'.\n   */\n  autoHideOnMousedown: !1,\n  // Themes\n  themes: {\n    tooltip: {\n      // Default tooltip placement relative to target element\n      placement: \"top\",\n      // Default events that trigger the tooltip\n      triggers: [\"hover\", \"focus\", \"touch\"],\n      // Close tooltip on click on tooltip target\n      hideTriggers: (e) => [...e, \"click\"],\n      // Delay (ms)\n      delay: {\n        show: 200,\n        hide: 0\n      },\n      // Update popper on content resize\n      handleResize: !1,\n      // Enable HTML content in directive\n      html: !1,\n      // Displayed when tooltip content is loading\n      loadingContent: \"...\"\n    },\n    dropdown: {\n      // Default dropdown placement relative to target element\n      placement: \"bottom\",\n      // Default events that trigger the dropdown\n      triggers: [\"click\"],\n      // Delay (ms)\n      delay: 0,\n      // Update popper on content resize\n      handleResize: !0,\n      // Hide on clock outside\n      autoHide: !0\n    },\n    menu: {\n      $extend: \"dropdown\",\n      triggers: [\"hover\", \"focus\"],\n      popperTriggers: [\"hover\"],\n      delay: {\n        show: 0,\n        hide: 400\n      }\n    }\n  }\n};\nfunction S(e, t) {\n  let o = h.themes[e] || {}, i;\n  do\n    i = o[t], typeof i > \"u\" ? o.$extend ? o = h.themes[o.$extend] || {} : (o = null, i = h[t]) : o = null;\n  while (o);\n  return i;\n}\nfunction Ze(e) {\n  const t = [e];\n  let o = h.themes[e] || {};\n  do\n    o.$extend && !o.$resetCss ? (t.push(o.$extend), o = h.themes[o.$extend] || {}) : o = null;\n  while (o);\n  return t.map((i) => `v-popper--theme-${i}`);\n}\nfunction re(e) {\n  const t = [e];\n  let o = h.themes[e] || {};\n  do\n    o.$extend ? (t.push(o.$extend), o = h.themes[o.$extend] || {}) : o = null;\n  while (o);\n  return t;\n}\nlet $ = !1;\nif (typeof window < \"u\") {\n  $ = !1;\n  try {\n    const e = Object.defineProperty({}, \"passive\", {\n      get() {\n        $ = !0;\n      }\n    });\n    window.addEventListener(\"test\", null, e);\n  } catch {\n  }\n}\nlet _e = !1;\ntypeof window < \"u\" && typeof navigator < \"u\" && (_e = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);\nconst Te = [\"auto\", \"top\", \"bottom\", \"left\", \"right\"].reduce((e, t) => e.concat([\n  t,\n  `${t}-start`,\n  `${t}-end`\n]), []), pe = {\n  hover: \"mouseenter\",\n  focus: \"focus\",\n  click: \"click\",\n  touch: \"touchstart\",\n  pointer: \"pointerdown\"\n}, ae = {\n  hover: \"mouseleave\",\n  focus: \"blur\",\n  click: \"click\",\n  touch: \"touchend\",\n  pointer: \"pointerup\"\n};\nfunction de(e, t) {\n  const o = e.indexOf(t);\n  o !== -1 && e.splice(o, 1);\n}\nfunction G() {\n  return new Promise((e) => requestAnimationFrame(() => {\n    requestAnimationFrame(e);\n  }));\n}\nconst d = [];\nlet g = null;\nconst le = {};\nfunction he(e) {\n  let t = le[e];\n  return t || (t = le[e] = []), t;\n}\nlet Y = function() {\n};\ntypeof window < \"u\" && (Y = window.Element);\nfunction n(e) {\n  return function(t) {\n    return S(t.theme, e);\n  };\n}\nconst q = \"__floating-vue__popper\", Q = () => O({\n  name: \"VPopper\",\n  provide() {\n    return {\n      [q]: {\n        parentPopper: this\n      }\n    };\n  },\n  inject: {\n    [q]: { default: null }\n  },\n  props: {\n    theme: {\n      type: String,\n      required: !0\n    },\n    targetNodes: {\n      type: Function,\n      required: !0\n    },\n    referenceNode: {\n      type: Function,\n      default: null\n    },\n    popperNode: {\n      type: Function,\n      required: !0\n    },\n    shown: {\n      type: Boolean,\n      default: !1\n    },\n    showGroup: {\n      type: String,\n      default: null\n    },\n    // eslint-disable-next-line vue/require-prop-types\n    ariaId: {\n      default: null\n    },\n    disabled: {\n      type: Boolean,\n      default: n(\"disabled\")\n    },\n    positioningDisabled: {\n      type: Boolean,\n      default: n(\"positioningDisabled\")\n    },\n    placement: {\n      type: String,\n      default: n(\"placement\"),\n      validator: (e) => Te.includes(e)\n    },\n    delay: {\n      type: [String, Number, Object],\n      default: n(\"delay\")\n    },\n    distance: {\n      type: [Number, String],\n      default: n(\"distance\")\n    },\n    skidding: {\n      type: [Number, String],\n      default: n(\"skidding\")\n    },\n    triggers: {\n      type: Array,\n      default: n(\"triggers\")\n    },\n    showTriggers: {\n      type: [Array, Function],\n      default: n(\"showTriggers\")\n    },\n    hideTriggers: {\n      type: [Array, Function],\n      default: n(\"hideTriggers\")\n    },\n    popperTriggers: {\n      type: Array,\n      default: n(\"popperTriggers\")\n    },\n    popperShowTriggers: {\n      type: [Array, Function],\n      default: n(\"popperShowTriggers\")\n    },\n    popperHideTriggers: {\n      type: [Array, Function],\n      default: n(\"popperHideTriggers\")\n    },\n    container: {\n      type: [String, Object, Y, Boolean],\n      default: n(\"container\")\n    },\n    boundary: {\n      type: [String, Y],\n      default: n(\"boundary\")\n    },\n    strategy: {\n      type: String,\n      validator: (e) => [\"absolute\", \"fixed\"].includes(e),\n      default: n(\"strategy\")\n    },\n    autoHide: {\n      type: [Boolean, Function],\n      default: n(\"autoHide\")\n    },\n    handleResize: {\n      type: Boolean,\n      default: n(\"handleResize\")\n    },\n    instantMove: {\n      type: Boolean,\n      default: n(\"instantMove\")\n    },\n    eagerMount: {\n      type: Boolean,\n      default: n(\"eagerMount\")\n    },\n    popperClass: {\n      type: [String, Array, Object],\n      default: n(\"popperClass\")\n    },\n    computeTransformOrigin: {\n      type: Boolean,\n      default: n(\"computeTransformOrigin\")\n    },\n    /**\n     * @deprecated\n     */\n    autoMinSize: {\n      type: Boolean,\n      default: n(\"autoMinSize\")\n    },\n    autoSize: {\n      type: [Boolean, String],\n      default: n(\"autoSize\")\n    },\n    /**\n     * @deprecated\n     */\n    autoMaxSize: {\n      type: Boolean,\n      default: n(\"autoMaxSize\")\n    },\n    autoBoundaryMaxSize: {\n      type: Boolean,\n      default: n(\"autoBoundaryMaxSize\")\n    },\n    preventOverflow: {\n      type: Boolean,\n      default: n(\"preventOverflow\")\n    },\n    overflowPadding: {\n      type: [Number, String],\n      default: n(\"overflowPadding\")\n    },\n    arrowPadding: {\n      type: [Number, String],\n      default: n(\"arrowPadding\")\n    },\n    arrowOverflow: {\n      type: Boolean,\n      default: n(\"arrowOverflow\")\n    },\n    flip: {\n      type: Boolean,\n      default: n(\"flip\")\n    },\n    shift: {\n      type: Boolean,\n      default: n(\"shift\")\n    },\n    shiftCrossAxis: {\n      type: Boolean,\n      default: n(\"shiftCrossAxis\")\n    },\n    noAutoFocus: {\n      type: Boolean,\n      default: n(\"noAutoFocus\")\n    },\n    disposeTimeout: {\n      type: Number,\n      default: n(\"disposeTimeout\")\n    }\n  },\n  emits: {\n    show: () => !0,\n    hide: () => !0,\n    \"update:shown\": (e) => !0,\n    \"apply-show\": () => !0,\n    \"apply-hide\": () => !0,\n    \"close-group\": () => !0,\n    \"close-directive\": () => !0,\n    \"auto-hide\": () => !0,\n    resize: () => !0\n  },\n  data() {\n    return {\n      isShown: !1,\n      isMounted: !1,\n      skipTransition: !1,\n      classes: {\n        showFrom: !1,\n        showTo: !1,\n        hideFrom: !1,\n        hideTo: !0\n      },\n      result: {\n        x: 0,\n        y: 0,\n        placement: \"\",\n        strategy: this.strategy,\n        arrow: {\n          x: 0,\n          y: 0,\n          centerOffset: 0\n        },\n        transformOrigin: null\n      },\n      randomId: `popper_${[Math.random(), Date.now()].map((e) => e.toString(36).substring(2, 10)).join(\"_\")}`,\n      shownChildren: /* @__PURE__ */ new Set(),\n      lastAutoHide: !0,\n      pendingHide: !1,\n      containsGlobalTarget: !1,\n      isDisposed: !0,\n      mouseDownContains: !1\n    };\n  },\n  computed: {\n    popperId() {\n      return this.ariaId != null ? this.ariaId : this.randomId;\n    },\n    shouldMountContent() {\n      return this.eagerMount || this.isMounted;\n    },\n    slotData() {\n      return {\n        popperId: this.popperId,\n        isShown: this.isShown,\n        shouldMountContent: this.shouldMountContent,\n        skipTransition: this.skipTransition,\n        autoHide: typeof this.autoHide == \"function\" ? this.lastAutoHide : this.autoHide,\n        show: this.show,\n        hide: this.hide,\n        handleResize: this.handleResize,\n        onResize: this.onResize,\n        classes: {\n          ...this.classes,\n          popperClass: this.popperClass\n        },\n        result: this.positioningDisabled ? null : this.result,\n        attrs: this.$attrs\n      };\n    },\n    parentPopper() {\n      var e;\n      return (e = this[q]) == null ? void 0 : e.parentPopper;\n    },\n    hasPopperShowTriggerHover() {\n      var e, t;\n      return ((e = this.popperTriggers) == null ? void 0 : e.includes(\"hover\")) || ((t = this.popperShowTriggers) == null ? void 0 : t.includes(\"hover\"));\n    }\n  },\n  watch: {\n    shown: \"$_autoShowHide\",\n    disabled(e) {\n      e ? this.dispose() : this.init();\n    },\n    async container() {\n      this.isShown && (this.$_ensureTeleport(), await this.$_computePosition());\n    },\n    triggers: {\n      handler: \"$_refreshListeners\",\n      deep: !0\n    },\n    positioningDisabled: \"$_refreshListeners\",\n    ...[\n      \"placement\",\n      \"distance\",\n      \"skidding\",\n      \"boundary\",\n      \"strategy\",\n      \"overflowPadding\",\n      \"arrowPadding\",\n      \"preventOverflow\",\n      \"shift\",\n      \"shiftCrossAxis\",\n      \"flip\"\n    ].reduce((e, t) => (e[t] = \"$_computePosition\", e), {})\n  },\n  created() {\n    this.autoMinSize && console.warn('[floating-vue] `autoMinSize` option is deprecated. Use `autoSize=\"min\"` instead.'), this.autoMaxSize && console.warn(\"[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.\");\n  },\n  mounted() {\n    this.init(), this.$_detachPopperNode();\n  },\n  activated() {\n    this.$_autoShowHide();\n  },\n  deactivated() {\n    this.hide();\n  },\n  beforeUnmount() {\n    this.dispose();\n  },\n  methods: {\n    show({ event: e = null, skipDelay: t = !1, force: o = !1 } = {}) {\n      var i, s;\n      (i = this.parentPopper) != null && i.lockedChild && this.parentPopper.lockedChild !== this || (this.pendingHide = !1, (o || !this.disabled) && (((s = this.parentPopper) == null ? void 0 : s.lockedChild) === this && (this.parentPopper.lockedChild = null), this.$_scheduleShow(e, t), this.$emit(\"show\"), this.$_showFrameLocked = !0, requestAnimationFrame(() => {\n        this.$_showFrameLocked = !1;\n      })), this.$emit(\"update:shown\", !0));\n    },\n    hide({ event: e = null, skipDelay: t = !1 } = {}) {\n      var o;\n      if (!this.$_hideInProgress) {\n        if (this.shownChildren.size > 0) {\n          this.pendingHide = !0;\n          return;\n        }\n        if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {\n          this.parentPopper && (this.parentPopper.lockedChild = this, clearTimeout(this.parentPopper.lockedChildTimer), this.parentPopper.lockedChildTimer = setTimeout(() => {\n            this.parentPopper.lockedChild === this && (this.parentPopper.lockedChild.hide({ skipDelay: t }), this.parentPopper.lockedChild = null);\n          }, 1e3));\n          return;\n        }\n        ((o = this.parentPopper) == null ? void 0 : o.lockedChild) === this && (this.parentPopper.lockedChild = null), this.pendingHide = !1, this.$_scheduleHide(e, t), this.$emit(\"hide\"), this.$emit(\"update:shown\", !1);\n      }\n    },\n    init() {\n      var e;\n      this.isDisposed && (this.isDisposed = !1, this.isMounted = !1, this.$_events = [], this.$_preventShow = !1, this.$_referenceNode = ((e = this.referenceNode) == null ? void 0 : e.call(this)) ?? this.$el, this.$_targetNodes = this.targetNodes().filter((t) => t.nodeType === t.ELEMENT_NODE), this.$_popperNode = this.popperNode(), this.$_innerNode = this.$_popperNode.querySelector(\".v-popper__inner\"), this.$_arrowNode = this.$_popperNode.querySelector(\".v-popper__arrow-container\"), this.$_swapTargetAttrs(\"title\", \"data-original-title\"), this.$_detachPopperNode(), this.triggers.length && this.$_addEventListeners(), this.shown && this.show());\n    },\n    dispose() {\n      this.isDisposed || (this.isDisposed = !0, this.$_removeEventListeners(), this.hide({ skipDelay: !0 }), this.$_detachPopperNode(), this.isMounted = !1, this.isShown = !1, this.$_updateParentShownChildren(!1), this.$_swapTargetAttrs(\"data-original-title\", \"title\"));\n    },\n    async onResize() {\n      this.isShown && (await this.$_computePosition(), this.$emit(\"resize\"));\n    },\n    async $_computePosition() {\n      if (this.isDisposed || this.positioningDisabled)\n        return;\n      const e = {\n        strategy: this.strategy,\n        middleware: []\n      };\n      (this.distance || this.skidding) && e.middleware.push(xe({\n        mainAxis: this.distance,\n        crossAxis: this.skidding\n      }));\n      const t = this.placement.startsWith(\"auto\");\n      if (t ? e.middleware.push(Ue({\n        alignment: this.placement.split(\"-\")[1] ?? \"\"\n      })) : e.placement = this.placement, this.preventOverflow && (this.shift && e.middleware.push(Ye({\n        padding: this.overflowPadding,\n        boundary: this.boundary,\n        crossAxis: this.shiftCrossAxis\n      })), !t && this.flip && e.middleware.push(Xe({\n        padding: this.overflowPadding,\n        boundary: this.boundary\n      }))), e.middleware.push(Ke({\n        element: this.$_arrowNode,\n        padding: this.arrowPadding\n      })), this.arrowOverflow && e.middleware.push({\n        name: \"arrowOverflow\",\n        fn: ({ placement: i, rects: s, middlewareData: r }) => {\n          let p;\n          const { centerOffset: a } = r.arrow;\n          return i.startsWith(\"top\") || i.startsWith(\"bottom\") ? p = Math.abs(a) > s.reference.width / 2 : p = Math.abs(a) > s.reference.height / 2, {\n            data: {\n              overflow: p\n            }\n          };\n        }\n      }), this.autoMinSize || this.autoSize) {\n        const i = this.autoSize ? this.autoSize : this.autoMinSize ? \"min\" : null;\n        e.middleware.push({\n          name: \"autoSize\",\n          fn: ({ rects: s, placement: r, middlewareData: p }) => {\n            var u;\n            if ((u = p.autoSize) != null && u.skip)\n              return {};\n            let a, l;\n            return r.startsWith(\"top\") || r.startsWith(\"bottom\") ? a = s.reference.width : l = s.reference.height, this.$_innerNode.style[i === \"min\" ? \"minWidth\" : i === \"max\" ? \"maxWidth\" : \"width\"] = a != null ? `${a}px` : null, this.$_innerNode.style[i === \"min\" ? \"minHeight\" : i === \"max\" ? \"maxHeight\" : \"height\"] = l != null ? `${l}px` : null, {\n              data: {\n                skip: !0\n              },\n              reset: {\n                rects: !0\n              }\n            };\n          }\n        });\n      }\n      (this.autoMaxSize || this.autoBoundaryMaxSize) && (this.$_innerNode.style.maxWidth = null, this.$_innerNode.style.maxHeight = null, e.middleware.push(Je({\n        boundary: this.boundary,\n        padding: this.overflowPadding,\n        apply: ({ availableWidth: i, availableHeight: s }) => {\n          this.$_innerNode.style.maxWidth = i != null ? `${i}px` : null, this.$_innerNode.style.maxHeight = s != null ? `${s}px` : null;\n        }\n      })));\n      const o = await Qe(this.$_referenceNode, this.$_popperNode, e);\n      Object.assign(this.result, {\n        x: o.x,\n        y: o.y,\n        placement: o.placement,\n        strategy: o.strategy,\n        arrow: {\n          ...o.middlewareData.arrow,\n          ...o.middlewareData.arrowOverflow\n        }\n      });\n    },\n    $_scheduleShow(e, t = !1) {\n      if (this.$_updateParentShownChildren(!0), this.$_hideInProgress = !1, clearTimeout(this.$_scheduleTimer), g && this.instantMove && g.instantMove && g !== this.parentPopper) {\n        g.$_applyHide(!0), this.$_applyShow(!0);\n        return;\n      }\n      t ? this.$_applyShow() : this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay(\"show\"));\n    },\n    $_scheduleHide(e, t = !1) {\n      if (this.shownChildren.size > 0) {\n        this.pendingHide = !0;\n        return;\n      }\n      this.$_updateParentShownChildren(!1), this.$_hideInProgress = !0, clearTimeout(this.$_scheduleTimer), this.isShown && (g = this), t ? this.$_applyHide() : this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay(\"hide\"));\n    },\n    $_computeDelay(e) {\n      const t = this.delay;\n      return parseInt(t && t[e] || t || 0);\n    },\n    async $_applyShow(e = !1) {\n      clearTimeout(this.$_disposeTimer), clearTimeout(this.$_scheduleTimer), this.skipTransition = e, !this.isShown && (this.$_ensureTeleport(), await G(), await this.$_computePosition(), await this.$_applyShowEffect(), this.positioningDisabled || this.$_registerEventListeners([\n        ...ne(this.$_referenceNode),\n        ...ne(this.$_popperNode)\n      ], \"scroll\", () => {\n        this.$_computePosition();\n      }));\n    },\n    async $_applyShowEffect() {\n      if (this.$_hideInProgress)\n        return;\n      if (this.computeTransformOrigin) {\n        const t = this.$_referenceNode.getBoundingClientRect(), o = this.$_popperNode.querySelector(\".v-popper__wrapper\"), i = o.parentNode.getBoundingClientRect(), s = t.x + t.width / 2 - (i.left + o.offsetLeft), r = t.y + t.height / 2 - (i.top + o.offsetTop);\n        this.result.transformOrigin = `${s}px ${r}px`;\n      }\n      this.isShown = !0, this.$_applyAttrsToTarget({\n        \"aria-describedby\": this.popperId,\n        \"data-popper-shown\": \"\"\n      });\n      const e = this.showGroup;\n      if (e) {\n        let t;\n        for (let o = 0; o < d.length; o++)\n          t = d[o], t.showGroup !== e && (t.hide(), t.$emit(\"close-group\"));\n      }\n      d.push(this), document.body.classList.add(\"v-popper--some-open\");\n      for (const t of re(this.theme))\n        he(t).push(this), document.body.classList.add(`v-popper--some-open--${t}`);\n      this.$emit(\"apply-show\"), this.classes.showFrom = !0, this.classes.showTo = !1, this.classes.hideFrom = !1, this.classes.hideTo = !1, await G(), this.classes.showFrom = !1, this.classes.showTo = !0, this.noAutoFocus || this.$_popperNode.focus();\n    },\n    async $_applyHide(e = !1) {\n      if (this.shownChildren.size > 0) {\n        this.pendingHide = !0, this.$_hideInProgress = !1;\n        return;\n      }\n      if (clearTimeout(this.$_scheduleTimer), !this.isShown)\n        return;\n      this.skipTransition = e, de(d, this), d.length === 0 && document.body.classList.remove(\"v-popper--some-open\");\n      for (const o of re(this.theme)) {\n        const i = he(o);\n        de(i, this), i.length === 0 && document.body.classList.remove(`v-popper--some-open--${o}`);\n      }\n      g === this && (g = null), this.isShown = !1, this.$_applyAttrsToTarget({\n        \"aria-describedby\": void 0,\n        \"data-popper-shown\": void 0\n      }), clearTimeout(this.$_disposeTimer);\n      const t = this.disposeTimeout;\n      t !== null && (this.$_disposeTimer = setTimeout(() => {\n        this.$_popperNode && (this.$_detachPopperNode(), this.isMounted = !1);\n      }, t)), this.$_removeEventListeners(\"scroll\"), this.$emit(\"apply-hide\"), this.classes.showFrom = !1, this.classes.showTo = !1, this.classes.hideFrom = !0, this.classes.hideTo = !1, await G(), this.classes.hideFrom = !1, this.classes.hideTo = !0;\n    },\n    $_autoShowHide() {\n      this.shown ? this.show() : this.hide();\n    },\n    $_ensureTeleport() {\n      if (this.isDisposed)\n        return;\n      let e = this.container;\n      if (typeof e == \"string\" ? e = window.document.querySelector(e) : e === !1 && (e = this.$_targetNodes[0].parentNode), !e)\n        throw new Error(\"No container for popover: \" + this.container);\n      e.appendChild(this.$_popperNode), this.isMounted = !0;\n    },\n    $_addEventListeners() {\n      const e = (o) => {\n        this.isShown && !this.$_hideInProgress || (o.usedByTooltip = !0, !this.$_preventShow && this.show({ event: o }));\n      };\n      this.$_registerTriggerListeners(this.$_targetNodes, pe, this.triggers, this.showTriggers, e), this.$_registerTriggerListeners([this.$_popperNode], pe, this.popperTriggers, this.popperShowTriggers, e);\n      const t = (o) => {\n        o.usedByTooltip || this.hide({ event: o });\n      };\n      this.$_registerTriggerListeners(this.$_targetNodes, ae, this.triggers, this.hideTriggers, t), this.$_registerTriggerListeners([this.$_popperNode], ae, this.popperTriggers, this.popperHideTriggers, t);\n    },\n    $_registerEventListeners(e, t, o) {\n      this.$_events.push({ targetNodes: e, eventType: t, handler: o }), e.forEach((i) => i.addEventListener(t, o, $ ? {\n        passive: !0\n      } : void 0));\n    },\n    $_registerTriggerListeners(e, t, o, i, s) {\n      let r = o;\n      i != null && (r = typeof i == \"function\" ? i(r) : i), r.forEach((p) => {\n        const a = t[p];\n        a && this.$_registerEventListeners(e, a, s);\n      });\n    },\n    $_removeEventListeners(e) {\n      const t = [];\n      this.$_events.forEach((o) => {\n        const { targetNodes: i, eventType: s, handler: r } = o;\n        !e || e === s ? i.forEach((p) => p.removeEventListener(s, r)) : t.push(o);\n      }), this.$_events = t;\n    },\n    $_refreshListeners() {\n      this.isDisposed || (this.$_removeEventListeners(), this.$_addEventListeners());\n    },\n    $_handleGlobalClose(e, t = !1) {\n      this.$_showFrameLocked || (this.hide({ event: e }), e.closePopover ? this.$emit(\"close-directive\") : this.$emit(\"auto-hide\"), t && (this.$_preventShow = !0, setTimeout(() => {\n        this.$_preventShow = !1;\n      }, 300)));\n    },\n    $_detachPopperNode() {\n      this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);\n    },\n    $_swapTargetAttrs(e, t) {\n      for (const o of this.$_targetNodes) {\n        const i = o.getAttribute(e);\n        i && (o.removeAttribute(e), o.setAttribute(t, i));\n      }\n    },\n    $_applyAttrsToTarget(e) {\n      for (const t of this.$_targetNodes)\n        for (const o in e) {\n          const i = e[o];\n          i == null ? t.removeAttribute(o) : t.setAttribute(o, i);\n        }\n    },\n    $_updateParentShownChildren(e) {\n      let t = this.parentPopper;\n      for (; t; )\n        e ? t.shownChildren.add(this.randomId) : (t.shownChildren.delete(this.randomId), t.pendingHide && t.hide()), t = t.parentPopper;\n    },\n    $_isAimingPopper() {\n      const e = this.$_referenceNode.getBoundingClientRect();\n      if (y >= e.left && y <= e.right && _ >= e.top && _ <= e.bottom) {\n        const t = this.$_popperNode.getBoundingClientRect(), o = y - c, i = _ - m, r = t.left + t.width / 2 - c + (t.top + t.height / 2) - m + t.width + t.height, p = c + o * r, a = m + i * r;\n        return C(c, m, p, a, t.left, t.top, t.left, t.bottom) || // Left edge\n        C(c, m, p, a, t.left, t.top, t.right, t.top) || // Top edge\n        C(c, m, p, a, t.right, t.top, t.right, t.bottom) || // Right edge\n        C(c, m, p, a, t.left, t.bottom, t.right, t.bottom);\n      }\n      return !1;\n    }\n  },\n  render() {\n    return this.$slots.default(this.slotData);\n  }\n});\nif (typeof document < \"u\" && typeof window < \"u\") {\n  if (_e) {\n    const e = $ ? {\n      passive: !0,\n      capture: !0\n    } : !0;\n    document.addEventListener(\"touchstart\", (t) => ue(t, !0), e), document.addEventListener(\"touchend\", (t) => fe(t, !0), e);\n  } else\n    window.addEventListener(\"mousedown\", (e) => ue(e, !1), !0), window.addEventListener(\"click\", (e) => fe(e, !1), !0);\n  window.addEventListener(\"resize\", tt);\n}\nfunction ue(e, t) {\n  if (h.autoHideOnMousedown)\n    Pe(e, t);\n  else\n    for (let o = 0; o < d.length; o++) {\n      const i = d[o];\n      try {\n        i.mouseDownContains = i.popperNode().contains(e.target);\n      } catch {\n      }\n    }\n}\nfunction fe(e, t) {\n  h.autoHideOnMousedown || Pe(e, t);\n}\nfunction Pe(e, t) {\n  const o = {};\n  for (let i = d.length - 1; i >= 0; i--) {\n    const s = d[i];\n    try {\n      const r = s.containsGlobalTarget = s.mouseDownContains || s.popperNode().contains(e.target);\n      s.pendingHide = !1, requestAnimationFrame(() => {\n        if (s.pendingHide = !1, !o[s.randomId] && ce(s, r, e)) {\n          if (s.$_handleGlobalClose(e, t), !e.closeAllPopover && e.closePopover && r) {\n            let a = s.parentPopper;\n            for (; a; )\n              o[a.randomId] = !0, a = a.parentPopper;\n            return;\n          }\n          let p = s.parentPopper;\n          for (; p && ce(p, p.containsGlobalTarget, e); ) {\n            p.$_handleGlobalClose(e, t);\n            p = p.parentPopper;\n          }\n        }\n      });\n    } catch {\n    }\n  }\n}\nfunction ce(e, t, o) {\n  return o.closeAllPopover || o.closePopover && t || et(e, o) && !t;\n}\nfunction et(e, t) {\n  if (typeof e.autoHide == \"function\") {\n    const o = e.autoHide(t);\n    return e.lastAutoHide = o, o;\n  }\n  return e.autoHide;\n}\nfunction tt() {\n  for (let e = 0; e < d.length; e++)\n    d[e].$_computePosition();\n}\nfunction Nt() {\n  for (let e = 0; e < d.length; e++)\n    d[e].hide();\n}\nlet c = 0, m = 0, y = 0, _ = 0;\ntypeof window < \"u\" && window.addEventListener(\"mousemove\", (e) => {\n  c = y, m = _, y = e.clientX, _ = e.clientY;\n}, $ ? {\n  passive: !0\n} : void 0);\nfunction C(e, t, o, i, s, r, p, a) {\n  const l = ((p - s) * (t - r) - (a - r) * (e - s)) / ((a - r) * (o - e) - (p - s) * (i - t)), u = ((o - e) * (t - r) - (i - t) * (e - s)) / ((a - r) * (o - e) - (p - s) * (i - t));\n  return l >= 0 && l <= 1 && u >= 0 && u <= 1;\n}\nconst ot = {\n  extends: Q()\n}, B = (e, t) => {\n  const o = e.__vccOpts || e;\n  for (const [i, s] of t)\n    o[i] = s;\n  return o;\n};\nfunction it(e, t, o, i, s, r) {\n  return f(), T(\"div\", {\n    ref: \"reference\",\n    class: J([\"v-popper\", {\n      \"v-popper--shown\": e.slotData.isShown\n    }])\n  }, [\n    A(e.$slots, \"default\", ke(Le(e.slotData)))\n  ], 2);\n}\nconst st = /* @__PURE__ */ B(ot, [[\"render\", it]]);\nfunction nt() {\n  var e = window.navigator.userAgent, t = e.indexOf(\"MSIE \");\n  if (t > 0)\n    return parseInt(e.substring(t + 5, e.indexOf(\".\", t)), 10);\n  var o = e.indexOf(\"Trident/\");\n  if (o > 0) {\n    var i = e.indexOf(\"rv:\");\n    return parseInt(e.substring(i + 3, e.indexOf(\".\", i)), 10);\n  }\n  var s = e.indexOf(\"Edge/\");\n  return s > 0 ? parseInt(e.substring(s + 5, e.indexOf(\".\", s)), 10) : -1;\n}\nlet z;\nfunction X() {\n  X.init || (X.init = !0, z = nt() !== -1);\n}\nvar E = {\n  name: \"ResizeObserver\",\n  props: {\n    emitOnMount: {\n      type: Boolean,\n      default: !1\n    },\n    ignoreWidth: {\n      type: Boolean,\n      default: !1\n    },\n    ignoreHeight: {\n      type: Boolean,\n      default: !1\n    }\n  },\n  emits: [\n    \"notify\"\n  ],\n  mounted() {\n    X(), Fe(() => {\n      this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitOnMount && this.emitSize();\n    });\n    const e = document.createElement(\"object\");\n    this._resizeObject = e, e.setAttribute(\"aria-hidden\", \"true\"), e.setAttribute(\"tabindex\", -1), e.onload = this.addResizeHandlers, e.type = \"text/html\", z && this.$el.appendChild(e), e.data = \"about:blank\", z || this.$el.appendChild(e);\n  },\n  beforeUnmount() {\n    this.removeResizeHandlers();\n  },\n  methods: {\n    compareAndNotify() {\n      (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) && (this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitSize());\n    },\n    emitSize() {\n      this.$emit(\"notify\", {\n        width: this._w,\n        height: this._h\n      });\n    },\n    addResizeHandlers() {\n      this._resizeObject.contentDocument.defaultView.addEventListener(\"resize\", this.compareAndNotify), this.compareAndNotify();\n    },\n    removeResizeHandlers() {\n      this._resizeObject && this._resizeObject.onload && (!z && this._resizeObject.contentDocument && this._resizeObject.contentDocument.defaultView.removeEventListener(\"resize\", this.compareAndNotify), this.$el.removeChild(this._resizeObject), this._resizeObject.onload = null, this._resizeObject = null);\n    }\n  }\n};\nconst rt = /* @__PURE__ */ Re(\"data-v-b329ee4c\");\nDe(\"data-v-b329ee4c\");\nconst pt = {\n  class: \"resize-observer\",\n  tabindex: \"-1\"\n};\nIe();\nconst at = /* @__PURE__ */ rt((e, t, o, i, s, r) => (f(), M(\"div\", pt)));\nE.render = at;\nE.__scopeId = \"data-v-b329ee4c\";\nE.__file = \"src/components/ResizeObserver.vue\";\nconst Z = (e = \"theme\") => ({\n  computed: {\n    themeClass() {\n      return Ze(this[e]);\n    }\n  }\n}), dt = O({\n  name: \"VPopperContent\",\n  components: {\n    ResizeObserver: E\n  },\n  mixins: [\n    Z()\n  ],\n  props: {\n    popperId: String,\n    theme: String,\n    shown: Boolean,\n    mounted: Boolean,\n    skipTransition: Boolean,\n    autoHide: Boolean,\n    handleResize: Boolean,\n    classes: Object,\n    result: Object\n  },\n  emits: [\n    \"hide\",\n    \"resize\"\n  ],\n  methods: {\n    toPx(e) {\n      return e != null && !isNaN(e) ? `${e}px` : null;\n    }\n  }\n}), lt = [\"id\", \"aria-hidden\", \"tabindex\", \"data-popper-placement\"], ht = {\n  ref: \"inner\",\n  class: \"v-popper__inner\"\n}, ut = /* @__PURE__ */ w(\"div\", { class: \"v-popper__arrow-outer\" }, null, -1), ft = /* @__PURE__ */ w(\"div\", { class: \"v-popper__arrow-inner\" }, null, -1), ct = [\n  ut,\n  ft\n];\nfunction mt(e, t, o, i, s, r) {\n  const p = P(\"ResizeObserver\");\n  return f(), T(\"div\", {\n    id: e.popperId,\n    ref: \"popover\",\n    class: J([\"v-popper__popper\", [\n      e.themeClass,\n      e.classes.popperClass,\n      {\n        \"v-popper__popper--shown\": e.shown,\n        \"v-popper__popper--hidden\": !e.shown,\n        \"v-popper__popper--show-from\": e.classes.showFrom,\n        \"v-popper__popper--show-to\": e.classes.showTo,\n        \"v-popper__popper--hide-from\": e.classes.hideFrom,\n        \"v-popper__popper--hide-to\": e.classes.hideTo,\n        \"v-popper__popper--skip-transition\": e.skipTransition,\n        \"v-popper__popper--arrow-overflow\": e.result && e.result.arrow.overflow,\n        \"v-popper__popper--no-positioning\": !e.result\n      }\n    ]]),\n    style: W(e.result ? {\n      position: e.result.strategy,\n      transform: `translate3d(${Math.round(e.result.x)}px,${Math.round(e.result.y)}px,0)`\n    } : void 0),\n    \"aria-hidden\": e.shown ? \"false\" : \"true\",\n    tabindex: e.autoHide ? 0 : void 0,\n    \"data-popper-placement\": e.result ? e.result.placement : void 0,\n    onKeyup: t[2] || (t[2] = je((a) => e.autoHide && e.$emit(\"hide\"), [\"esc\"]))\n  }, [\n    w(\"div\", {\n      class: \"v-popper__backdrop\",\n      onClick: t[0] || (t[0] = (a) => e.autoHide && e.$emit(\"hide\"))\n    }),\n    w(\"div\", {\n      class: \"v-popper__wrapper\",\n      style: W(e.result ? {\n        transformOrigin: e.result.transformOrigin\n      } : void 0)\n    }, [\n      w(\"div\", ht, [\n        e.mounted ? (f(), T(Ve, { key: 0 }, [\n          w(\"div\", null, [\n            A(e.$slots, \"default\")\n          ]),\n          e.handleResize ? (f(), M(p, {\n            key: 0,\n            onNotify: t[1] || (t[1] = (a) => e.$emit(\"resize\", a))\n          })) : se(\"\", !0)\n        ], 64)) : se(\"\", !0)\n      ], 512),\n      w(\"div\", {\n        ref: \"arrow\",\n        class: \"v-popper__arrow-container\",\n        style: W(e.result ? {\n          left: e.toPx(e.result.arrow.x),\n          top: e.toPx(e.result.arrow.y)\n        } : void 0)\n      }, ct, 4)\n    ], 4)\n  ], 46, lt);\n}\nconst ee = /* @__PURE__ */ B(dt, [[\"render\", mt]]), te = {\n  methods: {\n    show(...e) {\n      return this.$refs.popper.show(...e);\n    },\n    hide(...e) {\n      return this.$refs.popper.hide(...e);\n    },\n    dispose(...e) {\n      return this.$refs.popper.dispose(...e);\n    },\n    onResize(...e) {\n      return this.$refs.popper.onResize(...e);\n    }\n  }\n};\nlet K = function() {\n};\ntypeof window < \"u\" && (K = window.Element);\nconst gt = O({\n  name: \"VPopperWrapper\",\n  components: {\n    Popper: st,\n    PopperContent: ee\n  },\n  mixins: [\n    te,\n    Z(\"finalTheme\")\n  ],\n  props: {\n    theme: {\n      type: String,\n      default: null\n    },\n    referenceNode: {\n      type: Function,\n      default: null\n    },\n    shown: {\n      type: Boolean,\n      default: !1\n    },\n    showGroup: {\n      type: String,\n      default: null\n    },\n    // eslint-disable-next-line vue/require-prop-types\n    ariaId: {\n      default: null\n    },\n    disabled: {\n      type: Boolean,\n      default: void 0\n    },\n    positioningDisabled: {\n      type: Boolean,\n      default: void 0\n    },\n    placement: {\n      type: String,\n      default: void 0\n    },\n    delay: {\n      type: [String, Number, Object],\n      default: void 0\n    },\n    distance: {\n      type: [Number, String],\n      default: void 0\n    },\n    skidding: {\n      type: [Number, String],\n      default: void 0\n    },\n    triggers: {\n      type: Array,\n      default: void 0\n    },\n    showTriggers: {\n      type: [Array, Function],\n      default: void 0\n    },\n    hideTriggers: {\n      type: [Array, Function],\n      default: void 0\n    },\n    popperTriggers: {\n      type: Array,\n      default: void 0\n    },\n    popperShowTriggers: {\n      type: [Array, Function],\n      default: void 0\n    },\n    popperHideTriggers: {\n      type: [Array, Function],\n      default: void 0\n    },\n    container: {\n      type: [String, Object, K, Boolean],\n      default: void 0\n    },\n    boundary: {\n      type: [String, K],\n      default: void 0\n    },\n    strategy: {\n      type: String,\n      default: void 0\n    },\n    autoHide: {\n      type: [Boolean, Function],\n      default: void 0\n    },\n    handleResize: {\n      type: Boolean,\n      default: void 0\n    },\n    instantMove: {\n      type: Boolean,\n      default: void 0\n    },\n    eagerMount: {\n      type: Boolean,\n      default: void 0\n    },\n    popperClass: {\n      type: [String, Array, Object],\n      default: void 0\n    },\n    computeTransformOrigin: {\n      type: Boolean,\n      default: void 0\n    },\n    /**\n     * @deprecated\n     */\n    autoMinSize: {\n      type: Boolean,\n      default: void 0\n    },\n    autoSize: {\n      type: [Boolean, String],\n      default: void 0\n    },\n    /**\n     * @deprecated\n     */\n    autoMaxSize: {\n      type: Boolean,\n      default: void 0\n    },\n    autoBoundaryMaxSize: {\n      type: Boolean,\n      default: void 0\n    },\n    preventOverflow: {\n      type: Boolean,\n      default: void 0\n    },\n    overflowPadding: {\n      type: [Number, String],\n      default: void 0\n    },\n    arrowPadding: {\n      type: [Number, String],\n      default: void 0\n    },\n    arrowOverflow: {\n      type: Boolean,\n      default: void 0\n    },\n    flip: {\n      type: Boolean,\n      default: void 0\n    },\n    shift: {\n      type: Boolean,\n      default: void 0\n    },\n    shiftCrossAxis: {\n      type: Boolean,\n      default: void 0\n    },\n    noAutoFocus: {\n      type: Boolean,\n      default: void 0\n    },\n    disposeTimeout: {\n      type: Number,\n      default: void 0\n    }\n  },\n  emits: {\n    show: () => !0,\n    hide: () => !0,\n    \"update:shown\": (e) => !0,\n    \"apply-show\": () => !0,\n    \"apply-hide\": () => !0,\n    \"close-group\": () => !0,\n    \"close-directive\": () => !0,\n    \"auto-hide\": () => !0,\n    resize: () => !0\n  },\n  computed: {\n    finalTheme() {\n      return this.theme ?? this.$options.vPopperTheme;\n    }\n  },\n  methods: {\n    getTargetNodes() {\n      return Array.from(this.$el.children).filter((e) => e !== this.$refs.popperContent.$el);\n    }\n  }\n});\nfunction wt(e, t, o, i, s, r) {\n  const p = P(\"PopperContent\"), a = P(\"Popper\");\n  return f(), M(a, $e({ ref: \"popper\" }, e.$props, {\n    theme: e.finalTheme,\n    \"target-nodes\": e.getTargetNodes,\n    \"popper-node\": () => e.$refs.popperContent.$el,\n    class: [\n      e.themeClass\n    ],\n    onShow: t[0] || (t[0] = () => e.$emit(\"show\")),\n    onHide: t[1] || (t[1] = () => e.$emit(\"hide\")),\n    \"onUpdate:shown\": t[2] || (t[2] = (l) => e.$emit(\"update:shown\", l)),\n    onApplyShow: t[3] || (t[3] = () => e.$emit(\"apply-show\")),\n    onApplyHide: t[4] || (t[4] = () => e.$emit(\"apply-hide\")),\n    onCloseGroup: t[5] || (t[5] = () => e.$emit(\"close-group\")),\n    onCloseDirective: t[6] || (t[6] = () => e.$emit(\"close-directive\")),\n    onAutoHide: t[7] || (t[7] = () => e.$emit(\"auto-hide\")),\n    onResize: t[8] || (t[8] = () => e.$emit(\"resize\"))\n  }), {\n    default: N(({\n      popperId: l,\n      isShown: u,\n      shouldMountContent: L,\n      skipTransition: D,\n      autoHide: I,\n      show: F,\n      hide: v,\n      handleResize: R,\n      onResize: j,\n      classes: V,\n      result: Ee\n    }) => [\n      A(e.$slots, \"default\", {\n        shown: u,\n        show: F,\n        hide: v\n      }),\n      ve(p, {\n        ref: \"popperContent\",\n        \"popper-id\": l,\n        theme: e.finalTheme,\n        shown: u,\n        mounted: L,\n        \"skip-transition\": D,\n        \"auto-hide\": I,\n        \"handle-resize\": R,\n        classes: V,\n        result: Ee,\n        onHide: v,\n        onResize: j\n      }, {\n        default: N(() => [\n          A(e.$slots, \"popper\", {\n            shown: u,\n            hide: v\n          })\n        ]),\n        _: 2\n      }, 1032, [\"popper-id\", \"theme\", \"shown\", \"mounted\", \"skip-transition\", \"auto-hide\", \"handle-resize\", \"classes\", \"result\", \"onHide\", \"onResize\"])\n    ]),\n    _: 3\n  }, 16, [\"theme\", \"target-nodes\", \"popper-node\", \"class\"]);\n}\nconst k = /* @__PURE__ */ B(gt, [[\"render\", wt]]), Se = {\n  ...k,\n  name: \"VDropdown\",\n  vPopperTheme: \"dropdown\"\n}, be = {\n  ...k,\n  name: \"VMenu\",\n  vPopperTheme: \"menu\"\n}, Ce = {\n  ...k,\n  name: \"VTooltip\",\n  vPopperTheme: \"tooltip\"\n}, $t = O({\n  name: \"VTooltipDirective\",\n  components: {\n    Popper: Q(),\n    PopperContent: ee\n  },\n  mixins: [\n    te\n  ],\n  inheritAttrs: !1,\n  props: {\n    theme: {\n      type: String,\n      default: \"tooltip\"\n    },\n    html: {\n      type: Boolean,\n      default: (e) => S(e.theme, \"html\")\n    },\n    content: {\n      type: [String, Number, Function],\n      default: null\n    },\n    loadingContent: {\n      type: String,\n      default: (e) => S(e.theme, \"loadingContent\")\n    },\n    targetNodes: {\n      type: Function,\n      required: !0\n    }\n  },\n  data() {\n    return {\n      asyncContent: null\n    };\n  },\n  computed: {\n    isContentAsync() {\n      return typeof this.content == \"function\";\n    },\n    loading() {\n      return this.isContentAsync && this.asyncContent == null;\n    },\n    finalContent() {\n      return this.isContentAsync ? this.loading ? this.loadingContent : this.asyncContent : this.content;\n    }\n  },\n  watch: {\n    content: {\n      handler() {\n        this.fetchContent(!0);\n      },\n      immediate: !0\n    },\n    async finalContent() {\n      await this.$nextTick(), this.$refs.popper.onResize();\n    }\n  },\n  created() {\n    this.$_fetchId = 0;\n  },\n  methods: {\n    fetchContent(e) {\n      if (typeof this.content == \"function\" && this.$_isShown && (e || !this.$_loading && this.asyncContent == null)) {\n        this.asyncContent = null, this.$_loading = !0;\n        const t = ++this.$_fetchId, o = this.content(this);\n        o.then ? o.then((i) => this.onResult(t, i)) : this.onResult(t, o);\n      }\n    },\n    onResult(e, t) {\n      e === this.$_fetchId && (this.$_loading = !1, this.asyncContent = t);\n    },\n    onShow() {\n      this.$_isShown = !0, this.fetchContent();\n    },\n    onHide() {\n      this.$_isShown = !1;\n    }\n  }\n}), vt = [\"innerHTML\"], yt = [\"textContent\"];\nfunction _t(e, t, o, i, s, r) {\n  const p = P(\"PopperContent\"), a = P(\"Popper\");\n  return f(), M(a, $e({ ref: \"popper\" }, e.$attrs, {\n    theme: e.theme,\n    \"target-nodes\": e.targetNodes,\n    \"popper-node\": () => e.$refs.popperContent.$el,\n    onApplyShow: e.onShow,\n    onApplyHide: e.onHide\n  }), {\n    default: N(({\n      popperId: l,\n      isShown: u,\n      shouldMountContent: L,\n      skipTransition: D,\n      autoHide: I,\n      hide: F,\n      handleResize: v,\n      onResize: R,\n      classes: j,\n      result: V\n    }) => [\n      ve(p, {\n        ref: \"popperContent\",\n        class: J({\n          \"v-popper--tooltip-loading\": e.loading\n        }),\n        \"popper-id\": l,\n        theme: e.theme,\n        shown: u,\n        mounted: L,\n        \"skip-transition\": D,\n        \"auto-hide\": I,\n        \"handle-resize\": v,\n        classes: j,\n        result: V,\n        onHide: F,\n        onResize: R\n      }, {\n        default: N(() => [\n          e.html ? (f(), T(\"div\", {\n            key: 0,\n            innerHTML: e.finalContent\n          }, null, 8, vt)) : (f(), T(\"div\", {\n            key: 1,\n            textContent: We(e.finalContent)\n          }, null, 8, yt))\n        ]),\n        _: 2\n      }, 1032, [\"class\", \"popper-id\", \"theme\", \"shown\", \"mounted\", \"skip-transition\", \"auto-hide\", \"handle-resize\", \"classes\", \"result\", \"onHide\", \"onResize\"])\n    ]),\n    _: 1\n  }, 16, [\"theme\", \"target-nodes\", \"popper-node\", \"onApplyShow\", \"onApplyHide\"]);\n}\nconst ze = /* @__PURE__ */ B($t, [[\"render\", _t]]), Ae = \"v-popper--has-tooltip\";\nfunction Tt(e, t) {\n  let o = e.placement;\n  if (!o && t)\n    for (const i of Te)\n      t[i] && (o = i);\n  return o || (o = S(e.theme || \"tooltip\", \"placement\")), o;\n}\nfunction Ne(e, t, o) {\n  let i;\n  const s = typeof t;\n  return s === \"string\" ? i = { content: t } : t && s === \"object\" ? i = t : i = { content: !1 }, i.placement = Tt(i, o), i.targetNodes = () => [e], i.referenceNode = () => e, i;\n}\nlet x, b, Pt = 0;\nfunction St() {\n  if (x)\n    return;\n  b = U([]), x = Ge({\n    name: \"VTooltipDirectiveApp\",\n    setup() {\n      return {\n        directives: b\n      };\n    },\n    render() {\n      return this.directives.map((t) => qe(ze, {\n        ...t.options,\n        shown: t.shown || t.options.shown,\n        key: t.id\n      }));\n    },\n    devtools: {\n      hide: !0\n    }\n  });\n  const e = document.createElement(\"div\");\n  document.body.appendChild(e), x.mount(e);\n}\nfunction bt(e, t, o) {\n  St();\n  const i = U(Ne(e, t, o)), s = U(!1), r = {\n    id: Pt++,\n    options: i,\n    shown: s\n  };\n  return b.value.push(r), e.classList && e.classList.add(Ae), e.$_popper = {\n    options: i,\n    item: r,\n    show() {\n      s.value = !0;\n    },\n    hide() {\n      s.value = !1;\n    }\n  };\n}\nfunction He(e) {\n  if (e.$_popper) {\n    const t = b.value.indexOf(e.$_popper.item);\n    t !== -1 && b.value.splice(t, 1), delete e.$_popper, delete e.$_popperOldShown, delete e.$_popperMountTarget;\n  }\n  e.classList && e.classList.remove(Ae);\n}\nfunction me(e, { value: t, modifiers: o }) {\n  const i = Ne(e, t, o);\n  if (!i.content || S(i.theme || \"tooltip\", \"disabled\"))\n    He(e);\n  else {\n    let s;\n    e.$_popper ? (s = e.$_popper, s.options.value = i) : s = bt(e, t, o), typeof t.shown < \"u\" && t.shown !== e.$_popperOldShown && (e.$_popperOldShown = t.shown, t.shown ? s.show() : s.hide());\n  }\n}\nconst oe = {\n  beforeMount: me,\n  updated: me,\n  beforeUnmount(e) {\n    He(e);\n  }\n};\nfunction ge(e) {\n  e.addEventListener(\"mousedown\", H), e.addEventListener(\"click\", H), e.addEventListener(\"touchstart\", Oe, $ ? {\n    passive: !0\n  } : !1);\n}\nfunction we(e) {\n  e.removeEventListener(\"mousedown\", H), e.removeEventListener(\"click\", H), e.removeEventListener(\"touchstart\", Oe), e.removeEventListener(\"touchend\", Me), e.removeEventListener(\"touchcancel\", Be);\n}\nfunction H(e) {\n  const t = e.currentTarget;\n  e.closePopover = !t.$_vclosepopover_touch, e.closeAllPopover = t.$_closePopoverModifiers && !!t.$_closePopoverModifiers.all;\n}\nfunction Oe(e) {\n  if (e.changedTouches.length === 1) {\n    const t = e.currentTarget;\n    t.$_vclosepopover_touch = !0;\n    const o = e.changedTouches[0];\n    t.$_vclosepopover_touchPoint = o, t.addEventListener(\"touchend\", Me), t.addEventListener(\"touchcancel\", Be);\n  }\n}\nfunction Me(e) {\n  const t = e.currentTarget;\n  if (t.$_vclosepopover_touch = !1, e.changedTouches.length === 1) {\n    const o = e.changedTouches[0], i = t.$_vclosepopover_touchPoint;\n    e.closePopover = Math.abs(o.screenY - i.screenY) < 20 && Math.abs(o.screenX - i.screenX) < 20, e.closeAllPopover = t.$_closePopoverModifiers && !!t.$_closePopoverModifiers.all;\n  }\n}\nfunction Be(e) {\n  const t = e.currentTarget;\n  t.$_vclosepopover_touch = !1;\n}\nconst ie = {\n  beforeMount(e, { value: t, modifiers: o }) {\n    e.$_closePopoverModifiers = o, (typeof t > \"u\" || t) && ge(e);\n  },\n  updated(e, { value: t, oldValue: o, modifiers: i }) {\n    e.$_closePopoverModifiers = i, t !== o && (typeof t > \"u\" || t ? ge(e) : we(e));\n  },\n  beforeUnmount(e) {\n    we(e);\n  }\n}, Ht = h, Ot = oe, Mt = oe, Bt = ie, Et = ie, kt = Se, Lt = be, Dt = Q, It = ee, Ft = te, Rt = k, jt = Z, Vt = Ce, Wt = ze;\nfunction Ct(e, t = {}) {\n  e.$_vTooltipInstalled || (e.$_vTooltipInstalled = !0, ye(h, t), e.directive(\"tooltip\", oe), e.directive(\"close-popper\", ie), e.component(\"VTooltip\", Ce), e.component(\"VDropdown\", Se), e.component(\"VMenu\", be));\n}\nconst Gt = {\n  // eslint-disable-next-line no-undef\n  version: \"5.2.2\",\n  install: Ct,\n  options: h\n};\nexport {\n  kt as Dropdown,\n  ae as HIDE_EVENT_MAP,\n  Lt as Menu,\n  Dt as Popper,\n  It as PopperContent,\n  Ft as PopperMethods,\n  Rt as PopperWrapper,\n  pe as SHOW_EVENT_MAP,\n  jt as ThemeClass,\n  Vt as Tooltip,\n  Wt as TooltipDirective,\n  Bt as VClosePopper,\n  Ot as VTooltip,\n  bt as createTooltip,\n  Gt as default,\n  He as destroyTooltip,\n  Nt as hideAllPoppers,\n  Ct as install,\n  Ht as options,\n  Te as placements,\n  tt as recomputeAllPoppers,\n  Et as vClosePopper,\n  Mt as vTooltip\n};\n","/*!\n* tabbable 6.4.0\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\n// NOTE: separate `:not()` selectors has broader browser support than the newer\n//  `:not([inert], [inert] *)` (Feb 2023)\nvar candidateSelectors = ['input:not([inert]):not([inert] *)', 'select:not([inert]):not([inert] *)', 'textarea:not([inert]):not([inert] *)', 'a[href]:not([inert]):not([inert] *)', 'button:not([inert]):not([inert] *)', '[tabindex]:not(slot):not([inert]):not([inert] *)', 'audio[controls]:not([inert]):not([inert] *)', 'video[controls]:not([inert]):not([inert] *)', '[contenteditable]:not([contenteditable=\"false\"]):not([inert]):not([inert] *)', 'details>summary:first-of-type:not([inert]):not([inert] *)', 'details:not([inert]):not([inert] *)'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  var _element$getRootNode;\n  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);\n} : function (element) {\n  return element === null || element === void 0 ? void 0 : element.ownerDocument;\n};\n\n/**\n * Determines if a node is inert or in an inert ancestor.\n * @param {Node} [node]\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\n *  see if any of them are inert. If false, only `node` itself is considered.\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\n *  False if `node` is falsy.\n */\nvar _isInert = function isInert(node, lookUp) {\n  var _node$getAttribute;\n  if (lookUp === void 0) {\n    lookUp = true;\n  }\n  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\n  //  JS API property; we have to check the attribute, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's an active element\n  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');\n  var inert = inertAtt === '' || inertAtt === 'true';\n\n  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\n  //  if it weren't for `matches()` not being a function on shadow roots; the following\n  //  code works for any kind of node\n  var result = inert || lookUp && node && (\n  // closest does not exist on shadow roots, so we fall back to a manual\n  // lookup upward, in case it is not defined.\n  typeof node.closest === 'function' ? node.closest('[inert]') : _isInert(node.parentNode));\n  return result;\n};\n\n/**\n * Determines if a node's content is editable.\n * @param {Element} [node]\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\n */\nvar isContentEditable = function isContentEditable(node) {\n  var _node$getAttribute2;\n  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\n  //  to use the attribute directly to check for this, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's a non-editable element\n  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');\n  return attValue === '' || attValue === 'true';\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  // even if `includeContainer=false`, we still have to check it for inertness because\n  //  if it's inert (either by itself or via its parent), then all its children are inert\n  if (_isInert(el)) {\n    return [];\n  }\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nvar _getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n    if (_isInert(element, false)) {\n      // no need to look up since we're drilling down\n      // anything inside this container will also be inert\n      continue;\n    }\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = _getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      var shadowRoot = element.shadowRoot ||\n      // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n\n      // no inert look up because we're already drilling down and checking for inertness\n      //  on the way down, so all containers to this root node should have already been\n      //  vetted as non-inert\n      var validShadowRoot = !_isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = _getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\n/**\n * @private\n * Determines if the node has an explicitly specified `tabindex` attribute.\n * @param {HTMLElement} node\n * @returns {boolean} True if so; false if not.\n */\nvar hasTabIndex = function hasTabIndex(node) {\n  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\n};\n\n/**\n * Determine the tab index of a given node.\n * @param {HTMLElement} node\n * @returns {number} Tab order (negative, 0, or positive number).\n * @throws {Error} If `node` is falsy.\n */\nvar getTabIndex = function getTabIndex(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n};\n\n/**\n * Determine the tab index of a given node __for sort order purposes__.\n * @param {HTMLElement} node\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\n *  inserted into the correct sort position.\n * @returns {number} Tab order (negative, 0, or positive number).\n */\nvar getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {\n  var tabIndex = getTabIndex(node);\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n    return 0;\n  }\n  return tabIndex;\n};\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  var radioScope = node.form || getRootNode(node);\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n  var radioSet;\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nvar isNodeAttached = function isNodeAttached(node) {\n  var _nodeRoot;\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\n  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\n  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\n  //  `ownerDocument` will be `null`, hence the optional chaining on it.\n  var nodeRoot = node && getRootNode(node);\n  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;\n\n  // in some cases, a detached node will return itself as the root instead of a document or\n  //  shadow root object, in which case, we shouldn't try to look further up the host chain\n  var attached = false;\n  if (nodeRoot && nodeRoot !== node) {\n    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;\n    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));\n    while (!attached && nodeRootHost) {\n      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n      //  which means we need to get the host's host and check if that parent host is contained\n      //  in (i.e. attached to) the document\n      nodeRoot = getRootNode(nodeRootHost);\n      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;\n      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));\n    }\n  }\n  return attached;\n};\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    width = _node$getBoundingClie.width,\n    height = _node$getBoundingClie.height;\n  return width === 0 && height === 0;\n};\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n    getShadowRoot = _ref.getShadowRoot;\n  if (displayCheck === 'full-native') {\n    if ('checkVisibility' in node) {\n      // Chrome >= 105, Edge >= 105, Firefox >= 106, Safari >= 17.4\n      // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/checkVisibility#browser_compatibility\n      var visible = node.checkVisibility({\n        // Checking opacity might be desirable for some use cases, but natively,\n        // opacity zero elements _are_ focusable and tabbable.\n        checkOpacity: false,\n        opacityProperty: false,\n        contentVisibilityAuto: true,\n        visibilityProperty: true,\n        // This is an alias for `visibilityProperty`. Contemporary browsers\n        // support both. However, this alias has wider browser support (Chrome\n        // >= 105 and Firefox >= 106, vs. Chrome >= 121 and Firefox >= 122), so\n        // we include it anyway.\n        checkVisibilityCSS: true\n      });\n      return !visible;\n    }\n    // Fall through to manual visibility checks\n  }\n\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full' ||\n  // full-native can run this branch when it falls through in case\n  // Element#checkVisibility is unsupported\n  displayCheck === 'full-native' || displayCheck === 'legacy-full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options) ||\n  // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n  return true;\n};\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n  return true;\n};\nvar isShadowRootTabbable = function isShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nvar _sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scopeParent;\n    var element = isScope ? item.scopeParent : item;\n    var candidateTabindex = getSortOrderTabIndex(element, isScope);\n    var elements = isScope ? _sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\nvar tabbable = function tabbable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = _getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n  return _sortByOrder(candidates);\n};\nvar focusable = function focusable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = _getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n  return candidates;\n};\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe:not([inert]):not([inert] *)').join(',');\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, getTabIndex, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","/*!\n* focus-trap 8.0.0\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { isFocusable, tabbable, focusable, isTabbable, getTabIndex } from 'tabbable';\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) {\n  try {\n    var i = n[a](c),\n      u = i.value;\n  } catch (n) {\n    return void e(n);\n  }\n  i.done ? t(u) : Promise.resolve(u).then(r, o);\n}\nfunction _asyncToGenerator(n) {\n  return function () {\n    var t = this,\n      e = arguments;\n    return new Promise(function (r, o) {\n      var a = n.apply(t, e);\n      function _next(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n);\n      }\n      function _throw(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n);\n      }\n      _next(void 0);\n    });\n  };\n}\nfunction _createForOfIteratorHelper(r, e) {\n  var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (!t) {\n    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {\n      t && (r = t);\n      var n = 0,\n        F = function () {};\n      return {\n        s: F,\n        n: function () {\n          return n >= r.length ? {\n            done: true\n          } : {\n            done: false,\n            value: r[n++]\n          };\n        },\n        e: function (r) {\n          throw r;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var o,\n    a = true,\n    u = false;\n  return {\n    s: function () {\n      t = t.call(r);\n    },\n    n: function () {\n      var r = t.next();\n      return a = r.done, r;\n    },\n    e: function (r) {\n      u = true, o = r;\n    },\n    f: function () {\n      try {\n        a || null == t.return || t.return();\n      } finally {\n        if (u) throw o;\n      }\n    }\n  };\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  }) : e[r] = t, e;\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), true).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _regenerator() {\n  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */\n  var e,\n    t,\n    r = \"function\" == typeof Symbol ? Symbol : {},\n    n = r.iterator || \"@@iterator\",\n    o = r.toStringTag || \"@@toStringTag\";\n  function i(r, n, o, i) {\n    var c = n && n.prototype instanceof Generator ? n : Generator,\n      u = Object.create(c.prototype);\n    return _regeneratorDefine(u, \"_invoke\", function (r, n, o) {\n      var i,\n        c,\n        u,\n        f = 0,\n        p = o || [],\n        y = false,\n        G = {\n          p: 0,\n          n: 0,\n          v: e,\n          a: d,\n          f: d.bind(e, 4),\n          d: function (t, r) {\n            return i = t, c = 0, u = e, G.n = r, a;\n          }\n        };\n      function d(r, n) {\n        for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {\n          var o,\n            i = p[t],\n            d = G.p,\n            l = i[2];\n          r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));\n        }\n        if (o || r > 1) return a;\n        throw y = true, n;\n      }\n      return function (o, p, l) {\n        if (f > 1) throw TypeError(\"Generator is already running\");\n        for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {\n          i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);\n          try {\n            if (f = 2, i) {\n              if (c || (o = \"next\"), t = i[o]) {\n                if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\");\n                if (!t.done) return t;\n                u = t.value, c < 2 && (c = 0);\n              } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1);\n              i = e;\n            } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;\n          } catch (t) {\n            i = e, c = 1, u = t;\n          } finally {\n            f = 1;\n          }\n        }\n        return {\n          value: t,\n          done: y\n        };\n      };\n    }(r, o, i), true), u;\n  }\n  var a = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  t = Object.getPrototypeOf;\n  var c = [][n] ? t(t([][n]())) : (_regeneratorDefine(t = {}, n, function () {\n      return this;\n    }), t),\n    u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);\n  function f(e) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e;\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine(u), _regeneratorDefine(u, o, \"Generator\"), _regeneratorDefine(u, n, function () {\n    return this;\n  }), _regeneratorDefine(u, \"toString\", function () {\n    return \"[object Generator]\";\n  }), (_regenerator = function () {\n    return {\n      w: i,\n      m: f\n    };\n  })();\n}\nfunction _regeneratorDefine(e, r, n, t) {\n  var i = Object.defineProperty;\n  try {\n    i({}, \"\", {});\n  } catch (e) {\n    i = 0;\n  }\n  _regeneratorDefine = function (e, r, n, t) {\n    function o(r, n) {\n      _regeneratorDefine(e, r, function (e) {\n        return this._invoke(r, n, e);\n      });\n    }\n    r ? i ? i(e, r, {\n      value: n,\n      enumerable: !t,\n      configurable: !t,\n      writable: !t\n    }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2));\n  }, _regeneratorDefine(e, r, n, t);\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r);\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nvar activeFocusTraps = {\n  // Returns the trap from the top of the stack.\n  getActiveTrap: function getActiveTrap(trapStack) {\n    if ((trapStack === null || trapStack === void 0 ? void 0 : trapStack.length) > 0) {\n      return trapStack[trapStack.length - 1];\n    }\n    return null;\n  },\n  // Pauses the currently active trap, then adds a new trap to the stack.\n  activateTrap: function activateTrap(trapStack, trap) {\n    var activeTrap = activeFocusTraps.getActiveTrap(trapStack);\n    if (trap !== activeTrap) {\n      activeFocusTraps.pauseTrap(trapStack);\n    }\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  // Removes the trap from the top of the stack, then unpauses the next trap down.\n  deactivateTrap: function deactivateTrap(trapStack, trap) {\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    activeFocusTraps.unpauseTrap(trapStack);\n  },\n  // Pauses the trap at the top of the stack.\n  pauseTrap: function pauseTrap(trapStack) {\n    var activeTrap = activeFocusTraps.getActiveTrap(trapStack);\n    activeTrap === null || activeTrap === void 0 || activeTrap._setPausedState(true);\n  },\n  // Unpauses the trap at the top of the stack.\n  unpauseTrap: function unpauseTrap(trapStack) {\n    var activeTrap = activeFocusTraps.getActiveTrap(trapStack);\n    if (activeTrap && !activeTrap._isManuallyPaused()) {\n      activeTrap._setPausedState(false);\n    }\n  }\n};\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Escape' || (e === null || e === void 0 ? void 0 : e.key) === 'Esc' || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Tab' || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;\n};\n\n// checks for TAB by default\nvar isKeyForward = function isKeyForward(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nvar isKeyBackward = function isKeyBackward(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nvar internalTrapStack = [];\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isolateSubtrees: false,\n    isKeyForward: isKeyForward,\n    isKeyBackward: isKeyBackward\n  }, userOptions);\n  var state = {\n    // containers given to createFocusTrap()\n    /** @type {Array<HTMLElement>} */\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    /** @type {Array<{\n     *    container: HTMLElement,\n     *    tabbableNodes: Array<HTMLElement>, // empty if none\n     *    focusableNodes: Array<HTMLElement>, // empty if none\n     *    posTabIndexesFound: boolean,\n     *    firstTabbableNode: HTMLElement|undefined,\n     *    lastTabbableNode: HTMLElement|undefined,\n     *    firstDomTabbableNode: HTMLElement|undefined,\n     *    lastDomTabbableNode: HTMLElement|undefined,\n     *    nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n     *  }>}\n     */\n    containerGroups: [],\n    // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    // references to nodes that are siblings to the ancestors of this trap's containers.\n    /** @type {Set<HTMLElement>} */\n    adjacentElements: new Set(),\n    // references to nodes that were inert or aria-hidden before the trap was activated.\n    /** @type {Set<HTMLElement>} */\n    alreadySilent: new Set(),\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    manuallyPaused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any\n    recentNavEvent: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @param {Event} [event] If available, and `element` isn't directly found in any container,\n   *  the event's composed path is used to see if includes any known trap containers in the\n   *  case where the element is inside a Shadow DOM.\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  var findContainerIndex = function findContainerIndex(element, event) {\n    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n        tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || (// fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @param {Object} options\n   * @param {boolean} [options.hasFallback] True if the option could be a selector string\n   *  and the option allows for a fallback scenario in the case where the selector is\n   *  valid but does not match a node (i.e. the queried node doesn't exist in the DOM).\n   * @param {Array} [options.params] Params to pass to the option if it's a function.\n   * @returns {undefined | null | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `null` if the option didn't resolve\n   *  to a node but `options.hasFallback=true`, `false` if the option resolved to `false`\n   *  (node explicitly not given); otherwise, the resolved DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node, unless the option is a selector string and `options.hasFallback=true`.\n   */\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$hasFallback = _ref2.hasFallback,\n      hasFallback = _ref2$hasFallback === void 0 ? false : _ref2$hasFallback,\n      _ref2$params = _ref2.params,\n      params = _ref2$params === void 0 ? [] : _ref2$params;\n    var optionValue = config[optionName];\n    if (typeof optionValue === 'function') {\n      optionValue = optionValue.apply(void 0, _toConsumableArray(params));\n    }\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      try {\n        node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      } catch (err) {\n        throw new Error(\"`\".concat(optionName, \"` appears to be an invalid selector; error=\\\"\").concat(err.message, \"\\\"\"));\n      }\n      if (!node) {\n        if (!hasFallback) {\n          throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n        }\n        // else, `node` MUST be `null` because that's what `Document.querySelector()` returns\n        //  if the selector is valid but doesn't match anything\n      }\n    }\n    return node;\n  };\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus', {\n      hasFallback: true\n    });\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n    if (node === undefined || node && !isFocusable(node, config.tabbableOptions)) {\n      // option not specified nor focusable: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    } else if (node === null) {\n      // option is a VALID selector string that doesn't yield a node: use the `fallbackFocus`\n      //  option instead of the default behavior when the option isn't specified at all\n      node = getNodeForOption('fallbackFocus');\n    }\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n    return node;\n  };\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes\n      //  are focusable but not tabbable\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;\n      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;\n      var firstDomTabbableNode = focusableNodes.find(function (node) {\n        return isTabbable(node);\n      });\n      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function (node) {\n        return isTabbable(node);\n      });\n      var posTabIndexesFound = !!tabbableNodes.find(function (node) {\n        return getTabIndex(node) > 0;\n      });\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        /** True if at least one node with positive `tabindex` was found in this container. */\n        posTabIndexesFound: posTabIndexesFound,\n        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */\n        firstTabbableNode: firstTabbableNode,\n        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */\n        lastTabbableNode: lastTabbableNode,\n        // NOTE: DOM order is NOT NECESSARILY \"document position\" order, but figuring that out\n        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        //  because that API doesn't work with Shadow DOM as well as it should (@see\n        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,\n        //  to address an edge case related to positive tabindex support, this seems like a much easier,\n        //  \"close enough most of the time\" alternative for positive tabindexes which should generally\n        //  be avoided anyway...\n        /** First tabbable node in container, __DOM__ order; `undefined` if none. */\n        firstDomTabbableNode: firstDomTabbableNode,\n        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */\n        lastDomTabbableNode: lastDomTabbableNode,\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          var nodeIdx = tabbableNodes.indexOf(node);\n          if (nodeIdx < 0) {\n            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):\n            //  since `node` should at least have been focusable, we assume that's the case and mimic\n            //  what browsers do, which is set focus to the next node in __document position order__,\n            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE\n            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to\n            //  basic DOM order\n            if (forward) {\n              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function (el) {\n                return isTabbable(el);\n              });\n            }\n            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function (el) {\n              return isTabbable(el);\n            });\n          }\n          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    });\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n\n    // NOTE: Positive tabindexes are only properly supported in single-container traps because\n    //  doing it across multiple containers where tabindexes could be all over the place\n    //  would require Tabbable to support multiple containers, would require additional\n    //  specialized Shadow DOM support, and would require Tabbable's multi-container support\n    //  to look at those containers in document position order rather than user-provided\n    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on\n    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.\n    if (state.containerGroups.find(function (g) {\n      return g.posTabIndexesFound;\n    }) && state.containerGroups.length > 1) {\n      throw new Error(\"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\");\n    }\n  };\n\n  /**\n   * Gets the current activeElement. If it's a web-component and has open shadow-root\n   * it will recursively search inside shadow roots for the \"true\" activeElement.\n   *\n   * @param {Document | ShadowRoot} el\n   *\n   * @returns {HTMLElement} The element that currently has the focus\n   **/\n  var _getActiveElement = function getActiveElement(el) {\n    var activeElement = el.activeElement;\n    if (!activeElement) {\n      return;\n    }\n    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {\n      return _getActiveElement(activeElement.shadowRoot);\n    }\n    return activeElement;\n  };\n  var _tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n    if (node === _getActiveElement(document)) {\n      return;\n    }\n    if (!node || !node.focus) {\n      _tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    // NOTE: focus() API does not trigger focusIn event so set MRU node manually\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', {\n      params: [previousActiveElement]\n    });\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  /**\n   * Finds the next node (in either direction) where focus should move according to a\n   *  keyboard focus-in event.\n   * @param {Object} params\n   * @param {Node} [params.target] Known target __from which__ to navigate, if any.\n   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event\n   *  will be used to determine the `target`). Ignored if `target` is specified.\n   * @param {boolean} [params.isBackward] True if focus should move backward.\n   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be\n   *  determined given the current state of the trap.\n   */\n  var findNextNavNode = function findNextNavNode(_ref3) {\n    var target = _ref3.target,\n      event = _ref3.event,\n      _ref3$isBackward = _ref3.isBackward,\n      isBackward = _ref3$isBackward === void 0 ? false : _ref3$isBackward;\n    target = target || getActualTarget(event);\n    updateTabbableNodes();\n    var destinationNode = null;\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target, event);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = state.tabbableGroups.findIndex(function (_ref4) {\n          var firstTabbableNode = _ref4.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = state.tabbableGroups.findIndex(function (_ref5) {\n          var lastTabbableNode = _ref5.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n    return destinationNode;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      // allow the click since it occurred inside the trap\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked (and if not focusable, to \"nothing\"); by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node), whether the\n        //  outside click was on a focusable node or not\n        returnFocus: config.returnFocusOnDeactivate\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected\n  //  scrolling if the node that got focused was out of view; there's nothing we can do to\n  //  prevent that from happening by the time we discover that focus escaped\n  var checkFocusIn = function checkFocusIn(event) {\n    var target = getActualTarget(event);\n    var targetContained = findContainerIndex(target, event) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      event.stopImmediatePropagation();\n\n      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;\n      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward\n      //  toward a node with a positive tab index\n      var nextNode; // next node to focus, if we find one\n      var navAcrossContainers = true;\n      if (state.mostRecentlyFocusedNode) {\n        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {\n          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...\n          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);\n          // there MAY not be any tabbable nodes in the container if there are at least 2 containers\n          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container\n          //  with at least one tabbable node in order to function, so this could be the other container\n          //  with nothing tabbable in it)\n          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;\n          if (tabbableNodes.length > 0) {\n            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable\n            var mruTabIdx = tabbableNodes.findIndex(function (node) {\n              return node === state.mostRecentlyFocusedNode;\n            });\n            if (mruTabIdx >= 0) {\n              if (config.isKeyForward(state.recentNavEvent)) {\n                if (mruTabIdx + 1 < tabbableNodes.length) {\n                  nextNode = tabbableNodes[mruTabIdx + 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              } else {\n                if (mruTabIdx - 1 >= 0) {\n                  nextNode = tabbableNodes[mruTabIdx - 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              }\n              // else, don't find in container order without considering direction too\n            }\n          }\n          // else, no tabbable nodes in that container (which means we must have at least one other\n          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown\n          //  an error the last time updateTabbableNodes() was run): find next node among all known\n          //  containers\n        } else {\n          // check to see if there's at least one tabbable node with a positive tab index inside\n          //  the trap because focus seems to escape when navigating backward from a tabbable node\n          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with\n          //  the greatest positive tab index like it should)\n          if (!state.containerGroups.some(function (g) {\n            return g.tabbableNodes.some(function (n) {\n              return getTabIndex(n) > 0;\n            });\n          })) {\n            // no containers with tabbable nodes with positive tab indexes which means the focus\n            //  escaped for some other reason and we should just execute the fallback to the\n            //  MRU node or initial focus node, if any\n            navAcrossContainers = false;\n          }\n        }\n      } else {\n        // no MRU node means we're likely in some initial condition when the trap has just\n        //  been activated and initial focus hasn't been given yet, in which case we should\n        //  fall through to trying to focus the initial focus node, which is what should\n        //  happen below at this point in the logic\n        navAcrossContainers = false;\n      }\n      if (navAcrossContainers) {\n        nextNode = findNextNavNode({\n          // move FROM the MRU node, not event-related node (which will be the node that is\n          //  outside the trap causing the focus escape we're trying to fix)\n          target: state.mostRecentlyFocusedNode,\n          isBackward: config.isKeyBackward(state.recentNavEvent)\n        });\n      }\n      if (nextNode) {\n        _tryFocus(nextNode);\n      } else {\n        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n      }\n    }\n    state.recentNavEvent = undefined; // clear\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  var checkKeyNav = function checkKeyNav(event) {\n    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    state.recentNavEvent = event;\n    var destinationNode = findNextNavNode({\n      event: event,\n      isBackward: isBackward\n    });\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      _tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n  var checkTabKey = function checkTabKey(event) {\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n\n  // we use a different event phase for the Escape key to allow canceling the event and checking for this in escapeDeactivates\n  var checkEscapeKey = function checkEscapeKey(event) {\n    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {\n      event.preventDefault();\n      trap.deactivate();\n    }\n  };\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  /**\n   * Adds listeners to the document necessary for trapping focus and attempts to set focus\n   *  to the configured initial focus node. Does nothing if the trap isn't active.\n   * @returns {Promise<void>} Resolved (always) once the initial focus node has been focused.\n   *  Also resolved if the trap isn't active.\n   */\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return Promise.resolve();\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    /** @type {Promise<void>} */\n    var promise;\n    if (config.delayInitialFocus) {\n      // NOTE: Promise constructor callback is called synchronously, which is what we want\n      //  since we need to capture the timer ID immediately\n      promise = new Promise(function (resolve) {\n        state.delayInitialFocusTimer = delay(function () {\n          _tryFocus(getInitialFocusNode());\n          resolve();\n        });\n      });\n    } else {\n      promise = Promise.resolve();\n      _tryFocus(getInitialFocusNode());\n    }\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkTabKey, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkEscapeKey);\n    return promise;\n  };\n\n  /**\n   * Traverses up the DOM from each of `containers`, collecting references to\n   * the elements that are siblings to `container` or an ancestor of `container`.\n   * @param {Array<HTMLElement>} containers\n   */\n  var collectAdjacentElements = function collectAdjacentElements(containers) {\n    // Re-activate all adjacent elements & clear previous collection.\n    if (state.active && !state.paused) {\n      trap._setSubtreeIsolation(false);\n    }\n    state.adjacentElements.clear();\n    state.alreadySilent.clear();\n\n    // Collect all ancestors of all containers to avoid redundant processing.\n    var containerAncestors = new Set();\n    var adjacentElements = new Set();\n\n    // Compile all elements adjacent to the focus trap containers & lineage.\n    var _iterator = _createForOfIteratorHelper(containers),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var container = _step.value;\n        containerAncestors.add(container);\n        var insideShadowRoot = typeof ShadowRoot !== 'undefined' && container.getRootNode() instanceof ShadowRoot;\n        var current = container;\n        while (current) {\n          containerAncestors.add(current);\n          var parent = current.parentElement;\n          var siblings = [];\n          if (parent) {\n            siblings = parent.children;\n          } else if (!parent && insideShadowRoot) {\n            siblings = current.getRootNode().children;\n            parent = current.getRootNode().host;\n            insideShadowRoot = typeof ShadowRoot !== 'undefined' && parent.getRootNode() instanceof ShadowRoot;\n          }\n\n          // Add all the children, we'll remove container lineage later.\n          var _iterator2 = _createForOfIteratorHelper(siblings),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var child = _step2.value;\n              adjacentElements.add(child);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          current = parent;\n        }\n      }\n\n      // Multi-container traps may overlap.\n      // Remove elements within container lineages.\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    containerAncestors.forEach(function (el) {\n      adjacentElements[\"delete\"](el);\n    });\n    state.adjacentElements = adjacentElements;\n  };\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkTabKey, true);\n    doc.removeEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n\n  //\n  // MUTATION OBSERVER\n  //\n\n  var checkDomRemoval = function checkDomRemoval(mutations) {\n    var isFocusedNodeRemoved = mutations.some(function (mutation) {\n      var removedNodes = Array.from(mutation.removedNodes);\n      return removedNodes.some(function (node) {\n        return node === state.mostRecentlyFocusedNode;\n      });\n    });\n\n    // If the currently focused is removed then browsers will move focus to the\n    // <body> element. If this happens, try to move focus back into the trap.\n    if (isFocusedNodeRemoved) {\n      _tryFocus(getInitialFocusNode());\n    }\n  };\n\n  // Use MutationObserver - if supported - to detect if focused node is removed\n  // from the DOM.\n  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;\n  var updateObservedNodes = function updateObservedNodes() {\n    if (!mutationObserver) {\n      return;\n    }\n    mutationObserver.disconnect();\n    if (state.active && !state.paused) {\n      state.containers.map(function (container) {\n        mutationObserver.observe(container, {\n          subtree: true,\n          childList: true\n        });\n      });\n    }\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n    get paused() {\n      return state.paused;\n    },\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n\n      // If a currently-active trap is isolating its subtree, we need to remove\n      // that isolation to allow the new trap to find tabbable nodes.\n      var preexistingTrap = activeFocusTraps.getActiveTrap(trapStack);\n      var revertState = false;\n      if (preexistingTrap && !preexistingTrap.paused) {\n        var _preexistingTrap$_set;\n        // [#1729] method MAY not exist if using `trapStack` option to share stack with older\n        //  versions of Focus-trap in the same DOM so use optional chaining here just in case\n        //  since this is a trap we may not have created from this instance of the library\n        (_preexistingTrap$_set = preexistingTrap._setSubtreeIsolation) === null || _preexistingTrap$_set === void 0 || _preexistingTrap$_set.call(preexistingTrap, false);\n        revertState = true;\n      }\n      try {\n        if (!checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        state.active = true;\n        state.paused = false;\n        state.nodeFocusedBeforeActivation = _getActiveElement(doc);\n        onActivate === null || onActivate === void 0 || onActivate();\n        var finishActivation = /*#__PURE__*/function () {\n          var _ref6 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {\n            return _regenerator().w(function (_context) {\n              while (1) switch (_context.n) {\n                case 0:\n                  if (checkCanFocusTrap) {\n                    updateTabbableNodes();\n                  }\n\n                  // NOTE: wait for initial focus node to get focused before we potentially isolate\n                  //  the subtrees with aria-hidden while focus is still in some other subtree and\n                  //  not yet in the trap, resulting in some browsers (e.g. Chrome) logging to the\n                  //  console that they, \"Blocked aria-hidden on an element because its descendant\n                  //  retained focus...\"\n                  _context.n = 1;\n                  return addListeners();\n                case 1:\n                  trap._setSubtreeIsolation(true);\n                  updateObservedNodes();\n                  onPostActivate === null || onPostActivate === void 0 || onPostActivate();\n                case 2:\n                  return _context.a(2);\n              }\n            }, _callee);\n          }));\n          return function finishActivation() {\n            return _ref6.apply(this, arguments);\n          };\n        }();\n        if (checkCanFocusTrap) {\n          checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n          return this;\n        }\n        finishActivation();\n      } catch (error) {\n        // If our activation throws an exception and the stack hasn't changed,\n        // we need to re-enable the prior trap's subtree isolation.\n        if (preexistingTrap === activeFocusTraps.getActiveTrap(trapStack) && revertState) {\n          var _preexistingTrap$_set2;\n          // [#1729] method MAY not exist if using `trapStack` option to share stack with older\n          //  versions of Focus-trap in the same DOM so use optional chaining here just in case\n          //  since this is a trap we may not have created from this instance of the library\n          (_preexistingTrap$_set2 = preexistingTrap._setSubtreeIsolation) === null || _preexistingTrap$_set2 === void 0 || _preexistingTrap$_set2.call(preexistingTrap, true);\n        }\n        throw error;\n      }\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n\n      // Prior to removing this trap from the trapStack, we need to remove any applications of `inert`.\n      // This allows the next trap down to update its tabbable nodes properly.\n      //\n      // If this trap is not top of the stack, don't change any current isolation.\n      if (!state.paused) {\n        trap._setSubtreeIsolation(false);\n      }\n      state.alreadySilent.clear();\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      updateObservedNodes();\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n      onDeactivate === null || onDeactivate === void 0 || onDeactivate();\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause(pauseOptions) {\n      if (!state.active) {\n        return this;\n      }\n      state.manuallyPaused = true;\n      return this._setPausedState(true, pauseOptions);\n    },\n    unpause: function unpause(unpauseOptions) {\n      if (!state.active) {\n        return this;\n      }\n      state.manuallyPaused = false;\n      if (trapStack[trapStack.length - 1] !== this) {\n        return this;\n      }\n      return this._setPausedState(false, unpauseOptions);\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n      if (config.isolateSubtrees) {\n        collectAdjacentElements(state.containers);\n      }\n      if (state.active) {\n        updateTabbableNodes();\n        if (!state.paused) {\n          trap._setSubtreeIsolation(true);\n        }\n      }\n      updateObservedNodes();\n      return this;\n    }\n  };\n  Object.defineProperties(trap, {\n    _isManuallyPaused: {\n      value: function value() {\n        return state.manuallyPaused;\n      }\n    },\n    _setPausedState: {\n      value: function value(paused, options) {\n        if (state.paused === paused) {\n          return this;\n        }\n        state.paused = paused;\n        if (paused) {\n          var onPause = getOption(options, 'onPause');\n          var onPostPause = getOption(options, 'onPostPause');\n          onPause === null || onPause === void 0 || onPause();\n          removeListeners();\n          trap._setSubtreeIsolation(false);\n          updateObservedNodes();\n          onPostPause === null || onPostPause === void 0 || onPostPause();\n        } else {\n          var onUnpause = getOption(options, 'onUnpause');\n          var onPostUnpause = getOption(options, 'onPostUnpause');\n          onUnpause === null || onUnpause === void 0 || onUnpause();\n          var finishUnpause = /*#__PURE__*/function () {\n            var _ref7 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {\n              return _regenerator().w(function (_context2) {\n                while (1) switch (_context2.n) {\n                  case 0:\n                    updateTabbableNodes();\n\n                    // NOTE: wait for initial focus node to get focused before we potentially isolate\n                    //  the subtrees with aria-hidden while focus is still in some other subtree and\n                    //  not yet in the trap, resulting in some browsers (e.g. Chrome) logging to the\n                    //  console that they, \"Blocked aria-hidden on an element because its descendant\n                    //  retained focus...\"\n                    _context2.n = 1;\n                    return addListeners();\n                  case 1:\n                    trap._setSubtreeIsolation(true);\n                    updateObservedNodes();\n                    onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();\n                  case 2:\n                    return _context2.a(2);\n                }\n              }, _callee2);\n            }));\n            return function finishUnpause() {\n              return _ref7.apply(this, arguments);\n            };\n          }();\n          finishUnpause();\n        }\n        return this;\n      }\n    },\n    _setSubtreeIsolation: {\n      value: function value(isEnabled) {\n        if (config.isolateSubtrees) {\n          state.adjacentElements.forEach(function (el) {\n            var _el$getAttribute;\n            if (isEnabled) {\n              switch (config.isolateSubtrees) {\n                case 'aria-hidden':\n                  // check both attribute and property to ensure initial state is captured\n                  // correctly across different browsers and test environments (like JSDOM)\n                  if (el.ariaHidden === 'true' || ((_el$getAttribute = el.getAttribute('aria-hidden')) === null || _el$getAttribute === void 0 ? void 0 : _el$getAttribute.toLowerCase()) === 'true') {\n                    state.alreadySilent.add(el);\n                  }\n                  el.setAttribute('aria-hidden', 'true');\n                  break;\n                default:\n                  // check both attribute and property to ensure initial state is captured\n                  // correctly across different browsers and test environments (like JSDOM)\n                  if (el.inert || el.hasAttribute('inert')) {\n                    state.alreadySilent.add(el);\n                  }\n                  el.setAttribute('inert', true);\n                  break;\n              }\n            } else {\n              if (state.alreadySilent.has(el)) ; else {\n                switch (config.isolateSubtrees) {\n                  case 'aria-hidden':\n                    el.removeAttribute('aria-hidden');\n                    break;\n                  default:\n                    el.removeAttribute('inert');\n                    break;\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n  });\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n","import { isRTL } from \"@nextcloud/l10n\";\nconst isRtl = isRTL();\nexport {\n  isRtl as i\n};\n//# sourceMappingURL=rtl-v0UOPAM7.mjs.map\n","import '../assets/NcPopover-P1fheee2.css';\nimport { options, Dropdown } from \"floating-vue\";\nimport { createFocusTrap } from \"focus-trap\";\nimport { defineComponent, warn, resolveComponent, createBlock, openBlock, withCtx, createVNode, renderSlot, normalizeProps, guardReactiveProps } from \"vue\";\nimport { g as getTrapStack } from \"./focusTrap-HJQ4pqHV.mjs\";\nimport { l as logger } from \"./logger-D3RVzcfQ.mjs\";\nimport { i as isRtl } from \"./rtl-v0UOPAM7.mjs\";\nimport { _ as _export_sfc } from \"./_plugin-vue_export-helper-1tPrXgE0.mjs\";\nconst _sfc_main$1 = defineComponent({\n  name: \"NcPopoverTriggerProvider\",\n  provide() {\n    return {\n      \"NcPopover:trigger:shown\": () => this.shown,\n      \"NcPopover:trigger:attrs\": () => this.triggerAttrs\n    };\n  },\n  props: {\n    /**\n     * Is the popover currently shown\n     */\n    shown: {\n      type: Boolean,\n      required: true\n    },\n    /**\n     * ARIA Role of the popup\n     */\n    popupRole: {\n      type: String,\n      default: void 0\n    }\n  },\n  computed: {\n    triggerAttrs() {\n      return {\n        \"aria-haspopup\": this.popupRole,\n        \"aria-expanded\": this.shown.toString()\n      };\n    }\n  },\n  render() {\n    return this.$slots.default?.({\n      attrs: this.triggerAttrs\n    });\n  }\n});\nconst ncPopover = \"_ncPopover_HjJ88\";\nconst style0 = {\n  \"material-design-icon\": \"_material-design-icon_FKPyJ\",\n  ncPopover\n};\nconst theme = \"nc-popover-9\";\noptions.themes[theme] = structuredClone(options.themes.dropdown);\nconst _sfc_main = {\n  name: \"NcPopover\",\n  components: {\n    Dropdown,\n    NcPopoverTriggerProvider: _sfc_main$1\n  },\n  props: {\n    /**\n     * Element to use for calculating the popper boundary (size and position).\n     * Either a query string or the actual HTMLElement.\n     */\n    boundary: {\n      type: [String, Object],\n      default: \"\"\n    },\n    /**\n     * Automatically hide the popover on click outside.\n     *\n     * @deprecated Use `no-close-on-click-outside` instead (inverted value)\n     */\n    closeOnClickOutside: {\n      type: Boolean,\n      // eslint-disable-next-line vue/no-boolean-default\n      default: true\n    },\n    /**\n     * Disable the automatic popover hide on click outside.\n     */\n    noCloseOnClickOutside: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Container where to mount the popover.\n     * Either a select query or `false` to mount to the parent node.\n     */\n    container: {\n      type: [Boolean, String],\n      default: \"body\"\n    },\n    /**\n     * Delay for showing or hiding the popover.\n     *\n     * Can either be a number or an object to configure different delays (`{ show: number, hide: number }`).\n     */\n    delay: {\n      type: [Number, Object],\n      default: 0\n    },\n    /**\n     * Disable the popover focus trap.\n     */\n    noFocusTrap: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Where to place the popover.\n     *\n     * This consists of the vertical placement and the horizontal placement.\n     * E.g. `bottom` will place the popover on the bottom of the trigger (horizontally centered),\n     * while `buttom-start` will horizontally align the popover on the logical start (e.g. for LTR layout on the left.).\n     * The `start` or `end` placement will align the popover on the left or right side or the trigger element.\n     *\n     * @type {'auto'|'auto-start'|'auto-end'|'top'|'top-start'|'top-end'|'bottom'|'bottom-start'|'bottom-end'|'start'|'end'}\n     */\n    placement: {\n      type: String,\n      default: \"bottom\"\n    },\n    /**\n     * Class to be applied to the popover base\n     */\n    popoverBaseClass: {\n      type: String,\n      default: \"\"\n    },\n    /**\n     * Events that trigger the popover on the popover container itself.\n     * This is useful if you set `triggers` to `hover` and also want the popover to stay open while hovering the popover itself.\n     *\n     * It is possible to also pass an object to define different triggers for hide and show `{ show: ['hover'], hide: ['click'] }`.\n     */\n    popoverTriggers: {\n      type: [Array, Object],\n      default: null\n    },\n    /**\n     * Popup role\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-haspopup#values\n     */\n    popupRole: {\n      type: String,\n      default: void 0,\n      validator: (value) => [\"menu\", \"listbox\", \"tree\", \"grid\", \"dialog\", \"true\"].includes(value)\n    },\n    /**\n     * Set element to return focus to after focus trap deactivation\n     *\n     * @type {SetReturnFocus}\n     */\n    setReturnFocus: {\n      default: void 0,\n      type: [Boolean, HTMLElement, SVGElement, String, Function]\n    },\n    /**\n     * Show or hide the popper\n     */\n    shown: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Events that trigger the popover.\n     *\n     * If you pass an empty array then only the `shown` prop can control the popover state.\n     * Following events are available:\n     * - `'hover'`\n     * - `'click'`\n     * - `'focus'`\n     * - `'touch'`\n     *\n     * It is also possible to pass an object to have different events for show and hide:\n     * `{ hide: ['click'], show: ['click', 'hover'] }`\n     */\n    triggers: {\n      type: [Array, Object],\n      default: () => [\"click\"]\n    }\n  },\n  emits: [\n    \"afterShow\",\n    \"afterHide\",\n    \"update:shown\"\n  ],\n  setup() {\n    return {\n      theme\n    };\n  },\n  data() {\n    return {\n      internalShown: this.shown\n    };\n  },\n  computed: {\n    popperTriggers() {\n      if (this.popoverTriggers && Array.isArray(this.popoverTriggers)) {\n        return this.popoverTriggers;\n      }\n      return void 0;\n    },\n    popperHideTriggers() {\n      if (this.popoverTriggers && typeof this.popoverTriggers === \"object\") {\n        return this.popoverTriggers.hide;\n      }\n      return void 0;\n    },\n    popperShowTriggers() {\n      if (this.popoverTriggers && typeof this.popoverTriggers === \"object\") {\n        return this.popoverTriggers.show;\n      }\n      return void 0;\n    },\n    internalTriggers() {\n      if (this.triggers && Array.isArray(this.triggers)) {\n        return this.triggers;\n      }\n      return void 0;\n    },\n    hideTriggers() {\n      if (this.triggers && typeof this.triggers === \"object\") {\n        return this.triggers.hide;\n      }\n      return void 0;\n    },\n    showTriggers() {\n      if (this.triggers && typeof this.triggers === \"object\") {\n        return this.triggers.show;\n      }\n      return void 0;\n    },\n    internalPlacement() {\n      if (this.placement === \"start\") {\n        return isRtl ? \"right\" : \"left\";\n      } else if (this.placement === \"end\") {\n        return isRtl ? \"left\" : \"right\";\n      }\n      return this.placement;\n    }\n  },\n  watch: {\n    shown(value) {\n      this.internalShown = value;\n    },\n    internalShown(value) {\n      this.$emit(\"update:shown\", value);\n    }\n  },\n  mounted() {\n    this.checkTriggerA11y();\n  },\n  beforeUnmount() {\n    this.clearFocusTrap();\n    this.clearEscapeStopPropagation();\n  },\n  methods: {\n    /**\n     * Check if the trigger has all required a11y attributes.\n     * Important to check custom trigger button.\n     */\n    checkTriggerA11y() {\n      if (window.OC?.debug) {\n        const triggerContainer = this.getPopoverTriggerContainerElement();\n        const requiredTriggerButton = triggerContainer.querySelector(\"[aria-expanded]\");\n        if (!requiredTriggerButton) {\n          warn(\"It looks like you are using a custom button as a <NcPopover> or other popover #trigger. If you are not using <NcButton> as a trigger, you need to bind attrs from the #trigger slot props to your custom button. See <NcPopover> docs for an example.\");\n        }\n      }\n    },\n    /**\n     * Remove incorrect aria-describedby attribute from the trigger.\n     *\n     * @see https://github.com/Akryum/floating-vue/blob/8d4f7125aae0e3ea00ba4093d6d2001ab15058f1/packages/floating-vue/src/components/Popper.ts#L734\n     */\n    removeFloatingVueAriaDescribedBy() {\n      const triggerContainer = this.getPopoverTriggerContainerElement();\n      const triggerElements = triggerContainer.querySelectorAll(\"[data-popper-shown]\");\n      for (const el of triggerElements) {\n        el.removeAttribute(\"aria-describedby\");\n      }\n    },\n    /**\n     * @return {HTMLElement|undefined}\n     */\n    getPopoverContentElement() {\n      return this.$refs.popover?.$refs.popperContent?.$el;\n    },\n    /**\n     * @return {HTMLElement|undefined}\n     */\n    getPopoverTriggerContainerElement() {\n      return this.$refs.popover?.$refs.popper?.$refs.reference;\n    },\n    /**\n     * Add focus trap for accessibility.\n     */\n    async useFocusTrap() {\n      await this.$nextTick();\n      if (this.noFocusTrap) {\n        return;\n      }\n      const el = this.getPopoverContentElement();\n      el.tabIndex = -1;\n      if (!el) {\n        return;\n      }\n      this.$focusTrap = createFocusTrap(el, {\n        // Prevents to lose focus using esc key\n        // Focus will be release when popover be hide\n        escapeDeactivates: false,\n        allowOutsideClick: true,\n        setReturnFocus: this.setReturnFocus,\n        trapStack: getTrapStack(),\n        fallBackFocus: el\n      });\n      this.$focusTrap.activate();\n    },\n    /**\n     * Remove focus trap\n     *\n     * @param {object} options The configuration options for focusTrap\n     */\n    clearFocusTrap(options2 = {}) {\n      try {\n        this.$focusTrap?.deactivate(options2);\n        this.$focusTrap = null;\n      } catch (error) {\n        logger.warn(\"[NcPopover] Failed to clear focus trap\", { error });\n      }\n    },\n    /**\n     * Add stopPropagation for Escape.\n     * It prevents global Escape handling after closing popover.\n     *\n     * Manual event handling is used here instead of v-on because there is no direct access to the node.\n     * Alternative - wrap <template #popover> in a div wrapper.\n     */\n    addEscapeStopPropagation() {\n      const el = this.getPopoverContentElement();\n      el?.addEventListener(\"keydown\", this.stopKeydownEscapeHandler);\n    },\n    /**\n     * Remove stop Escape handler\n     */\n    clearEscapeStopPropagation() {\n      const el = this.getPopoverContentElement();\n      el?.removeEventListener(\"keydown\", this.stopKeydownEscapeHandler);\n    },\n    /**\n     * @param {KeyboardEvent} event - native keydown event\n     */\n    stopKeydownEscapeHandler(event) {\n      if (event.type === \"keydown\" && event.key === \"Escape\") {\n        event.stopPropagation();\n      }\n    },\n    async afterShow() {\n      this.getPopoverContentElement().addEventListener(\"transitionend\", () => {\n        this.$emit(\"afterShow\");\n      }, { once: true, passive: true });\n      this.removeFloatingVueAriaDescribedBy();\n      await this.$nextTick();\n      await this.useFocusTrap();\n      this.addEscapeStopPropagation();\n    },\n    afterHide() {\n      this.getPopoverContentElement()?.addEventListener(\"transitionend\", () => {\n        this.$emit(\"afterHide\");\n      }, { once: true, passive: true });\n      this.clearFocusTrap();\n      this.clearEscapeStopPropagation();\n    }\n  }\n};\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_NcPopoverTriggerProvider = resolveComponent(\"NcPopoverTriggerProvider\");\n  const _component_Dropdown = resolveComponent(\"Dropdown\");\n  return openBlock(), createBlock(_component_Dropdown, {\n    ref: \"popover\",\n    shown: $data.internalShown,\n    \"onUpdate:shown\": [\n      _cache[0] || (_cache[0] = ($event) => $data.internalShown = $event),\n      _cache[1] || (_cache[1] = ($event) => $data.internalShown = $event)\n    ],\n    arrowPadding: 10,\n    autoHide: !$props.noCloseOnClickOutside && $props.closeOnClickOutside,\n    boundary: $props.boundary || void 0,\n    container: $props.container,\n    delay: $props.delay,\n    distance: 10,\n    handleResize: \"\",\n    noAutoFocus: true,\n    placement: $options.internalPlacement,\n    popperClass: [_ctx.$style.ncPopover, $props.popoverBaseClass],\n    popperTriggers: $options.popperTriggers,\n    popperHideTriggers: $options.popperHideTriggers,\n    popperShowTriggers: $options.popperShowTriggers,\n    theme: $setup.theme,\n    triggers: $options.internalTriggers,\n    hideTriggers: $options.hideTriggers,\n    showTriggers: $options.showTriggers,\n    onApplyShow: $options.afterShow,\n    onApplyHide: $options.afterHide\n  }, {\n    popper: withCtx((slotProps) => [\n      renderSlot(_ctx.$slots, \"default\", normalizeProps(guardReactiveProps(slotProps)))\n    ]),\n    default: withCtx(() => [\n      createVNode(_component_NcPopoverTriggerProvider, {\n        shown: $data.internalShown,\n        popupRole: $props.popupRole\n      }, {\n        default: withCtx((slotProps) => [\n          renderSlot(_ctx.$slots, \"trigger\", normalizeProps(guardReactiveProps(slotProps)))\n        ]),\n        _: 3\n      }, 8, [\"shown\", \"popupRole\"])\n    ]),\n    _: 3\n  }, 8, [\"shown\", \"autoHide\", \"boundary\", \"container\", \"delay\", \"placement\", \"popperClass\", \"popperTriggers\", \"popperHideTriggers\", \"popperShowTriggers\", \"theme\", \"triggers\", \"hideTriggers\", \"showTriggers\", \"onApplyShow\", \"onApplyHide\"]);\n}\nconst cssModules = {\n  \"$style\": style0\n};\nconst NcPopover = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__cssModules\", cssModules]]);\nexport {\n  NcPopover as N\n};\n//# sourceMappingURL=NcPopover-OqcYrWOx.mjs.map\n","import '../assets/NcActions-DOI7rRa0.css';\nimport { createElementBlock, openBlock, mergeProps, createElementVNode, createCommentVNode, toDisplayString, Comment, Fragment, Text, warn, h, computed } from \"vue\";\nimport { _ as _export_sfc } from \"./_plugin-vue_export-helper-1tPrXgE0.mjs\";\nimport { u as useTrapStackControl } from \"./useTrapStackControl-B6cEicto.mjs\";\nimport { r as register, F as t4, a as t } from \"./_l10n-Dq_eYxz_.mjs\";\nimport { c as createElementId } from \"./createElementId-DhjFt1I9.mjs\";\nimport { N as NcButton } from \"./NcButton-C9D47Igd.mjs\";\nimport { N as NcPopover } from \"./NcPopover-OqcYrWOx.mjs\";\nimport { N as NC_ACTIONS_CLOSE_MENU, a as NC_ACTIONS_IS_SEMANTIC_MENU } from \"./useNcActions-BzPO2c4h.mjs\";\nconst _sfc_main$1 = {\n  name: \"DotsHorizontalIcon\",\n  emits: [\"click\"],\n  props: {\n    title: {\n      type: String\n    },\n    fillColor: {\n      type: String,\n      default: \"currentColor\"\n    },\n    size: {\n      type: Number,\n      default: 24\n    }\n  }\n};\nconst _hoisted_1 = [\"aria-hidden\", \"aria-label\"];\nconst _hoisted_2 = [\"fill\", \"width\", \"height\"];\nconst _hoisted_3 = { d: \"M16,12A2,2 0 0,1 18,10A2,2 0 0,1 20,12A2,2 0 0,1 18,14A2,2 0 0,1 16,12M10,12A2,2 0 0,1 12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12M4,12A2,2 0 0,1 6,10A2,2 0 0,1 8,12A2,2 0 0,1 6,14A2,2 0 0,1 4,12Z\" };\nconst _hoisted_4 = { key: 0 };\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"span\", mergeProps(_ctx.$attrs, {\n    \"aria-hidden\": $props.title ? null : \"true\",\n    \"aria-label\": $props.title,\n    class: \"material-design-icon dots-horizontal-icon\",\n    role: \"img\",\n    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit(\"click\", $event))\n  }), [\n    (openBlock(), createElementBlock(\"svg\", {\n      fill: $props.fillColor,\n      class: \"material-design-icon__svg\",\n      width: $props.size,\n      height: $props.size,\n      viewBox: \"0 0 24 24\"\n    }, [\n      createElementVNode(\"path\", _hoisted_3, [\n        $props.title ? (openBlock(), createElementBlock(\"title\", _hoisted_4, toDisplayString($props.title), 1)) : createCommentVNode(\"\", true)\n      ])\n    ], 8, _hoisted_2))\n  ], 16, _hoisted_1);\n}\nconst IconDotsHorizontal = /* @__PURE__ */ _export_sfc(_sfc_main$1, [[\"render\", _sfc_render]]);\nregister(t4);\nfunction isSlotPopulated(vnodes) {\n  return Array.isArray(vnodes) && vnodes.some((node) => {\n    if (node === null) {\n      return false;\n    } else if (typeof node === \"object\") {\n      const vnode = node;\n      if (vnode.type === Comment) {\n        return false;\n      } else if (vnode.type === Fragment && !isSlotPopulated(vnode.children)) {\n        return false;\n      } else if (vnode.type === Text && !vnode.children.trim()) {\n        return false;\n      }\n    }\n    return true;\n  });\n}\nconst focusableSelector = \".focusable\";\nconst _sfc_main = {\n  name: \"NcActions\",\n  components: {\n    NcButton,\n    NcPopover\n  },\n  provide() {\n    return {\n      /**\n       * NcActions can be used as:\n       * - Application menu (has menu role)\n       * - Navigation (has no specific role, should be used an element with navigation role)\n       * - Popover with plain text or text inputs (has no specific role)\n       * Depending on the usage (used items), the menu and its items should have different roles for a11y.\n       * Provide the role for NcAction* components in the NcActions content.\n       *\n       * @type {import('vue').ComputedRef<boolean>}\n       */\n      [NC_ACTIONS_IS_SEMANTIC_MENU]: computed(() => this.actionsMenuSemanticType === \"menu\"),\n      [NC_ACTIONS_CLOSE_MENU]: this.closeMenu\n    };\n  },\n  props: {\n    /**\n     * Specify the open state of the popover menu\n     */\n    open: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * This disables the internal open management,\n     * so the actions menu only respects the `open` prop.\n     * This is e.g. necessary for the NcAvatar component\n     * to only open the actions menu after loading it's entries has finished.\n     */\n    manualOpen: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Force the actions to display in a three dot menu\n     */\n    forceMenu: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Force the name to show for single actions\n     */\n    forceName: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Specify the menu name\n     */\n    menuName: {\n      type: String,\n      default: null\n    },\n    /**\n     * Apply primary styling for this menu\n     */\n    primary: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Icon to show for the toggle menu button\n     * when more than one action is inside the actions component.\n     * Only replace the default three-dot icon if really necessary.\n     */\n    defaultIcon: {\n      type: String,\n      default: \"\"\n    },\n    /**\n     * Aria label for the actions menu.\n     *\n     * If `menuName` is defined this will not be used to prevent\n     * any accessible name conflicts. This ensures that the\n     * element can be activated via voice input.\n     */\n    ariaLabel: {\n      type: String,\n      default: t(\"Actions\")\n    },\n    /**\n     * Wanted direction of the menu\n     */\n    placement: {\n      type: String,\n      default: \"bottom\"\n    },\n    /**\n     * DOM element for the actions' popover boundaries\n     */\n    boundariesElement: {\n      type: Element,\n      default: () => document.getElementById(\"content-vue\") ?? document.querySelector(\"body\")\n    },\n    /**\n     * Selector for the actions' popover container\n     */\n    container: {\n      type: [Boolean, String, Object, Element],\n      default: \"body\"\n    },\n    /**\n     * Disabled state of the main button (single action or menu toggle)\n     */\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    /**\n     * Display x items inline out of the dropdown menu\n     * Will be ignored if `forceMenu` is set\n     */\n    inline: {\n      type: Number,\n      default: 0\n    },\n    /**\n     * Specifies the button variant used for trigger and single actions buttons.\n     *\n     * If left empty, the default button style will be applied.\n     *\n     * @since 8.23.0\n     */\n    variant: {\n      type: String,\n      validator(value) {\n        return [\"primary\", \"secondary\", \"tertiary\", \"tertiary-no-background\", \"tertiary-on-primary\", \"error\", \"warning\", \"success\"].includes(value);\n      },\n      default: null\n    },\n    /**\n     * Specify the size used for trigger and single actions buttons.\n     *\n     * If left empty, the default button size will be applied.\n     */\n    size: {\n      type: String,\n      default: \"normal\",\n      validator(value) {\n        return [\"small\", \"normal\", \"large\"].includes(value);\n      }\n    }\n  },\n  emits: [\n    \"click\",\n    \"blur\",\n    \"focus\",\n    \"close\",\n    \"closed\",\n    \"open\",\n    \"opened\",\n    \"update:open\"\n  ],\n  setup() {\n    const randomId = createElementId();\n    return {\n      randomId\n    };\n  },\n  data() {\n    return {\n      opened: this.open,\n      focusIndex: 0,\n      /**\n       * @type {'menu'|'navigation'|'dialog'|'tooltip'|'unknown'}\n       */\n      actionsMenuSemanticType: \"unknown\"\n    };\n  },\n  computed: {\n    triggerButtonVariant() {\n      return this.variant || (this.primary ? \"primary\" : this.menuName ? \"secondary\" : \"tertiary\");\n    },\n    /**\n     * A11y roles and keyboard navigation configuration depending on the semantic type\n     */\n    config() {\n      const configs = {\n        menu: {\n          popupRole: \"menu\",\n          withArrowNavigation: true,\n          withTabNavigation: false,\n          withFocusTrap: false\n        },\n        navigation: {\n          popupRole: void 0,\n          withArrowNavigation: false,\n          withTabNavigation: true,\n          withFocusTrap: false\n        },\n        dialog: {\n          popupRole: \"dialog\",\n          withArrowNavigation: false,\n          withTabNavigation: true,\n          withFocusTrap: true\n        },\n        tooltip: {\n          popupRole: void 0,\n          withArrowNavigation: false,\n          withTabNavigation: false,\n          withFocusTrap: false\n        },\n        // Due to Vue limitations, we sometimes cannot determine the true type\n        // As a fallback use both arrow navigation and focus trap\n        unknown: {\n          popupRole: void 0,\n          role: void 0,\n          withArrowNavigation: true,\n          withTabNavigation: false,\n          withFocusTrap: true\n        }\n      };\n      return configs[this.actionsMenuSemanticType];\n    },\n    withFocusTrap() {\n      return this.config.withFocusTrap;\n    }\n  },\n  watch: {\n    // Watch parent prop\n    open(state) {\n      if (state === this.opened) {\n        return;\n      }\n      this.opened = state;\n    },\n    opened() {\n      if (this.opened) {\n        document.body.addEventListener(\"keydown\", this.handleEscapePressed);\n      } else {\n        document.body.removeEventListener(\"keydown\", this.handleEscapePressed);\n      }\n    }\n  },\n  created() {\n    useTrapStackControl(() => this.opened, {\n      disabled: () => this.config.withFocusTrap\n    });\n    if (\"ariaHidden\" in this.$attrs) {\n      warn(\"[NcActions]: Do not set the ariaHidden attribute as the root element will inherit the incorrect aria-hidden.\");\n    }\n  },\n  methods: {\n    /**\n     * Get the name of the action component\n     *\n     * @param {import('vue').VNode} action - a vnode with a NcAction* component instance\n     * @return {string} the name of the action component\n     */\n    getActionName(action) {\n      return action?.type?.name;\n    },\n    /**\n     * Do we have exactly one Action and\n     * is it allowed as a standalone element?\n     *\n     * @param {import('vue').VNode} action The action to check\n     * @return {boolean}\n     */\n    isValidSingleAction(action) {\n      return [\"NcActionButton\", \"NcActionLink\", \"NcActionRouter\"].includes(this.getActionName(action));\n    },\n    isAction(action) {\n      return this.getActionName(action)?.startsWith?.(\"NcAction\");\n    },\n    /**\n     * Check whether a icon prop value is an URL or not\n     *\n     * @param {string} url The icon prop value\n     */\n    isIconUrl(url) {\n      try {\n        return !!new URL(url, url.startsWith(\"/\") ? window.location.origin : void 0);\n      } catch {\n        return false;\n      }\n    },\n    // MENU STATE MANAGEMENT\n    toggleMenu(state) {\n      if (state) {\n        this.openMenu();\n      } else {\n        this.closeMenu();\n      }\n    },\n    openMenu() {\n      if (this.opened) {\n        return;\n      }\n      this.opened = true;\n      this.$emit(\"update:open\", true);\n      this.$emit(\"open\");\n    },\n    async closeMenu(returnFocus = true) {\n      if (!this.opened) {\n        return;\n      }\n      await this.$nextTick();\n      this.opened = false;\n      this.$refs.popover?.clearFocusTrap({ returnFocus });\n      this.$emit(\"update:open\", false);\n      this.$emit(\"close\");\n      this.focusIndex = 0;\n      if (returnFocus) {\n        this.$refs.triggerButton?.$el.focus();\n      }\n    },\n    /**\n     * Called when popover is shown after the show delay\n     */\n    onOpened() {\n      this.$nextTick(() => {\n        this.focusFirstAction(null);\n        this.$emit(\"opened\");\n      });\n    },\n    onClosed() {\n      this.$emit(\"closed\");\n    },\n    // MENU KEYS & FOCUS MANAGEMENT\n    /**\n     * @return {HTMLElement|null}\n     */\n    getCurrentActiveMenuItemElement() {\n      return this.$refs.menu.querySelector(\"li.active\");\n    },\n    /**\n     * @return {NodeList<HTMLElement>}\n     */\n    getFocusableMenuItemElements() {\n      return this.$refs.menu.querySelectorAll(focusableSelector);\n    },\n    /**\n     * Dispatches the keydown listener to different handlers\n     *\n     * @param {object} event The keydown event\n     */\n    onKeydown(event) {\n      if (event.key === \"Tab\") {\n        if (this.config.withFocusTrap) {\n          return;\n        }\n        if (!this.config.withTabNavigation) {\n          this.closeMenu(true);\n          return;\n        }\n        event.preventDefault();\n        const focusList = this.getFocusableMenuItemElements();\n        const focusIndex = [...focusList].indexOf(document.activeElement);\n        if (focusIndex === -1) {\n          return;\n        }\n        const newFocusIndex = event.shiftKey ? focusIndex - 1 : focusIndex + 1;\n        if (newFocusIndex < 0 || newFocusIndex === focusList.length) {\n          this.closeMenu(true);\n        }\n        this.focusIndex = newFocusIndex;\n        this.focusAction();\n        return;\n      }\n      if (this.config.withArrowNavigation) {\n        if (event.key === \"ArrowUp\") {\n          this.focusPreviousAction(event);\n        }\n        if (event.key === \"ArrowDown\") {\n          this.focusNextAction(event);\n        }\n        if (event.key === \"PageUp\") {\n          this.focusFirstAction(event);\n        }\n        if (event.key === \"PageDown\") {\n          this.focusLastAction(event);\n        }\n      }\n      this.handleEscapePressed(event);\n    },\n    onTriggerKeydown(event) {\n      if (event.key === \"Escape\") {\n        if (this.actionsMenuSemanticType === \"tooltip\") {\n          this.closeMenu();\n        }\n      }\n    },\n    handleEscapePressed(event) {\n      if (event.key === \"Escape\") {\n        this.closeMenu();\n        event.preventDefault();\n      }\n    },\n    removeCurrentActive() {\n      const currentActiveElement = this.$refs.menu.querySelector(\"li.active\");\n      if (currentActiveElement) {\n        currentActiveElement.classList.remove(\"active\");\n      }\n    },\n    focusAction() {\n      const focusElement = this.getFocusableMenuItemElements()[this.focusIndex];\n      if (focusElement) {\n        this.removeCurrentActive();\n        const liMenuParent = focusElement.closest(\"li.action\");\n        focusElement.focus();\n        if (liMenuParent) {\n          liMenuParent.classList.add(\"active\");\n        }\n      }\n    },\n    focusPreviousAction(event) {\n      if (this.opened) {\n        if (this.focusIndex === 0) {\n          this.focusLastAction(event);\n        } else {\n          this.preventIfEvent(event);\n          this.focusIndex = this.focusIndex - 1;\n        }\n        this.focusAction();\n      }\n    },\n    focusNextAction(event) {\n      if (this.opened) {\n        const indexLength = this.getFocusableMenuItemElements().length - 1;\n        if (this.focusIndex === indexLength) {\n          this.focusFirstAction(event);\n        } else {\n          this.preventIfEvent(event);\n          this.focusIndex = this.focusIndex + 1;\n        }\n        this.focusAction();\n      }\n    },\n    focusFirstAction(event) {\n      if (this.opened) {\n        this.preventIfEvent(event);\n        const firstCheckedIndex = [...this.getFocusableMenuItemElements()].findIndex((button) => {\n          return button.getAttribute(\"aria-checked\") === \"true\" && button.getAttribute(\"role\") === \"menuitemradio\";\n        });\n        this.focusIndex = firstCheckedIndex > -1 ? firstCheckedIndex : 0;\n        this.focusAction();\n      }\n    },\n    focusLastAction(event) {\n      if (this.opened) {\n        this.preventIfEvent(event);\n        this.focusIndex = this.getFocusableMenuItemElements().length - 1;\n        this.focusAction();\n      }\n    },\n    preventIfEvent(event) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    },\n    onFocus(event) {\n      this.$emit(\"focus\", event);\n    },\n    onBlur(event) {\n      this.$emit(\"blur\", event);\n      if (this.actionsMenuSemanticType === \"tooltip\") {\n        if (this.$refs.menu && this.getFocusableMenuItemElements().length === 0) {\n          this.closeMenu(false);\n        }\n      }\n    },\n    onClick(event) {\n      this.$emit(\"click\", event);\n    }\n  },\n  /**\n   * The render function to display the component\n   *\n   * @return {object|undefined} The created VNode\n   */\n  render() {\n    const actions = [];\n    const findActions = (vnodes, actions2) => {\n      vnodes.forEach((vnode) => {\n        if (this.isAction(vnode)) {\n          actions2.push(vnode);\n          return;\n        }\n        if (vnode.type === Fragment) {\n          findActions(vnode.children, actions2);\n        }\n      });\n    };\n    findActions(this.$slots.default?.(), actions);\n    if (actions.length === 0) {\n      return;\n    }\n    let validInlineActions = actions.filter(this.isValidSingleAction);\n    if (this.forceMenu && validInlineActions.length > 0 && this.inline > 0) {\n      warn(\"Specifying forceMenu will ignore any inline actions rendering.\");\n      validInlineActions = [];\n    }\n    const inlineActions = validInlineActions.slice(0, this.inline);\n    const menuActions = actions.filter((action) => !inlineActions.includes(action));\n    const menuItemsActions = [\"NcActionButton\", \"NcActionButtonGroup\", \"NcActionCheckbox\", \"NcActionRadio\"];\n    const textInputActions = [\"NcActionInput\", \"NcActionTextEditable\"];\n    const linkActions = [\"NcActionLink\", \"NcActionRouter\"];\n    const hasTextInputAction = menuActions.some((action) => textInputActions.includes(this.getActionName(action)));\n    const hasMenuItemAction = menuActions.some((action) => menuItemsActions.includes(this.getActionName(action)));\n    const hasLinkAction = menuActions.some((action) => linkActions.includes(this.getActionName(action)));\n    if (hasTextInputAction) {\n      this.actionsMenuSemanticType = \"dialog\";\n    } else if (hasMenuItemAction) {\n      this.actionsMenuSemanticType = \"menu\";\n    } else if (hasLinkAction) {\n      this.actionsMenuSemanticType = \"navigation\";\n    } else {\n      const ncActions = actions.filter((action) => this.getActionName(action).startsWith(\"NcAction\"));\n      if (ncActions.length === actions.length) {\n        this.actionsMenuSemanticType = \"tooltip\";\n      } else {\n        this.actionsMenuSemanticType = \"unknown\";\n      }\n    }\n    const renderInlineAction = (action) => {\n      const iconProp = action?.props?.icon;\n      const icon = action?.children?.icon?.()?.[0] ?? (this.isIconUrl(iconProp) ? h(\"img\", { class: \"action-item__menutoggle__icon\", src: iconProp, alt: \"\" }) : h(\"span\", { class: [\"icon\", iconProp] }));\n      const text = action?.children?.default?.()?.[0]?.children?.trim();\n      const buttonText = this.forceName ? text : \"\";\n      let title = action?.props?.title;\n      if (!(this.forceName || title)) {\n        title = text;\n      }\n      const propsToForward = { ...action?.props ?? {} };\n      const type = [\"submit\", \"reset\"].includes(propsToForward.type) ? propsToForward.modelValue : \"button\";\n      delete propsToForward.modelValue;\n      delete propsToForward.type;\n      return h(\n        NcButton,\n        mergeProps(\n          propsToForward,\n          {\n            class: \"action-item action-item--single\",\n            \"aria-label\": action?.props?.[\"aria-label\"] || text,\n            title,\n            disabled: this.disabled || action?.props?.disabled,\n            pressed: action?.props?.modelValue,\n            size: this.size,\n            type,\n            // If it has a menuName, we use a secondary button\n            variant: this.variant || (buttonText ? \"secondary\" : \"tertiary\"),\n            onFocus: this.onFocus,\n            onBlur: this.onBlur,\n            // forward any pressed state from NcButton just like NcActionButton does\n            \"onUpdate:pressed\": action?.props?.[\"onUpdate:modelValue\"] ?? (() => {\n            })\n          }\n        ),\n        {\n          default: () => buttonText,\n          icon: () => icon\n        }\n      );\n    };\n    const renderActionsPopover = (actions2) => {\n      const triggerIcon = isSlotPopulated(this.$slots.icon?.()) ? this.$slots.icon?.() : this.defaultIcon ? h(\"span\", { class: [\"icon\", this.defaultIcon] }) : h(IconDotsHorizontal, { size: 20 });\n      const triggerRandomId = `${this.randomId}-trigger`;\n      return h(\n        NcPopover,\n        {\n          ref: \"popover\",\n          delay: 0,\n          shown: this.opened,\n          placement: this.placement,\n          boundary: this.boundariesElement,\n          autoBoundaryMaxSize: true,\n          container: this.container,\n          ...this.manualOpen && {\n            triggers: []\n          },\n          noCloseOnClickOutside: this.manualOpen,\n          popoverBaseClass: \"action-item__popper\",\n          popupRole: this.config.popupRole,\n          setReturnFocus: this.config.withFocusTrap ? this.$refs.triggerButton?.$el : void 0,\n          noFocusTrap: !this.config.withFocusTrap,\n          \"onUpdate:shown\": this.toggleMenu,\n          onAfterShow: this.onOpened,\n          onAfterClose: this.onClosed\n        },\n        {\n          trigger: () => h(NcButton, {\n            id: triggerRandomId,\n            class: \"action-item__menutoggle\",\n            disabled: this.disabled,\n            size: this.size,\n            variant: this.triggerButtonVariant,\n            ref: \"triggerButton\",\n            \"aria-label\": this.menuName ? null : this.ariaLabel,\n            // 'aria-controls' should only present together with a valid aria-haspopup\n            \"aria-controls\": this.opened && this.config.popupRole ? this.randomId : null,\n            onFocus: this.onFocus,\n            onBlur: this.onBlur,\n            onClick: this.onClick,\n            onKeydown: this.onTriggerKeydown\n          }, {\n            icon: () => triggerIcon,\n            default: () => this.menuName\n          }),\n          default: () => h(\"div\", {\n            class: {\n              open: this.opened\n            },\n            tabindex: \"-1\",\n            onKeydown: this.onKeydown,\n            ref: \"menu\"\n          }, [\n            h(\"ul\", {\n              id: this.randomId,\n              tabindex: \"-1\",\n              ref: \"menuList\",\n              role: this.config.popupRole,\n              // For most roles a label is required (dialog, menu), but also in general nothing speaks against labelling a list.\n              // It is even recommended to do so.\n              \"aria-labelledby\": triggerRandomId,\n              \"aria-modal\": this.actionsMenuSemanticType === \"dialog\" ? \"true\" : void 0\n            }, [\n              actions2\n            ])\n          ])\n        }\n      );\n    };\n    if (actions.length === 1 && validInlineActions.length === 1 && !this.forceMenu) {\n      return renderInlineAction(actions[0]);\n    }\n    this.$nextTick(() => {\n      if (this.opened && this.$refs.menu) {\n        const isAnyActive = this.$refs.menu.querySelector(\"li.active\") || [];\n        if (isAnyActive.length === 0) {\n          this.focusFirstAction();\n        }\n      }\n    });\n    if (inlineActions.length > 0 && this.inline > 0) {\n      return h(\n        \"div\",\n        {\n          class: [\n            \"action-items\",\n            `action-item--${this.triggerButtonVariant}`\n          ]\n        },\n        [\n          // Render inline actions\n          ...inlineActions.map(renderInlineAction),\n          // render the rest within the popover menu\n          menuActions.length > 0 ? h(\n            \"div\",\n            {\n              class: [\n                \"action-item\",\n                {\n                  \"action-item--open\": this.opened\n                }\n              ]\n            },\n            [renderActionsPopover(menuActions)]\n          ) : null\n        ]\n      );\n    }\n    return h(\n      \"div\",\n      {\n        class: [\n          \"action-item action-item--default-popover\",\n          `action-item--${this.triggerButtonVariant}`,\n          {\n            \"action-item--open\": this.opened\n          }\n        ]\n      },\n      [\n        renderActionsPopover(actions)\n      ]\n    );\n  }\n};\nconst NcActions = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"__scopeId\", \"data-v-5f7eed6b\"]]);\nexport {\n  IconDotsHorizontal as I,\n  NcActions as N,\n  isSlotPopulated as i\n};\n//# sourceMappingURL=NcActions-BWDsG06k.mjs.map\n","import { computed, customRef, effectScope, getCurrentInstance, getCurrentScope, hasInjectionContext, inject, isReactive, isRef, nextTick, onBeforeMount, onBeforeUnmount, onMounted, onScopeDispose, onUnmounted, provide, reactive, readonly, ref, shallowReadonly, shallowRef, toRef as toRef$1, toRefs as toRefs$1, toValue, unref, watch, watchEffect } from \"vue\";\n\n//#region computedEager/index.ts\n/**\n*\n* @deprecated This function will be removed in future version.\n*\n* Note: If you are using Vue 3.4+, you can straight use computed instead.\n* Because in Vue 3.4+, if computed new value does not change,\n* computed, effect, watch, watchEffect, render dependencies will not be triggered.\n* refer: https://github.com/vuejs/core/pull/5912\n*\n* @param fn effect function\n* @param options WatchOptionsBase\n* @returns readonly shallowRef\n*/\nfunction computedEager(fn, options) {\n\tvar _options$flush;\n\tconst result = shallowRef();\n\twatchEffect(() => {\n\t\tresult.value = fn();\n\t}, {\n\t\t...options,\n\t\tflush: (_options$flush = options === null || options === void 0 ? void 0 : options.flush) !== null && _options$flush !== void 0 ? _options$flush : \"sync\"\n\t});\n\treturn readonly(result);\n}\n/** @deprecated use `computedEager` instead */\nconst eagerComputed = computedEager;\n\n//#endregion\n//#region computedWithControl/index.ts\n/**\n* Explicitly define the deps of computed.\n*\n* @param source\n* @param fn\n*/\nfunction computedWithControl(source, fn, options = {}) {\n\tlet v = void 0;\n\tlet track;\n\tlet trigger;\n\tlet dirty = true;\n\tconst update = () => {\n\t\tdirty = true;\n\t\ttrigger();\n\t};\n\twatch(source, update, {\n\t\tflush: \"sync\",\n\t\t...options\n\t});\n\tconst get$1 = typeof fn === \"function\" ? fn : fn.get;\n\tconst set$1 = typeof fn === \"function\" ? void 0 : fn.set;\n\tconst result = customRef((_track, _trigger) => {\n\t\ttrack = _track;\n\t\ttrigger = _trigger;\n\t\treturn {\n\t\t\tget() {\n\t\t\t\tif (dirty) {\n\t\t\t\t\tv = get$1(v);\n\t\t\t\t\tdirty = false;\n\t\t\t\t}\n\t\t\t\ttrack();\n\t\t\t\treturn v;\n\t\t\t},\n\t\t\tset(v$1) {\n\t\t\t\tset$1 === null || set$1 === void 0 || set$1(v$1);\n\t\t\t}\n\t\t};\n\t});\n\tresult.trigger = update;\n\treturn result;\n}\n/** @deprecated use `computedWithControl` instead */\nconst controlledComputed = computedWithControl;\n\n//#endregion\n//#region tryOnScopeDispose/index.ts\n/**\n* Call onScopeDispose() if it's inside an effect scope lifecycle, if not, do nothing\n*\n* @param fn\n*/\nfunction tryOnScopeDispose(fn, failSilently) {\n\tif (getCurrentScope()) {\n\t\tonScopeDispose(fn, failSilently);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//#endregion\n//#region createEventHook/index.ts\n/**\n* Utility for creating event hooks\n*\n* @see https://vueuse.org/createEventHook\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction createEventHook() {\n\tconst fns = /* @__PURE__ */ new Set();\n\tconst off = (fn) => {\n\t\tfns.delete(fn);\n\t};\n\tconst clear = () => {\n\t\tfns.clear();\n\t};\n\tconst on = (fn) => {\n\t\tfns.add(fn);\n\t\tconst offFn = () => off(fn);\n\t\ttryOnScopeDispose(offFn);\n\t\treturn { off: offFn };\n\t};\n\tconst trigger = (...args) => {\n\t\treturn Promise.all(Array.from(fns).map((fn) => fn(...args)));\n\t};\n\treturn {\n\t\ton,\n\t\toff,\n\t\ttrigger,\n\t\tclear\n\t};\n}\n\n//#endregion\n//#region createGlobalState/index.ts\n/**\n* Keep states in the global scope to be reusable across Vue instances.\n*\n* @see https://vueuse.org/createGlobalState\n* @param stateFactory A factory function to create the state\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction createGlobalState(stateFactory) {\n\tlet initialized = false;\n\tlet state;\n\tconst scope = effectScope(true);\n\treturn ((...args) => {\n\t\tif (!initialized) {\n\t\t\tstate = scope.run(() => stateFactory(...args));\n\t\t\tinitialized = true;\n\t\t}\n\t\treturn state;\n\t});\n}\n\n//#endregion\n//#region provideLocal/map.ts\nconst localProvidedStateMap = /* @__PURE__ */ new WeakMap();\n\n//#endregion\n//#region injectLocal/index.ts\n/**\n* On the basis of `inject`, it is allowed to directly call inject to obtain the value after call provide in the same component.\n*\n* @example\n* ```ts\n* injectLocal('MyInjectionKey', 1)\n* const injectedValue = injectLocal('MyInjectionKey') // injectedValue === 1\n* ```\n*\n* @__NO_SIDE_EFFECTS__\n*/\nconst injectLocal = (...args) => {\n\tvar _getCurrentInstance;\n\tconst key = args[0];\n\tconst instance = (_getCurrentInstance = getCurrentInstance()) === null || _getCurrentInstance === void 0 ? void 0 : _getCurrentInstance.proxy;\n\tconst owner = instance !== null && instance !== void 0 ? instance : getCurrentScope();\n\tif (owner == null && !hasInjectionContext()) throw new Error(\"injectLocal must be called in setup\");\n\tif (owner && localProvidedStateMap.has(owner) && key in localProvidedStateMap.get(owner)) return localProvidedStateMap.get(owner)[key];\n\treturn inject(...args);\n};\n\n//#endregion\n//#region provideLocal/index.ts\n/**\n* On the basis of `provide`, it is allowed to directly call inject to obtain the value after call provide in the same component.\n*\n* @example\n* ```ts\n* provideLocal('MyInjectionKey', 1)\n* const injectedValue = injectLocal('MyInjectionKey') // injectedValue === 1\n* ```\n*/\nfunction provideLocal(key, value) {\n\tvar _getCurrentInstance;\n\tconst instance = (_getCurrentInstance = getCurrentInstance()) === null || _getCurrentInstance === void 0 ? void 0 : _getCurrentInstance.proxy;\n\tconst owner = instance !== null && instance !== void 0 ? instance : getCurrentScope();\n\tif (owner == null) throw new Error(\"provideLocal must be called in setup\");\n\tif (!localProvidedStateMap.has(owner)) localProvidedStateMap.set(owner, Object.create(null));\n\tconst localProvidedState = localProvidedStateMap.get(owner);\n\tlocalProvidedState[key] = value;\n\treturn provide(key, value);\n}\n\n//#endregion\n//#region createInjectionState/index.ts\n/**\n* Create global state that can be injected into components.\n*\n* @see https://vueuse.org/createInjectionState\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction createInjectionState(composable, options) {\n\tconst key = (options === null || options === void 0 ? void 0 : options.injectionKey) || Symbol(composable.name || \"InjectionState\");\n\tconst defaultValue = options === null || options === void 0 ? void 0 : options.defaultValue;\n\tconst useProvidingState = (...args) => {\n\t\tconst state = composable(...args);\n\t\tprovideLocal(key, state);\n\t\treturn state;\n\t};\n\tconst useInjectedState = () => injectLocal(key, defaultValue);\n\treturn [useProvidingState, useInjectedState];\n}\n\n//#endregion\n//#region createRef/index.ts\n/**\n* Returns a `deepRef` or `shallowRef` depending on the `deep` param.\n*\n* @example createRef(1) // ShallowRef<number>\n* @example createRef(1, false) // ShallowRef<number>\n* @example createRef(1, true) // Ref<number>\n* @example createRef(\"string\") // ShallowRef<string>\n* @example createRef<\"A\"|\"B\">(\"A\", true) // Ref<\"A\"|\"B\">\n*\n* @param value\n* @param deep\n* @returns the `deepRef` or `shallowRef`\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction createRef(value, deep) {\n\tif (deep === true) return ref(value);\n\telse return shallowRef(value);\n}\n\n//#endregion\n//#region utils/is.ts\nconst isClient = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n\tif (!condition) console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {};\nconst rand = (min, max) => {\n\tmin = Math.ceil(min);\n\tmax = Math.floor(max);\n\treturn Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n\tvar _window, _window2, _window3;\n\treturn isClient && !!((_window = window) === null || _window === void 0 || (_window = _window.navigator) === null || _window === void 0 ? void 0 : _window.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_window2 = window) === null || _window2 === void 0 || (_window2 = _window2.navigator) === null || _window2 === void 0 ? void 0 : _window2.maxTouchPoints) > 2 && /iPad|Macintosh/.test((_window3 = window) === null || _window3 === void 0 ? void 0 : _window3.navigator.userAgent));\n}\n\n//#endregion\n//#region toRef/index.ts\nfunction toRef(...args) {\n\tif (args.length !== 1) return toRef$1(...args);\n\tconst r = args[0];\n\treturn typeof r === \"function\" ? readonly(customRef(() => ({\n\t\tget: r,\n\t\tset: noop\n\t}))) : ref(r);\n}\n\n//#endregion\n//#region utils/filters.ts\n/**\n* @internal\n*/\nfunction createFilterWrapper(filter, fn) {\n\tfunction wrapper(...args) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tPromise.resolve(filter(() => fn.apply(this, args), {\n\t\t\t\tfn,\n\t\t\t\tthisArg: this,\n\t\t\t\targs\n\t\t\t})).then(resolve).catch(reject);\n\t\t});\n\t}\n\treturn wrapper;\n}\nconst bypassFilter = (invoke$1) => {\n\treturn invoke$1();\n};\n/**\n* Create an EventFilter that debounce the events\n*/\nfunction debounceFilter(ms, options = {}) {\n\tlet timer;\n\tlet maxTimer;\n\tlet lastRejector = noop;\n\tconst _clearTimeout = (timer$1) => {\n\t\tclearTimeout(timer$1);\n\t\tlastRejector();\n\t\tlastRejector = noop;\n\t};\n\tlet lastInvoker;\n\tconst filter = (invoke$1) => {\n\t\tconst duration = toValue(ms);\n\t\tconst maxDuration = toValue(options.maxWait);\n\t\tif (timer) _clearTimeout(timer);\n\t\tif (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n\t\t\tif (maxTimer) {\n\t\t\t\t_clearTimeout(maxTimer);\n\t\t\t\tmaxTimer = void 0;\n\t\t\t}\n\t\t\treturn Promise.resolve(invoke$1());\n\t\t}\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlastRejector = options.rejectOnCancel ? reject : resolve;\n\t\t\tlastInvoker = invoke$1;\n\t\t\tif (maxDuration && !maxTimer) maxTimer = setTimeout(() => {\n\t\t\t\tif (timer) _clearTimeout(timer);\n\t\t\t\tmaxTimer = void 0;\n\t\t\t\tresolve(lastInvoker());\n\t\t\t}, maxDuration);\n\t\t\ttimer = setTimeout(() => {\n\t\t\t\tif (maxTimer) _clearTimeout(maxTimer);\n\t\t\t\tmaxTimer = void 0;\n\t\t\t\tresolve(invoke$1());\n\t\t\t}, duration);\n\t\t});\n\t};\n\treturn filter;\n}\nfunction throttleFilter(...args) {\n\tlet lastExec = 0;\n\tlet timer;\n\tlet isLeading = true;\n\tlet lastRejector = noop;\n\tlet lastValue;\n\tlet ms;\n\tlet trailing;\n\tlet leading;\n\tlet rejectOnCancel;\n\tif (!isRef(args[0]) && typeof args[0] === \"object\") ({delay: ms, trailing = true, leading = true, rejectOnCancel = false} = args[0]);\n\telse [ms, trailing = true, leading = true, rejectOnCancel = false] = args;\n\tconst clear = () => {\n\t\tif (timer) {\n\t\t\tclearTimeout(timer);\n\t\t\ttimer = void 0;\n\t\t\tlastRejector();\n\t\t\tlastRejector = noop;\n\t\t}\n\t};\n\tconst filter = (_invoke) => {\n\t\tconst duration = toValue(ms);\n\t\tconst elapsed = Date.now() - lastExec;\n\t\tconst invoke$1 = () => {\n\t\t\treturn lastValue = _invoke();\n\t\t};\n\t\tclear();\n\t\tif (duration <= 0) {\n\t\t\tlastExec = Date.now();\n\t\t\treturn invoke$1();\n\t\t}\n\t\tif (elapsed > duration) {\n\t\t\tlastExec = Date.now();\n\t\t\tif (leading || !isLeading) invoke$1();\n\t\t} else if (trailing) lastValue = new Promise((resolve, reject) => {\n\t\t\tlastRejector = rejectOnCancel ? reject : resolve;\n\t\t\ttimer = setTimeout(() => {\n\t\t\t\tlastExec = Date.now();\n\t\t\t\tisLeading = true;\n\t\t\t\tresolve(invoke$1());\n\t\t\t\tclear();\n\t\t\t}, Math.max(0, duration - elapsed));\n\t\t});\n\t\tif (!leading && !timer) timer = setTimeout(() => isLeading = true, duration);\n\t\tisLeading = false;\n\t\treturn lastValue;\n\t};\n\treturn filter;\n}\n/**\n* EventFilter that gives extra controls to pause and resume the filter\n*\n* @param extendFilter  Extra filter to apply when the PausableFilter is active, default to none\n* @param options Options to configure the filter\n*/\nfunction pausableFilter(extendFilter = bypassFilter, options = {}) {\n\tconst { initialState = \"active\" } = options;\n\tconst isActive = toRef(initialState === \"active\");\n\tfunction pause() {\n\t\tisActive.value = false;\n\t}\n\tfunction resume() {\n\t\tisActive.value = true;\n\t}\n\tconst eventFilter = (...args) => {\n\t\tif (isActive.value) extendFilter(...args);\n\t};\n\treturn {\n\t\tisActive: readonly(isActive),\n\t\tpause,\n\t\tresume,\n\t\teventFilter\n\t};\n}\n\n//#endregion\n//#region utils/general.ts\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n\treturn new Promise((resolve, reject) => {\n\t\tif (throwOnTimeout) setTimeout(() => reject(reason), ms);\n\t\telse setTimeout(resolve, ms);\n\t});\n}\nfunction identity(arg) {\n\treturn arg;\n}\n/**\n* Create singleton promise function\n*\n* @example\n* ```\n* const promise = createSingletonPromise(async () => { ... })\n*\n* await promise()\n* await promise() // all of them will be bind to a single promise instance\n* await promise() // and be resolved together\n* ```\n*/\nfunction createSingletonPromise(fn) {\n\tlet _promise;\n\tfunction wrapper() {\n\t\tif (!_promise) _promise = fn();\n\t\treturn _promise;\n\t}\n\twrapper.reset = async () => {\n\t\tconst _prev = _promise;\n\t\t_promise = void 0;\n\t\tif (_prev) await _prev;\n\t};\n\treturn wrapper;\n}\nfunction invoke(fn) {\n\treturn fn();\n}\nfunction containsProp(obj, ...props) {\n\treturn props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n\tvar _target$match;\n\tif (typeof target === \"number\") return target + delta;\n\tconst value = ((_target$match = target.match(/^-?\\d+\\.?\\d*/)) === null || _target$match === void 0 ? void 0 : _target$match[0]) || \"\";\n\tconst unit = target.slice(value.length);\n\tconst result = Number.parseFloat(value) + delta;\n\tif (Number.isNaN(result)) return target;\n\treturn result + unit;\n}\n/**\n* Get a px value for SSR use, do not rely on this method outside of SSR as REM unit is assumed at 16px, which might not be the case on the client\n*/\nfunction pxValue(px) {\n\treturn px.endsWith(\"rem\") ? Number.parseFloat(px) * 16 : Number.parseFloat(px);\n}\n/**\n* Create a new subset object by giving keys\n*/\nfunction objectPick(obj, keys, omitUndefined = false) {\n\treturn keys.reduce((n, k) => {\n\t\tif (k in obj) {\n\t\t\tif (!omitUndefined || obj[k] !== void 0) n[k] = obj[k];\n\t\t}\n\t\treturn n;\n\t}, {});\n}\n/**\n* Create a new subset object by omit giving keys\n*/\nfunction objectOmit(obj, keys, omitUndefined = false) {\n\treturn Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n\t\treturn (!omitUndefined || value !== void 0) && !keys.includes(key);\n\t}));\n}\nfunction objectEntries(obj) {\n\treturn Object.entries(obj);\n}\nfunction toArray(value) {\n\treturn Array.isArray(value) ? value : [value];\n}\n\n//#endregion\n//#region utils/port.ts\nfunction cacheStringFunction(fn) {\n\tconst cache = Object.create(null);\n\treturn ((str) => {\n\t\treturn cache[str] || (cache[str] = fn(str));\n\t});\n}\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n\treturn str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\n\n//#endregion\n//#region utils/vue.ts\nfunction getLifeCycleTarget(target) {\n\treturn target || getCurrentInstance();\n}\n\n//#endregion\n//#region createSharedComposable/index.ts\n/**\n* Make a composable function usable with multiple Vue instances.\n*\n* @see https://vueuse.org/createSharedComposable\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction createSharedComposable(composable) {\n\tif (!isClient) return composable;\n\tlet subscribers = 0;\n\tlet state;\n\tlet scope;\n\tconst dispose = () => {\n\t\tsubscribers -= 1;\n\t\tif (scope && subscribers <= 0) {\n\t\t\tscope.stop();\n\t\t\tstate = void 0;\n\t\t\tscope = void 0;\n\t\t}\n\t};\n\treturn ((...args) => {\n\t\tsubscribers += 1;\n\t\tif (!scope) {\n\t\t\tscope = effectScope(true);\n\t\t\tstate = scope.run(() => composable(...args));\n\t\t}\n\t\ttryOnScopeDispose(dispose);\n\t\treturn state;\n\t});\n}\n\n//#endregion\n//#region extendRef/index.ts\nfunction extendRef(ref$1, extend, { enumerable = false, unwrap = true } = {}) {\n\tfor (const [key, value] of Object.entries(extend)) {\n\t\tif (key === \"value\") continue;\n\t\tif (isRef(value) && unwrap) Object.defineProperty(ref$1, key, {\n\t\t\tget() {\n\t\t\t\treturn value.value;\n\t\t\t},\n\t\t\tset(v) {\n\t\t\t\tvalue.value = v;\n\t\t\t},\n\t\t\tenumerable\n\t\t});\n\t\telse Object.defineProperty(ref$1, key, {\n\t\t\tvalue,\n\t\t\tenumerable\n\t\t});\n\t}\n\treturn ref$1;\n}\n\n//#endregion\n//#region get/index.ts\nfunction get(obj, key) {\n\tif (key == null) return unref(obj);\n\treturn unref(obj)[key];\n}\n\n//#endregion\n//#region isDefined/index.ts\nfunction isDefined(v) {\n\treturn unref(v) != null;\n}\n\n//#endregion\n//#region makeDestructurable/index.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction makeDestructurable(obj, arr) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tconst clone = { ...obj };\n\t\tObject.defineProperty(clone, Symbol.iterator, {\n\t\t\tenumerable: false,\n\t\t\tvalue() {\n\t\t\t\tlet index = 0;\n\t\t\t\treturn { next: () => ({\n\t\t\t\t\tvalue: arr[index++],\n\t\t\t\t\tdone: index > arr.length\n\t\t\t\t}) };\n\t\t\t}\n\t\t});\n\t\treturn clone;\n\t} else return Object.assign([...arr], obj);\n}\n\n//#endregion\n//#region reactify/index.ts\n/**\n* Converts plain function into a reactive function.\n* The converted function accepts refs as it's arguments\n* and returns a ComputedRef, with proper typing.\n*\n* @param fn - Source function\n* @param options - Options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction reactify(fn, options) {\n\tconst unrefFn = (options === null || options === void 0 ? void 0 : options.computedGetter) === false ? unref : toValue;\n\treturn function(...args) {\n\t\treturn computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n\t};\n}\n/** @deprecated use `reactify` instead */\nconst createReactiveFn = reactify;\n\n//#endregion\n//#region reactifyObject/index.ts\n/**\n* Apply `reactify` to an object\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n\tlet keys = [];\n\tlet options;\n\tif (Array.isArray(optionsOrKeys)) keys = optionsOrKeys;\n\telse {\n\t\toptions = optionsOrKeys;\n\t\tconst { includeOwnProperties = true } = optionsOrKeys;\n\t\tkeys.push(...Object.keys(obj));\n\t\tif (includeOwnProperties) keys.push(...Object.getOwnPropertyNames(obj));\n\t}\n\treturn Object.fromEntries(keys.map((key) => {\n\t\tconst value = obj[key];\n\t\treturn [key, typeof value === \"function\" ? reactify(value.bind(obj), options) : value];\n\t}));\n}\n\n//#endregion\n//#region toReactive/index.ts\n/**\n* Converts ref to reactive.\n*\n* @see https://vueuse.org/toReactive\n* @param objectRef A ref of object\n*/\nfunction toReactive(objectRef) {\n\tif (!isRef(objectRef)) return reactive(objectRef);\n\treturn reactive(new Proxy({}, {\n\t\tget(_, p, receiver) {\n\t\t\treturn unref(Reflect.get(objectRef.value, p, receiver));\n\t\t},\n\t\tset(_, p, value) {\n\t\t\tif (isRef(objectRef.value[p]) && !isRef(value)) objectRef.value[p].value = value;\n\t\t\telse objectRef.value[p] = value;\n\t\t\treturn true;\n\t\t},\n\t\tdeleteProperty(_, p) {\n\t\t\treturn Reflect.deleteProperty(objectRef.value, p);\n\t\t},\n\t\thas(_, p) {\n\t\t\treturn Reflect.has(objectRef.value, p);\n\t\t},\n\t\townKeys() {\n\t\t\treturn Object.keys(objectRef.value);\n\t\t},\n\t\tgetOwnPropertyDescriptor() {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true\n\t\t\t};\n\t\t}\n\t}));\n}\n\n//#endregion\n//#region reactiveComputed/index.ts\n/**\n* Computed reactive object.\n*/\nfunction reactiveComputed(fn) {\n\treturn toReactive(computed(fn));\n}\n\n//#endregion\n//#region reactiveOmit/index.ts\n/**\n* Reactively omit fields from a reactive object\n*\n* @see https://vueuse.org/reactiveOmit\n*/\nfunction reactiveOmit(obj, ...keys) {\n\tconst flatKeys = keys.flat();\n\tconst predicate = flatKeys[0];\n\treturn reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\n//#endregion\n//#region reactivePick/index.ts\n/**\n* Reactively pick fields from a reactive object\n*\n* @see https://vueuse.org/reactivePick\n*/\nfunction reactivePick(obj, ...keys) {\n\tconst flatKeys = keys.flat();\n\tconst predicate = flatKeys[0];\n\treturn reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\n//#endregion\n//#region refAutoReset/index.ts\n/**\n* Create a ref which will be reset to the default value after some time.\n*\n* @see https://vueuse.org/refAutoReset\n* @param defaultValue The value which will be set.\n* @param afterMs      A zero-or-greater delay in milliseconds.\n*/\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n\treturn customRef((track, trigger) => {\n\t\tlet value = toValue(defaultValue);\n\t\tlet timer;\n\t\tconst resetAfter = () => setTimeout(() => {\n\t\t\tvalue = toValue(defaultValue);\n\t\t\ttrigger();\n\t\t}, toValue(afterMs));\n\t\ttryOnScopeDispose(() => {\n\t\t\tclearTimeout(timer);\n\t\t});\n\t\treturn {\n\t\t\tget() {\n\t\t\t\ttrack();\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tset(newValue) {\n\t\t\t\tvalue = newValue;\n\t\t\t\ttrigger();\n\t\t\t\tclearTimeout(timer);\n\t\t\t\ttimer = resetAfter();\n\t\t\t}\n\t\t};\n\t});\n}\n/** @deprecated use `refAutoReset` instead */\nconst autoResetRef = refAutoReset;\n\n//#endregion\n//#region useDebounceFn/index.ts\n/**\n* Debounce execution of a function.\n*\n* @see https://vueuse.org/useDebounceFn\n* @param  fn          A function to be executed after delay milliseconds debounced.\n* @param  ms          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n* @param  options     Options\n*\n* @return A new, debounce, function.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n\treturn createFilterWrapper(debounceFilter(ms, options), fn);\n}\n\n//#endregion\n//#region refDebounced/index.ts\n/**\n* Debounce updates of a ref.\n*\n* @return A new debounced ref.\n*/\nfunction refDebounced(value, ms = 200, options = {}) {\n\tconst debounced = ref(toValue(value));\n\tconst updater = useDebounceFn(() => {\n\t\tdebounced.value = value.value;\n\t}, ms, options);\n\twatch(value, () => updater());\n\treturn shallowReadonly(debounced);\n}\n/** @deprecated use `refDebounced` instead */\nconst debouncedRef = refDebounced;\n/** @deprecated use `refDebounced` instead */\nconst useDebounce = refDebounced;\n\n//#endregion\n//#region refDefault/index.ts\n/**\n* Apply default value to a ref.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction refDefault(source, defaultValue) {\n\treturn computed({\n\t\tget() {\n\t\t\tvar _source$value;\n\t\t\treturn (_source$value = source.value) !== null && _source$value !== void 0 ? _source$value : defaultValue;\n\t\t},\n\t\tset(value) {\n\t\t\tsource.value = value;\n\t\t}\n\t});\n}\n\n//#endregion\n//#region refManualReset/index.ts\n/**\n* Create a ref with manual reset functionality.\n*\n* @see https://vueuse.org/refManualReset\n* @param defaultValue The value which will be set.\n*/\nfunction refManualReset(defaultValue) {\n\tlet value = toValue(defaultValue);\n\tlet trigger;\n\tconst reset = () => {\n\t\tvalue = toValue(defaultValue);\n\t\ttrigger();\n\t};\n\tconst refValue = customRef((track, _trigger) => {\n\t\ttrigger = _trigger;\n\t\treturn {\n\t\t\tget() {\n\t\t\t\ttrack();\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tset(newValue) {\n\t\t\t\tvalue = newValue;\n\t\t\t\ttrigger();\n\t\t\t}\n\t\t};\n\t});\n\trefValue.reset = reset;\n\treturn refValue;\n}\n\n//#endregion\n//#region useThrottleFn/index.ts\n/**\n* Throttle execution of a function. Especially useful for rate limiting\n* execution of handlers on events like resize and scroll.\n*\n* @param   fn             A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n*                                    to `callback` when the throttled-function is executed.\n* @param   ms             A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n*                                    (default value: 200)\n*\n* @param [trailing] if true, call fn again after the time is up (default value: false)\n*\n* @param [leading] if true, call fn on the leading edge of the ms timeout (default value: true)\n*\n* @param [rejectOnCancel] if true, reject the last call if it's been cancel (default value: false)\n*\n* @return  A new, throttled, function.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n\treturn createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn);\n}\n\n//#endregion\n//#region refThrottled/index.ts\n/**\n* Throttle execution of a function. Especially useful for rate limiting\n* execution of handlers on events like resize and scroll.\n*\n* @param value Ref value to be watched with throttle effect\n* @param  delay  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n* @param trailing if true, update the value again after the delay time is up\n* @param leading if true, update the value on the leading edge of the ms timeout\n*/\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n\tif (delay <= 0) return value;\n\tconst throttled = ref(toValue(value));\n\tconst updater = useThrottleFn(() => {\n\t\tthrottled.value = value.value;\n\t}, delay, trailing, leading);\n\twatch(value, () => updater());\n\treturn throttled;\n}\n/** @deprecated use `refThrottled` instead */\nconst throttledRef = refThrottled;\n/** @deprecated use `refThrottled` instead */\nconst useThrottle = refThrottled;\n\n//#endregion\n//#region refWithControl/index.ts\n/**\n* Fine-grained controls over ref and its reactivity.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction refWithControl(initial, options = {}) {\n\tlet source = initial;\n\tlet track;\n\tlet trigger;\n\tconst ref$1 = customRef((_track, _trigger) => {\n\t\ttrack = _track;\n\t\ttrigger = _trigger;\n\t\treturn {\n\t\t\tget() {\n\t\t\t\treturn get$1();\n\t\t\t},\n\t\t\tset(v) {\n\t\t\t\tset$1(v);\n\t\t\t}\n\t\t};\n\t});\n\tfunction get$1(tracking = true) {\n\t\tif (tracking) track();\n\t\treturn source;\n\t}\n\tfunction set$1(value, triggering = true) {\n\t\tvar _options$onBeforeChan, _options$onChanged;\n\t\tif (value === source) return;\n\t\tconst old = source;\n\t\tif (((_options$onBeforeChan = options.onBeforeChange) === null || _options$onBeforeChan === void 0 ? void 0 : _options$onBeforeChan.call(options, value, old)) === false) return;\n\t\tsource = value;\n\t\t(_options$onChanged = options.onChanged) === null || _options$onChanged === void 0 || _options$onChanged.call(options, value, old);\n\t\tif (triggering) trigger();\n\t}\n\t/**\n\t* Get the value without tracked in the reactivity system\n\t*/\n\tconst untrackedGet = () => get$1(false);\n\t/**\n\t* Set the value without triggering the reactivity system\n\t*/\n\tconst silentSet = (v) => set$1(v, false);\n\t/**\n\t* Get the value without tracked in the reactivity system.\n\t*\n\t* Alias for `untrackedGet()`\n\t*/\n\tconst peek = () => get$1(false);\n\t/**\n\t* Set the value without triggering the reactivity system\n\t*\n\t* Alias for `silentSet(v)`\n\t*/\n\tconst lay = (v) => set$1(v, false);\n\treturn extendRef(ref$1, {\n\t\tget: get$1,\n\t\tset: set$1,\n\t\tuntrackedGet,\n\t\tsilentSet,\n\t\tpeek,\n\t\tlay\n\t}, { enumerable: true });\n}\n/** @deprecated use `refWithControl` instead */\nconst controlledRef = refWithControl;\n\n//#endregion\n//#region set/index.ts\n/**\n*  Shorthand for `ref.value = x`\n*/\nfunction set(...args) {\n\tif (args.length === 2) {\n\t\tconst [ref$1, value] = args;\n\t\tref$1.value = value;\n\t}\n\tif (args.length === 3) {\n\t\tconst [target, key, value] = args;\n\t\ttarget[key] = value;\n\t}\n}\n\n//#endregion\n//#region watchWithFilter/index.ts\nfunction watchWithFilter(source, cb, options = {}) {\n\tconst { eventFilter = bypassFilter,...watchOptions } = options;\n\treturn watch(source, createFilterWrapper(eventFilter, cb), watchOptions);\n}\n\n//#endregion\n//#region watchPausable/index.ts\n/** @deprecated Use Vue's built-in `watch` instead. This function will be removed in future version. */\nfunction watchPausable(source, cb, options = {}) {\n\tconst { eventFilter: filter, initialState = \"active\",...watchOptions } = options;\n\tconst { eventFilter, pause, resume, isActive } = pausableFilter(filter, { initialState });\n\treturn {\n\t\tstop: watchWithFilter(source, cb, {\n\t\t\t...watchOptions,\n\t\t\teventFilter\n\t\t}),\n\t\tpause,\n\t\tresume,\n\t\tisActive\n\t};\n}\n/** @deprecated Use Vue's built-in `watch` instead. This function will be removed in future version. */\nconst pausableWatch = watchPausable;\n\n//#endregion\n//#region syncRef/index.ts\n/**\n* Two-way refs synchronization.\n* From the set theory perspective to restrict the option's type\n* Check in the following order:\n* 1. L = R\n* 2. L âˆ© R â‰  âˆ…\n* 3. L âŠ† R\n* 4. L âˆ© R = âˆ…\n*/\nfunction syncRef(left, right, ...[options]) {\n\tconst { flush = \"sync\", deep = false, immediate = true, direction = \"both\", transform = {} } = options || {};\n\tconst watchers = [];\n\tconst transformLTR = \"ltr\" in transform && transform.ltr || ((v) => v);\n\tconst transformRTL = \"rtl\" in transform && transform.rtl || ((v) => v);\n\tif (direction === \"both\" || direction === \"ltr\") watchers.push(watchPausable(left, (newValue) => {\n\t\twatchers.forEach((w) => w.pause());\n\t\tright.value = transformLTR(newValue);\n\t\twatchers.forEach((w) => w.resume());\n\t}, {\n\t\tflush,\n\t\tdeep,\n\t\timmediate\n\t}));\n\tif (direction === \"both\" || direction === \"rtl\") watchers.push(watchPausable(right, (newValue) => {\n\t\twatchers.forEach((w) => w.pause());\n\t\tleft.value = transformRTL(newValue);\n\t\twatchers.forEach((w) => w.resume());\n\t}, {\n\t\tflush,\n\t\tdeep,\n\t\timmediate\n\t}));\n\tconst stop = () => {\n\t\twatchers.forEach((w) => w.stop());\n\t};\n\treturn stop;\n}\n\n//#endregion\n//#region syncRefs/index.ts\n/**\n* Keep target ref(s) in sync with the source ref\n*\n* @param source source ref\n* @param targets\n*/\nfunction syncRefs(source, targets, options = {}) {\n\tconst { flush = \"sync\", deep = false, immediate = true } = options;\n\tconst targetsArray = toArray(targets);\n\treturn watch(source, (newValue) => targetsArray.forEach((target) => target.value = newValue), {\n\t\tflush,\n\t\tdeep,\n\t\timmediate\n\t});\n}\n\n//#endregion\n//#region toRefs/index.ts\n/**\n* Extended `toRefs` that also accepts refs of an object.\n*\n* @see https://vueuse.org/toRefs\n* @param objectRef A ref or normal object or array.\n* @param options Options\n*/\nfunction toRefs(objectRef, options = {}) {\n\tif (!isRef(objectRef)) return toRefs$1(objectRef);\n\tconst result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};\n\tfor (const key in objectRef.value) result[key] = customRef(() => ({\n\t\tget() {\n\t\t\treturn objectRef.value[key];\n\t\t},\n\t\tset(v) {\n\t\t\tvar _toValue;\n\t\t\tif ((_toValue = toValue(options.replaceRef)) !== null && _toValue !== void 0 ? _toValue : true) if (Array.isArray(objectRef.value)) {\n\t\t\t\tconst copy = [...objectRef.value];\n\t\t\t\tcopy[key] = v;\n\t\t\t\tobjectRef.value = copy;\n\t\t\t} else {\n\t\t\t\tconst newObject = {\n\t\t\t\t\t...objectRef.value,\n\t\t\t\t\t[key]: v\n\t\t\t\t};\n\t\t\t\tObject.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));\n\t\t\t\tobjectRef.value = newObject;\n\t\t\t}\n\t\t\telse objectRef.value[key] = v;\n\t\t}\n\t}));\n\treturn result;\n}\n\n//#endregion\n//#region tryOnBeforeMount/index.ts\n/**\n* Call onBeforeMount() if it's inside a component lifecycle, if not, just call the function\n*\n* @param fn\n* @param sync if set to false, it will run in the nextTick() of Vue\n* @param target\n*/\nfunction tryOnBeforeMount(fn, sync = true, target) {\n\tif (getLifeCycleTarget(target)) onBeforeMount(fn, target);\n\telse if (sync) fn();\n\telse nextTick(fn);\n}\n\n//#endregion\n//#region tryOnBeforeUnmount/index.ts\n/**\n* Call onBeforeUnmount() if it's inside a component lifecycle, if not, do nothing\n*\n* @param fn\n* @param target\n*/\nfunction tryOnBeforeUnmount(fn, target) {\n\tif (getLifeCycleTarget(target)) onBeforeUnmount(fn, target);\n}\n\n//#endregion\n//#region tryOnMounted/index.ts\n/**\n* Call onMounted() if it's inside a component lifecycle, if not, just call the function\n*\n* @param fn\n* @param sync if set to false, it will run in the nextTick() of Vue\n* @param target\n*/\nfunction tryOnMounted(fn, sync = true, target) {\n\tif (getLifeCycleTarget(target)) onMounted(fn, target);\n\telse if (sync) fn();\n\telse nextTick(fn);\n}\n\n//#endregion\n//#region tryOnUnmounted/index.ts\n/**\n* Call onUnmounted() if it's inside a component lifecycle, if not, do nothing\n*\n* @param fn\n* @param target\n*/\nfunction tryOnUnmounted(fn, target) {\n\tif (getLifeCycleTarget(target)) onUnmounted(fn, target);\n}\n\n//#endregion\n//#region until/index.ts\nfunction createUntil(r, isNot = false) {\n\tfunction toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n\t\tlet stop = null;\n\t\tconst promises = [new Promise((resolve) => {\n\t\t\tstop = watch(r, (v) => {\n\t\t\t\tif (condition(v) !== isNot) {\n\t\t\t\t\tif (stop) stop();\n\t\t\t\t\telse nextTick(() => stop === null || stop === void 0 ? void 0 : stop());\n\t\t\t\t\tresolve(v);\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tflush,\n\t\t\t\tdeep,\n\t\t\t\timmediate: true\n\t\t\t});\n\t\t})];\n\t\tif (timeout != null) promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => stop === null || stop === void 0 ? void 0 : stop()));\n\t\treturn Promise.race(promises);\n\t}\n\tfunction toBe(value, options) {\n\t\tif (!isRef(value)) return toMatch((v) => v === value, options);\n\t\tconst { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options !== null && options !== void 0 ? options : {};\n\t\tlet stop = null;\n\t\tconst promises = [new Promise((resolve) => {\n\t\t\tstop = watch([r, value], ([v1, v2]) => {\n\t\t\t\tif (isNot !== (v1 === v2)) {\n\t\t\t\t\tif (stop) stop();\n\t\t\t\t\telse nextTick(() => stop === null || stop === void 0 ? void 0 : stop());\n\t\t\t\t\tresolve(v1);\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tflush,\n\t\t\t\tdeep,\n\t\t\t\timmediate: true\n\t\t\t});\n\t\t})];\n\t\tif (timeout != null) promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => {\n\t\t\tstop === null || stop === void 0 || stop();\n\t\t\treturn toValue(r);\n\t\t}));\n\t\treturn Promise.race(promises);\n\t}\n\tfunction toBeTruthy(options) {\n\t\treturn toMatch((v) => Boolean(v), options);\n\t}\n\tfunction toBeNull(options) {\n\t\treturn toBe(null, options);\n\t}\n\tfunction toBeUndefined(options) {\n\t\treturn toBe(void 0, options);\n\t}\n\tfunction toBeNaN(options) {\n\t\treturn toMatch(Number.isNaN, options);\n\t}\n\tfunction toContains(value, options) {\n\t\treturn toMatch((v) => {\n\t\t\tconst array = Array.from(v);\n\t\t\treturn array.includes(value) || array.includes(toValue(value));\n\t\t}, options);\n\t}\n\tfunction changed(options) {\n\t\treturn changedTimes(1, options);\n\t}\n\tfunction changedTimes(n = 1, options) {\n\t\tlet count = -1;\n\t\treturn toMatch(() => {\n\t\t\tcount += 1;\n\t\t\treturn count >= n;\n\t\t}, options);\n\t}\n\tif (Array.isArray(toValue(r))) return {\n\t\ttoMatch,\n\t\ttoContains,\n\t\tchanged,\n\t\tchangedTimes,\n\t\tget not() {\n\t\t\treturn createUntil(r, !isNot);\n\t\t}\n\t};\n\telse return {\n\t\ttoMatch,\n\t\ttoBe,\n\t\ttoBeTruthy,\n\t\ttoBeNull,\n\t\ttoBeNaN,\n\t\ttoBeUndefined,\n\t\tchanged,\n\t\tchangedTimes,\n\t\tget not() {\n\t\t\treturn createUntil(r, !isNot);\n\t\t}\n\t};\n}\nfunction until(r) {\n\treturn createUntil(r);\n}\n\n//#endregion\n//#region useArrayDifference/index.ts\nfunction defaultComparator(value, othVal) {\n\treturn value === othVal;\n}\n/**\n* Reactive get array difference of two array\n* @see https://vueuse.org/useArrayDifference\n* @returns - the difference of two array\n* @param args\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useArrayDifference(...args) {\n\tvar _args$, _args$2;\n\tconst list = args[0];\n\tconst values = args[1];\n\tlet compareFn = (_args$ = args[2]) !== null && _args$ !== void 0 ? _args$ : defaultComparator;\n\tconst { symmetric = false } = (_args$2 = args[3]) !== null && _args$2 !== void 0 ? _args$2 : {};\n\tif (typeof compareFn === \"string\") {\n\t\tconst key = compareFn;\n\t\tcompareFn = (value, othVal) => value[key] === othVal[key];\n\t}\n\tconst diff1 = computed(() => toValue(list).filter((x) => toValue(values).findIndex((y) => compareFn(x, y)) === -1));\n\tif (symmetric) {\n\t\tconst diff2 = computed(() => toValue(values).filter((x) => toValue(list).findIndex((y) => compareFn(x, y)) === -1));\n\t\treturn computed(() => symmetric ? [...toValue(diff1), ...toValue(diff2)] : toValue(diff1));\n\t} else return diff1;\n}\n\n//#endregion\n//#region useArrayEvery/index.ts\n/**\n* Reactive `Array.every`\n*\n* @see https://vueuse.org/useArrayEvery\n* @param list - the array was called upon.\n* @param fn - a function to test each element.\n*\n* @returns **true** if the `fn` function returns a **truthy** value for every element from the array. Otherwise, **false**.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useArrayEvery(list, fn) {\n\treturn computed(() => toValue(list).every((element, index, array) => fn(toValue(element), index, array)));\n}\n\n//#endregion\n//#region useArrayFilter/index.ts\n/**\n* Reactive `Array.filter`\n*\n* @see https://vueuse.org/useArrayFilter\n* @param list - the array was called upon.\n* @param fn - a function that is called for every element of the given `list`. Each time `fn` executes, the returned value is added to the new array.\n*\n* @returns a shallow copy of a portion of the given array, filtered down to just the elements from the given array that pass the test implemented by the provided function. If no elements pass the test, an empty array will be returned.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useArrayFilter(list, fn) {\n\treturn computed(() => toValue(list).map((i) => toValue(i)).filter(fn));\n}\n\n//#endregion\n//#region useArrayFind/index.ts\n/**\n* Reactive `Array.find`\n*\n* @see https://vueuse.org/useArrayFind\n* @param list - the array was called upon.\n* @param fn - a function to test each element.\n*\n* @returns the first element in the array that satisfies the provided testing function. Otherwise, undefined is returned.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useArrayFind(list, fn) {\n\treturn computed(() => toValue(toValue(list).find((element, index, array) => fn(toValue(element), index, array))));\n}\n\n//#endregion\n//#region useArrayFindIndex/index.ts\n/**\n* Reactive `Array.findIndex`\n*\n* @see https://vueuse.org/useArrayFindIndex\n* @param list - the array was called upon.\n* @param fn - a function to test each element.\n*\n* @returns the index of the first element in the array that passes the test. Otherwise, \"-1\".\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useArrayFindIndex(list, fn) {\n\treturn computed(() => toValue(list).findIndex((element, index, array) => fn(toValue(element), index, array)));\n}\n\n//#endregion\n//#region useArrayFindLast/index.ts\nfunction findLast(arr, cb) {\n\tlet index = arr.length;\n\twhile (index-- > 0) if (cb(arr[index], index, arr)) return arr[index];\n}\n/**\n* Reactive `Array.findLast`\n*\n* @see https://vueuse.org/useArrayFindLast\n* @param list - the array was called upon.\n* @param fn - a function to test each element.\n*\n* @returns the last element in the array that satisfies the provided testing function. Otherwise, undefined is returned.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useArrayFindLast(list, fn) {\n\treturn computed(() => toValue(!Array.prototype.findLast ? findLast(toValue(list), (element, index, array) => fn(toValue(element), index, array)) : toValue(list).findLast((element, index, array) => fn(toValue(element), index, array))));\n}\n\n//#endregion\n//#region useArrayIncludes/index.ts\nfunction isArrayIncludesOptions(obj) {\n\treturn isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\n/**\n* Reactive `Array.includes`\n*\n* @see https://vueuse.org/useArrayIncludes\n*\n* @returns true if the `value` is found in the array. Otherwise, false.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useArrayIncludes(...args) {\n\tvar _comparator;\n\tconst list = args[0];\n\tconst value = args[1];\n\tlet comparator = args[2];\n\tlet formIndex = 0;\n\tif (isArrayIncludesOptions(comparator)) {\n\t\tvar _comparator$fromIndex;\n\t\tformIndex = (_comparator$fromIndex = comparator.fromIndex) !== null && _comparator$fromIndex !== void 0 ? _comparator$fromIndex : 0;\n\t\tcomparator = comparator.comparator;\n\t}\n\tif (typeof comparator === \"string\") {\n\t\tconst key = comparator;\n\t\tcomparator = (element, value$1) => element[key] === toValue(value$1);\n\t}\n\tcomparator = (_comparator = comparator) !== null && _comparator !== void 0 ? _comparator : ((element, value$1) => element === toValue(value$1));\n\treturn computed(() => toValue(list).slice(formIndex).some((element, index, array) => comparator(toValue(element), toValue(value), index, toValue(array))));\n}\n\n//#endregion\n//#region useArrayJoin/index.ts\n/**\n* Reactive `Array.join`\n*\n* @see https://vueuse.org/useArrayJoin\n* @param list - the array was called upon.\n* @param separator - a string to separate each pair of adjacent elements of the array. If omitted, the array elements are separated with a comma (\",\").\n*\n* @returns a string with all array elements joined. If arr.length is 0, the empty string is returned.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useArrayJoin(list, separator) {\n\treturn computed(() => toValue(list).map((i) => toValue(i)).join(toValue(separator)));\n}\n\n//#endregion\n//#region useArrayMap/index.ts\n/**\n* Reactive `Array.map`\n*\n* @see https://vueuse.org/useArrayMap\n* @param list - the array was called upon.\n* @param fn - a function that is called for every element of the given `list`. Each time `fn` executes, the returned value is added to the new array.\n*\n* @returns a new array with each element being the result of the callback function.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useArrayMap(list, fn) {\n\treturn computed(() => toValue(list).map((i) => toValue(i)).map(fn));\n}\n\n//#endregion\n//#region useArrayReduce/index.ts\n/**\n* Reactive `Array.reduce`\n*\n* @see https://vueuse.org/useArrayReduce\n* @param list - the array was called upon.\n* @param reducer - a \"reducer\" function.\n* @param args\n*\n* @returns the value that results from running the \"reducer\" callback function to completion over the entire array.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useArrayReduce(list, reducer, ...args) {\n\tconst reduceCallback = (sum, value, index) => reducer(toValue(sum), toValue(value), index);\n\treturn computed(() => {\n\t\tconst resolved = toValue(list);\n\t\treturn args.length ? resolved.reduce(reduceCallback, typeof args[0] === \"function\" ? toValue(args[0]()) : toValue(args[0])) : resolved.reduce(reduceCallback);\n\t});\n}\n\n//#endregion\n//#region useArraySome/index.ts\n/**\n* Reactive `Array.some`\n*\n* @see https://vueuse.org/useArraySome\n* @param list - the array was called upon.\n* @param fn - a function to test each element.\n*\n* @returns **true** if the `fn` function returns a **truthy** value for any element from the array. Otherwise, **false**.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useArraySome(list, fn) {\n\treturn computed(() => toValue(list).some((element, index, array) => fn(toValue(element), index, array)));\n}\n\n//#endregion\n//#region useArrayUnique/index.ts\nfunction uniq(array) {\n\treturn Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n\treturn array.reduce((acc, v) => {\n\t\tif (!acc.some((x) => fn(v, x, array))) acc.push(v);\n\t\treturn acc;\n\t}, []);\n}\n/**\n* reactive unique array\n* @see https://vueuse.org/useArrayUnique\n* @param list - the array was called upon.\n* @param compareFn\n* @returns A computed ref that returns a unique array of items.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useArrayUnique(list, compareFn) {\n\treturn computed(() => {\n\t\tconst resolvedList = toValue(list).map((element) => toValue(element));\n\t\treturn compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n\t});\n}\n\n//#endregion\n//#region useCounter/index.ts\n/**\n* Basic counter with utility functions.\n*\n* @see https://vueuse.org/useCounter\n* @param [initialValue]\n* @param options\n*/\nfunction useCounter(initialValue = 0, options = {}) {\n\tlet _initialValue = unref(initialValue);\n\tconst count = shallowRef(initialValue);\n\tconst { max = Number.POSITIVE_INFINITY, min = Number.NEGATIVE_INFINITY } = options;\n\tconst inc = (delta = 1) => count.value = Math.max(Math.min(max, count.value + delta), min);\n\tconst dec = (delta = 1) => count.value = Math.min(Math.max(min, count.value - delta), max);\n\tconst get$1 = () => count.value;\n\tconst set$1 = (val) => count.value = Math.max(min, Math.min(max, val));\n\tconst reset = (val = _initialValue) => {\n\t\t_initialValue = val;\n\t\treturn set$1(val);\n\t};\n\treturn {\n\t\tcount: shallowReadonly(count),\n\t\tinc,\n\t\tdec,\n\t\tget: get$1,\n\t\tset: set$1,\n\t\treset\n\t};\n}\n\n//#endregion\n//#region useDateFormat/index.ts\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[T\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/i;\nconst REGEX_FORMAT = /[YMDHhms]o|\\[([^\\]]+)\\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|z{1,4}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n\tlet m = hours < 12 ? \"AM\" : \"PM\";\n\tif (hasPeriod) m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n\treturn isLowercase ? m.toLowerCase() : m;\n}\nfunction formatOrdinal(num) {\n\tconst suffixes = [\n\t\t\"th\",\n\t\t\"st\",\n\t\t\"nd\",\n\t\t\"rd\"\n\t];\n\tconst v = num % 100;\n\treturn num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\n}\nfunction formatDate(date, formatStr, options = {}) {\n\tvar _options$customMeridi;\n\tconst years = date.getFullYear();\n\tconst month = date.getMonth();\n\tconst days = date.getDate();\n\tconst hours = date.getHours();\n\tconst minutes = date.getMinutes();\n\tconst seconds = date.getSeconds();\n\tconst milliseconds = date.getMilliseconds();\n\tconst day = date.getDay();\n\tconst meridiem = (_options$customMeridi = options.customMeridiem) !== null && _options$customMeridi !== void 0 ? _options$customMeridi : defaultMeridiem;\n\tconst stripTimeZone = (dateString) => {\n\t\tvar _dateString$split$;\n\t\treturn (_dateString$split$ = dateString.split(\" \")[1]) !== null && _dateString$split$ !== void 0 ? _dateString$split$ : \"\";\n\t};\n\tconst matches = {\n\t\tYo: () => formatOrdinal(years),\n\t\tYY: () => String(years).slice(-2),\n\t\tYYYY: () => years,\n\t\tM: () => month + 1,\n\t\tMo: () => formatOrdinal(month + 1),\n\t\tMM: () => `${month + 1}`.padStart(2, \"0\"),\n\t\tMMM: () => date.toLocaleDateString(toValue(options.locales), { month: \"short\" }),\n\t\tMMMM: () => date.toLocaleDateString(toValue(options.locales), { month: \"long\" }),\n\t\tD: () => String(days),\n\t\tDo: () => formatOrdinal(days),\n\t\tDD: () => `${days}`.padStart(2, \"0\"),\n\t\tH: () => String(hours),\n\t\tHo: () => formatOrdinal(hours),\n\t\tHH: () => `${hours}`.padStart(2, \"0\"),\n\t\th: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n\t\tho: () => formatOrdinal(hours % 12 || 12),\n\t\thh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n\t\tm: () => String(minutes),\n\t\tmo: () => formatOrdinal(minutes),\n\t\tmm: () => `${minutes}`.padStart(2, \"0\"),\n\t\ts: () => String(seconds),\n\t\tso: () => formatOrdinal(seconds),\n\t\tss: () => `${seconds}`.padStart(2, \"0\"),\n\t\tSSS: () => `${milliseconds}`.padStart(3, \"0\"),\n\t\td: () => day,\n\t\tdd: () => date.toLocaleDateString(toValue(options.locales), { weekday: \"narrow\" }),\n\t\tddd: () => date.toLocaleDateString(toValue(options.locales), { weekday: \"short\" }),\n\t\tdddd: () => date.toLocaleDateString(toValue(options.locales), { weekday: \"long\" }),\n\t\tA: () => meridiem(hours, minutes),\n\t\tAA: () => meridiem(hours, minutes, false, true),\n\t\ta: () => meridiem(hours, minutes, true),\n\t\taa: () => meridiem(hours, minutes, true, true),\n\t\tz: () => stripTimeZone(date.toLocaleDateString(toValue(options.locales), { timeZoneName: \"shortOffset\" })),\n\t\tzz: () => stripTimeZone(date.toLocaleDateString(toValue(options.locales), { timeZoneName: \"shortOffset\" })),\n\t\tzzz: () => stripTimeZone(date.toLocaleDateString(toValue(options.locales), { timeZoneName: \"shortOffset\" })),\n\t\tzzzz: () => stripTimeZone(date.toLocaleDateString(toValue(options.locales), { timeZoneName: \"longOffset\" }))\n\t};\n\treturn formatStr.replace(REGEX_FORMAT, (match, $1) => {\n\t\tvar _ref, _matches$match;\n\t\treturn (_ref = $1 !== null && $1 !== void 0 ? $1 : (_matches$match = matches[match]) === null || _matches$match === void 0 ? void 0 : _matches$match.call(matches)) !== null && _ref !== void 0 ? _ref : match;\n\t});\n}\nfunction normalizeDate(date) {\n\tif (date === null) return /* @__PURE__ */ new Date(NaN);\n\tif (date === void 0) return /* @__PURE__ */ new Date();\n\tif (date instanceof Date) return new Date(date);\n\tif (typeof date === \"string\" && !/Z$/i.test(date)) {\n\t\tconst d = date.match(REGEX_PARSE);\n\t\tif (d) {\n\t\t\tconst m = d[2] - 1 || 0;\n\t\t\tconst ms = (d[7] || \"0\").substring(0, 3);\n\t\t\treturn new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n\t\t}\n\t}\n\treturn new Date(date);\n}\n/**\n* Get the formatted date according to the string of tokens passed in.\n*\n* @see https://vueuse.org/useDateFormat\n* @param date - The date to format, can either be a `Date` object, a timestamp, or a string\n* @param formatStr - The combination of tokens to format the date\n* @param options - UseDateFormatOptions\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n\treturn computed(() => formatDate(normalizeDate(toValue(date)), toValue(formatStr), options));\n}\n\n//#endregion\n//#region useIntervalFn/index.ts\n/**\n* Wrapper for `setInterval` with controls\n*\n* @see https://vueuse.org/useIntervalFn\n* @param cb\n* @param interval\n* @param options\n*/\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n\tconst { immediate = true, immediateCallback = false } = options;\n\tlet timer = null;\n\tconst isActive = shallowRef(false);\n\tfunction clean() {\n\t\tif (timer) {\n\t\t\tclearInterval(timer);\n\t\t\ttimer = null;\n\t\t}\n\t}\n\tfunction pause() {\n\t\tisActive.value = false;\n\t\tclean();\n\t}\n\tfunction resume() {\n\t\tconst intervalValue = toValue(interval);\n\t\tif (intervalValue <= 0) return;\n\t\tisActive.value = true;\n\t\tif (immediateCallback) cb();\n\t\tclean();\n\t\tif (isActive.value) timer = setInterval(cb, intervalValue);\n\t}\n\tif (immediate && isClient) resume();\n\tif (isRef(interval) || typeof interval === \"function\") tryOnScopeDispose(watch(interval, () => {\n\t\tif (isActive.value && isClient) resume();\n\t}));\n\ttryOnScopeDispose(pause);\n\treturn {\n\t\tisActive: shallowReadonly(isActive),\n\t\tpause,\n\t\tresume\n\t};\n}\n\n//#endregion\n//#region useInterval/index.ts\nfunction useInterval(interval = 1e3, options = {}) {\n\tconst { controls: exposeControls = false, immediate = true, callback } = options;\n\tconst counter = shallowRef(0);\n\tconst update = () => counter.value += 1;\n\tconst reset = () => {\n\t\tcounter.value = 0;\n\t};\n\tconst controls = useIntervalFn(callback ? () => {\n\t\tupdate();\n\t\tcallback(counter.value);\n\t} : update, interval, { immediate });\n\tif (exposeControls) return {\n\t\tcounter: shallowReadonly(counter),\n\t\treset,\n\t\t...controls\n\t};\n\telse return shallowReadonly(counter);\n}\n\n//#endregion\n//#region useLastChanged/index.ts\nfunction useLastChanged(source, options = {}) {\n\tvar _options$initialValue;\n\tconst ms = shallowRef((_options$initialValue = options.initialValue) !== null && _options$initialValue !== void 0 ? _options$initialValue : null);\n\twatch(source, () => ms.value = timestamp(), options);\n\treturn shallowReadonly(ms);\n}\n\n//#endregion\n//#region useTimeoutFn/index.ts\n/**\n* Wrapper for `setTimeout` with controls.\n*\n* @param cb\n* @param interval\n* @param options\n*/\nfunction useTimeoutFn(cb, interval, options = {}) {\n\tconst { immediate = true, immediateCallback = false } = options;\n\tconst isPending = shallowRef(false);\n\tlet timer;\n\tfunction clear() {\n\t\tif (timer) {\n\t\t\tclearTimeout(timer);\n\t\t\ttimer = void 0;\n\t\t}\n\t}\n\tfunction stop() {\n\t\tisPending.value = false;\n\t\tclear();\n\t}\n\tfunction start(...args) {\n\t\tif (immediateCallback) cb();\n\t\tclear();\n\t\tisPending.value = true;\n\t\ttimer = setTimeout(() => {\n\t\t\tisPending.value = false;\n\t\t\ttimer = void 0;\n\t\t\tcb(...args);\n\t\t}, toValue(interval));\n\t}\n\tif (immediate) {\n\t\tisPending.value = true;\n\t\tif (isClient) start();\n\t}\n\ttryOnScopeDispose(stop);\n\treturn {\n\t\tisPending: shallowReadonly(isPending),\n\t\tstart,\n\t\tstop\n\t};\n}\n\n//#endregion\n//#region useTimeout/index.ts\nfunction useTimeout(interval = 1e3, options = {}) {\n\tconst { controls: exposeControls = false, callback } = options;\n\tconst controls = useTimeoutFn(callback !== null && callback !== void 0 ? callback : noop, interval, options);\n\tconst ready = computed(() => !controls.isPending.value);\n\tif (exposeControls) return {\n\t\tready,\n\t\t...controls\n\t};\n\telse return ready;\n}\n\n//#endregion\n//#region useToNumber/index.ts\n/**\n* Reactively convert a string ref to number.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useToNumber(value, options = {}) {\n\tconst { method = \"parseFloat\", radix, nanToZero } = options;\n\treturn computed(() => {\n\t\tlet resolved = toValue(value);\n\t\tif (typeof method === \"function\") resolved = method(resolved);\n\t\telse if (typeof resolved === \"string\") resolved = Number[method](resolved, radix);\n\t\tif (nanToZero && Number.isNaN(resolved)) resolved = 0;\n\t\treturn resolved;\n\t});\n}\n\n//#endregion\n//#region useToString/index.ts\n/**\n* Reactively convert a ref to string.\n*\n* @see https://vueuse.org/useToString\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useToString(value) {\n\treturn computed(() => `${toValue(value)}`);\n}\n\n//#endregion\n//#region useToggle/index.ts\n/**\n* A boolean ref with a toggler\n*\n* @see https://vueuse.org/useToggle\n* @param [initialValue]\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useToggle(initialValue = false, options = {}) {\n\tconst { truthyValue = true, falsyValue = false } = options;\n\tconst valueIsRef = isRef(initialValue);\n\tconst _value = shallowRef(initialValue);\n\tfunction toggle(value) {\n\t\tif (arguments.length) {\n\t\t\t_value.value = value;\n\t\t\treturn _value.value;\n\t\t} else {\n\t\t\tconst truthy = toValue(truthyValue);\n\t\t\t_value.value = _value.value === truthy ? toValue(falsyValue) : truthy;\n\t\t\treturn _value.value;\n\t\t}\n\t}\n\tif (valueIsRef) return toggle;\n\telse return [_value, toggle];\n}\n\n//#endregion\n//#region watchArray/index.ts\n/**\n* Watch for an array with additions and removals.\n*\n* @see https://vueuse.org/watchArray\n*/\nfunction watchArray(source, cb, options) {\n\tlet oldList = (options === null || options === void 0 ? void 0 : options.immediate) ? [] : [...typeof source === \"function\" ? source() : Array.isArray(source) ? source : toValue(source)];\n\treturn watch(source, (newList, _, onCleanup) => {\n\t\tconst oldListRemains = Array.from({ length: oldList.length });\n\t\tconst added = [];\n\t\tfor (const obj of newList) {\n\t\t\tlet found = false;\n\t\t\tfor (let i = 0; i < oldList.length; i++) if (!oldListRemains[i] && obj === oldList[i]) {\n\t\t\t\toldListRemains[i] = true;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!found) added.push(obj);\n\t\t}\n\t\tconst removed = oldList.filter((_$1, i) => !oldListRemains[i]);\n\t\tcb(newList, oldList, added, removed, onCleanup);\n\t\toldList = [...newList];\n\t}, options);\n}\n\n//#endregion\n//#region watchAtMost/index.ts\nfunction watchAtMost(source, cb, options) {\n\tconst { count,...watchOptions } = options;\n\tconst current = shallowRef(0);\n\tconst { stop, resume, pause } = watchWithFilter(source, (...args) => {\n\t\tcurrent.value += 1;\n\t\tif (current.value >= toValue(count)) nextTick(() => stop());\n\t\tcb(...args);\n\t}, watchOptions);\n\treturn {\n\t\tcount: current,\n\t\tstop,\n\t\tresume,\n\t\tpause\n\t};\n}\n\n//#endregion\n//#region watchDebounced/index.ts\nfunction watchDebounced(source, cb, options = {}) {\n\tconst { debounce = 0, maxWait = void 0,...watchOptions } = options;\n\treturn watchWithFilter(source, cb, {\n\t\t...watchOptions,\n\t\teventFilter: debounceFilter(debounce, { maxWait })\n\t});\n}\n/** @deprecated use `watchDebounced` instead */\nconst debouncedWatch = watchDebounced;\n\n//#endregion\n//#region watchDeep/index.ts\n/**\n* Shorthand for watching value with {deep: true}\n*\n* @see https://vueuse.org/watchDeep\n*/\nfunction watchDeep(source, cb, options) {\n\treturn watch(source, cb, {\n\t\t...options,\n\t\tdeep: true\n\t});\n}\n\n//#endregion\n//#region watchIgnorable/index.ts\nfunction watchIgnorable(source, cb, options = {}) {\n\tconst { eventFilter = bypassFilter,...watchOptions } = options;\n\tconst filteredCb = createFilterWrapper(eventFilter, cb);\n\tlet ignoreUpdates;\n\tlet ignorePrevAsyncUpdates;\n\tlet stop;\n\tif (watchOptions.flush === \"sync\") {\n\t\tlet ignore = false;\n\t\tignorePrevAsyncUpdates = () => {};\n\t\tignoreUpdates = (updater) => {\n\t\t\tignore = true;\n\t\t\tupdater();\n\t\t\tignore = false;\n\t\t};\n\t\tstop = watch(source, (...args) => {\n\t\t\tif (!ignore) filteredCb(...args);\n\t\t}, watchOptions);\n\t} else {\n\t\tconst disposables = [];\n\t\tlet ignoreCounter = 0;\n\t\tlet syncCounter = 0;\n\t\tignorePrevAsyncUpdates = () => {\n\t\t\tignoreCounter = syncCounter;\n\t\t};\n\t\tdisposables.push(watch(source, () => {\n\t\t\tsyncCounter++;\n\t\t}, {\n\t\t\t...watchOptions,\n\t\t\tflush: \"sync\"\n\t\t}));\n\t\tignoreUpdates = (updater) => {\n\t\t\tconst syncCounterPrev = syncCounter;\n\t\t\tupdater();\n\t\t\tignoreCounter += syncCounter - syncCounterPrev;\n\t\t};\n\t\tdisposables.push(watch(source, (...args) => {\n\t\t\tconst ignore = ignoreCounter > 0 && ignoreCounter === syncCounter;\n\t\t\tignoreCounter = 0;\n\t\t\tsyncCounter = 0;\n\t\t\tif (ignore) return;\n\t\t\tfilteredCb(...args);\n\t\t}, watchOptions));\n\t\tstop = () => {\n\t\t\tdisposables.forEach((fn) => fn());\n\t\t};\n\t}\n\treturn {\n\t\tstop,\n\t\tignoreUpdates,\n\t\tignorePrevAsyncUpdates\n\t};\n}\n/** @deprecated use `watchIgnorable` instead */\nconst ignorableWatch = watchIgnorable;\n\n//#endregion\n//#region watchImmediate/index.ts\n/**\n* Shorthand for watching value with {immediate: true}\n*\n* @see https://vueuse.org/watchImmediate\n*/\nfunction watchImmediate(source, cb, options) {\n\treturn watch(source, cb, {\n\t\t...options,\n\t\timmediate: true\n\t});\n}\n\n//#endregion\n//#region watchOnce/index.ts\n/**\n* Shorthand for watching value with { once: true }\n*\n* @see https://vueuse.org/watchOnce\n*/\nfunction watchOnce(source, cb, options) {\n\treturn watch(source, cb, {\n\t\t...options,\n\t\tonce: true\n\t});\n}\n\n//#endregion\n//#region watchThrottled/index.ts\nfunction watchThrottled(source, cb, options = {}) {\n\tconst { throttle = 0, trailing = true, leading = true,...watchOptions } = options;\n\treturn watchWithFilter(source, cb, {\n\t\t...watchOptions,\n\t\teventFilter: throttleFilter(throttle, trailing, leading)\n\t});\n}\n/** @deprecated use `watchThrottled` instead */\nconst throttledWatch = watchThrottled;\n\n//#endregion\n//#region watchTriggerable/index.ts\nfunction watchTriggerable(source, cb, options = {}) {\n\tlet cleanupFn;\n\tfunction onEffect() {\n\t\tif (!cleanupFn) return;\n\t\tconst fn = cleanupFn;\n\t\tcleanupFn = void 0;\n\t\tfn();\n\t}\n\t/** Register the function `cleanupFn` */\n\tfunction onCleanup(callback) {\n\t\tcleanupFn = callback;\n\t}\n\tconst _cb = (value, oldValue) => {\n\t\tonEffect();\n\t\treturn cb(value, oldValue, onCleanup);\n\t};\n\tconst res = watchIgnorable(source, _cb, options);\n\tconst { ignoreUpdates } = res;\n\tconst trigger = () => {\n\t\tlet res$1;\n\t\tignoreUpdates(() => {\n\t\t\tres$1 = _cb(getWatchSources(source), getOldValue(source));\n\t\t});\n\t\treturn res$1;\n\t};\n\treturn {\n\t\t...res,\n\t\ttrigger\n\t};\n}\nfunction getWatchSources(sources) {\n\tif (isReactive(sources)) return sources;\n\tif (Array.isArray(sources)) return sources.map((item) => toValue(item));\n\treturn toValue(sources);\n}\nfunction getOldValue(source) {\n\treturn Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\n//#endregion\n//#region whenever/index.ts\n/**\n* Shorthand for watching value to be truthy\n*\n* @see https://vueuse.org/whenever\n*/\nfunction whenever(source, cb, options) {\n\tconst stop = watch(source, (v, ov, onInvalidate) => {\n\t\tif (v) {\n\t\t\tif (options === null || options === void 0 ? void 0 : options.once) nextTick(() => stop());\n\t\t\tcb(v, ov, onInvalidate);\n\t\t}\n\t}, {\n\t\t...options,\n\t\tonce: false\n\t});\n\treturn stop;\n}\n\n//#endregion\nexport { assert, autoResetRef, bypassFilter, camelize, clamp, computedEager, computedWithControl, containsProp, controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, createReactiveFn, createRef, createSharedComposable, createSingletonPromise, debounceFilter, debouncedRef, debouncedWatch, eagerComputed, extendRef, formatDate, get, getLifeCycleTarget, hasOwn, hyphenate, identity, ignorableWatch, increaseWithUnit, injectLocal, invoke, isClient, isDef, isDefined, isIOS, isObject, isWorker, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, pausableWatch, promiseTimeout, provideLocal, pxValue, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refManualReset, refThrottled, refWithControl, set, syncRef, syncRefs, throttleFilter, throttledRef, throttledWatch, timestamp, toArray, toReactive, toRef, toRefs, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };","import { bypassFilter, camelize, clamp, computedWithControl, containsProp, createEventHook, createFilterWrapper, createRef, createSingletonPromise, debounceFilter, hasOwn, identity, increaseWithUnit, injectLocal, isClient, isDef, isIOS, isObject, isWorker, makeDestructurable, noop, notNullish, objectEntries, objectOmit, objectPick, pausableFilter, promiseTimeout, provideLocal, pxValue, syncRef, throttleFilter, timestamp, toArray, toRef, toRefs, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useDebounceFn, useIntervalFn, useThrottleFn, useTimeoutFn, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchWithFilter, whenever } from \"@vueuse/shared\";\nimport { Fragment, TransitionGroup, computed, customRef, defineComponent, getCurrentInstance, getCurrentScope, h, hasInjectionContext, inject, isReadonly, isRef, markRaw, nextTick, onBeforeUpdate, onMounted, onUpdated, reactive, readonly, ref, shallowReactive, shallowReadonly, shallowRef, toRaw, toValue, unref, watch, watchEffect } from \"vue\";\n\nexport * from \"@vueuse/shared\"\n\n//#region computedAsync/index.ts\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n\tvar _globalThis$reportErr;\n\tlet options;\n\tif (isRef(optionsOrRef)) options = { evaluating: optionsOrRef };\n\telse options = optionsOrRef || {};\n\tconst { lazy = false, flush = \"sync\", evaluating = void 0, shallow = true, onError = (_globalThis$reportErr = globalThis.reportError) !== null && _globalThis$reportErr !== void 0 ? _globalThis$reportErr : noop } = options;\n\tconst started = shallowRef(!lazy);\n\tconst current = shallow ? shallowRef(initialState) : ref(initialState);\n\tlet counter = 0;\n\twatchEffect(async (onInvalidate) => {\n\t\tif (!started.value) return;\n\t\tcounter++;\n\t\tconst counterAtBeginning = counter;\n\t\tlet hasFinished = false;\n\t\tif (evaluating) Promise.resolve().then(() => {\n\t\t\tevaluating.value = true;\n\t\t});\n\t\ttry {\n\t\t\tconst result = await evaluationCallback((cancelCallback) => {\n\t\t\t\tonInvalidate(() => {\n\t\t\t\t\tif (evaluating) evaluating.value = false;\n\t\t\t\t\tif (!hasFinished) cancelCallback();\n\t\t\t\t});\n\t\t\t});\n\t\t\tif (counterAtBeginning === counter) current.value = result;\n\t\t} catch (e) {\n\t\t\tonError(e);\n\t\t} finally {\n\t\t\tif (evaluating && counterAtBeginning === counter) evaluating.value = false;\n\t\t\thasFinished = true;\n\t\t}\n\t}, { flush });\n\tif (lazy) return computed(() => {\n\t\tstarted.value = true;\n\t\treturn current.value;\n\t});\n\telse return current;\n}\n/** @deprecated use `computedAsync` instead */\nconst asyncComputed = computedAsync;\n\n//#endregion\n//#region computedInject/index.ts\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n\tlet source = inject(key);\n\tif (defaultSource) source = inject(key, defaultSource);\n\tif (treatDefaultAsFactory) source = inject(key, defaultSource, treatDefaultAsFactory);\n\tif (typeof options === \"function\") return computed((oldValue) => options(source, oldValue));\n\telse return computed({\n\t\tget: (oldValue) => options.get(source, oldValue),\n\t\tset: options.set\n\t});\n}\n\n//#endregion\n//#region createReusableTemplate/index.ts\n/**\n* This function creates `define` and `reuse` components in pair,\n* It also allow to pass a generic to bind with type.\n*\n* @see https://vueuse.org/createReusableTemplate\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction createReusableTemplate(options = {}) {\n\tconst { inheritAttrs = true } = options;\n\tconst render = shallowRef();\n\tconst define = defineComponent({ setup(_, { slots }) {\n\t\treturn () => {\n\t\t\trender.value = slots.default;\n\t\t};\n\t} });\n\tconst reuse = defineComponent({\n\t\tinheritAttrs,\n\t\tprops: options.props,\n\t\tsetup(props, { attrs, slots }) {\n\t\t\treturn () => {\n\t\t\t\tvar _render$value;\n\t\t\t\tif (!render.value && true) throw new Error(\"[VueUse] Failed to find the definition of reusable template\");\n\t\t\t\tconst vnode = (_render$value = render.value) === null || _render$value === void 0 ? void 0 : _render$value.call(render, {\n\t\t\t\t\t...options.props == null ? keysToCamelKebabCase(attrs) : props,\n\t\t\t\t\t$slots: slots\n\t\t\t\t});\n\t\t\t\treturn inheritAttrs && (vnode === null || vnode === void 0 ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;\n\t\t\t};\n\t\t}\n\t});\n\treturn makeDestructurable({\n\t\tdefine,\n\t\treuse\n\t}, [define, reuse]);\n}\nfunction keysToCamelKebabCase(obj) {\n\tconst newObj = {};\n\tfor (const key in obj) newObj[camelize(key)] = obj[key];\n\treturn newObj;\n}\n\n//#endregion\n//#region createTemplatePromise/index.ts\n/**\n* Creates a template promise component.\n*\n* @see https://vueuse.org/createTemplatePromise\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction createTemplatePromise(options = {}) {\n\tlet index = 0;\n\tconst instances = ref([]);\n\tfunction create(...args) {\n\t\tconst props = shallowReactive({\n\t\t\tkey: index++,\n\t\t\targs,\n\t\t\tpromise: void 0,\n\t\t\tresolve: () => {},\n\t\t\treject: () => {},\n\t\t\tisResolving: false,\n\t\t\toptions\n\t\t});\n\t\tinstances.value.push(props);\n\t\tprops.promise = new Promise((_resolve, _reject) => {\n\t\t\tprops.resolve = (v) => {\n\t\t\t\tprops.isResolving = true;\n\t\t\t\treturn _resolve(v);\n\t\t\t};\n\t\t\tprops.reject = _reject;\n\t\t}).finally(() => {\n\t\t\tprops.promise = void 0;\n\t\t\tconst index$1 = instances.value.indexOf(props);\n\t\t\tif (index$1 !== -1) instances.value.splice(index$1, 1);\n\t\t});\n\t\treturn props.promise;\n\t}\n\tfunction start(...args) {\n\t\tif (options.singleton && instances.value.length > 0) return instances.value[0].promise;\n\t\treturn create(...args);\n\t}\n\tconst component = defineComponent((_, { slots }) => {\n\t\tconst renderList = () => instances.value.map((props) => {\n\t\t\tvar _slots$default;\n\t\t\treturn h(Fragment, { key: props.key }, (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots, props));\n\t\t});\n\t\tif (options.transition) return () => h(TransitionGroup, options.transition, renderList);\n\t\treturn renderList;\n\t});\n\tcomponent.start = start;\n\treturn component;\n}\n\n//#endregion\n//#region createUnrefFn/index.ts\n/**\n* Make a plain function accepting ref and raw values as arguments.\n* Returns the same value the unconverted function returns, with proper typing.\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction createUnrefFn(fn) {\n\treturn function(...args) {\n\t\treturn fn.apply(this, args.map((i) => toValue(i)));\n\t};\n}\n\n//#endregion\n//#region _configurable.ts\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\n//#endregion\n//#region unrefElement/index.ts\n/**\n* Get the dom element of a ref of element or Vue component instance\n*\n* @param elRef\n*/\nfunction unrefElement(elRef) {\n\tvar _$el;\n\tconst plain = toValue(elRef);\n\treturn (_$el = plain === null || plain === void 0 ? void 0 : plain.$el) !== null && _$el !== void 0 ? _$el : plain;\n}\n\n//#endregion\n//#region useEventListener/index.ts\nfunction useEventListener(...args) {\n\tconst register = (el, event, listener, options) => {\n\t\tel.addEventListener(event, listener, options);\n\t\treturn () => el.removeEventListener(event, listener, options);\n\t};\n\tconst firstParamTargets = computed(() => {\n\t\tconst test = toArray(toValue(args[0])).filter((e) => e != null);\n\t\treturn test.every((e) => typeof e !== \"string\") ? test : void 0;\n\t});\n\treturn watchImmediate(() => {\n\t\tvar _firstParamTargets$va, _firstParamTargets$va2;\n\t\treturn [\n\t\t\t(_firstParamTargets$va = (_firstParamTargets$va2 = firstParamTargets.value) === null || _firstParamTargets$va2 === void 0 ? void 0 : _firstParamTargets$va2.map((e) => unrefElement(e))) !== null && _firstParamTargets$va !== void 0 ? _firstParamTargets$va : [defaultWindow].filter((e) => e != null),\n\t\t\ttoArray(toValue(firstParamTargets.value ? args[1] : args[0])),\n\t\t\ttoArray(unref(firstParamTargets.value ? args[2] : args[1])),\n\t\t\ttoValue(firstParamTargets.value ? args[3] : args[2])\n\t\t];\n\t}, ([raw_targets, raw_events, raw_listeners, raw_options], _, onCleanup) => {\n\t\tif (!(raw_targets === null || raw_targets === void 0 ? void 0 : raw_targets.length) || !(raw_events === null || raw_events === void 0 ? void 0 : raw_events.length) || !(raw_listeners === null || raw_listeners === void 0 ? void 0 : raw_listeners.length)) return;\n\t\tconst optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;\n\t\tconst cleanups = raw_targets.flatMap((el) => raw_events.flatMap((event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))));\n\t\tonCleanup(() => {\n\t\t\tcleanups.forEach((fn) => fn());\n\t\t});\n\t}, { flush: \"post\" });\n}\n\n//#endregion\n//#region onClickOutside/index.ts\nlet _iOSWorkaround = false;\nfunction onClickOutside(target, handler, options = {}) {\n\tconst { window: window$1 = defaultWindow, ignore = [], capture = true, detectIframe = false, controls = false } = options;\n\tif (!window$1) return controls ? {\n\t\tstop: noop,\n\t\tcancel: noop,\n\t\ttrigger: noop\n\t} : noop;\n\tif (isIOS && !_iOSWorkaround) {\n\t\t_iOSWorkaround = true;\n\t\tconst listenerOptions = { passive: true };\n\t\tArray.from(window$1.document.body.children).forEach((el) => el.addEventListener(\"click\", noop, listenerOptions));\n\t\twindow$1.document.documentElement.addEventListener(\"click\", noop, listenerOptions);\n\t}\n\tlet shouldListen = true;\n\tconst shouldIgnore = (event) => {\n\t\treturn toValue(ignore).some((target$1) => {\n\t\t\tif (typeof target$1 === \"string\") return Array.from(window$1.document.querySelectorAll(target$1)).some((el) => el === event.target || event.composedPath().includes(el));\n\t\t\telse {\n\t\t\t\tconst el = unrefElement(target$1);\n\t\t\t\treturn el && (event.target === el || event.composedPath().includes(el));\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t* Determines if the given target has multiple root elements.\n\t* Referenced from: https://github.com/vuejs/test-utils/blob/ccb460be55f9f6be05ab708500a41ec8adf6f4bc/src/vue-wrapper.ts#L21\n\t*/\n\tfunction hasMultipleRoots(target$1) {\n\t\tconst vm = toValue(target$1);\n\t\treturn vm && vm.$.subTree.shapeFlag === 16;\n\t}\n\tfunction checkMultipleRoots(target$1, event) {\n\t\tconst vm = toValue(target$1);\n\t\tconst children = vm.$.subTree && vm.$.subTree.children;\n\t\tif (children == null || !Array.isArray(children)) return false;\n\t\treturn children.some((child) => child.el === event.target || event.composedPath().includes(child.el));\n\t}\n\tconst listener = (event) => {\n\t\tconst el = unrefElement(target);\n\t\tif (event.target == null) return;\n\t\tif (!(el instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event)) return;\n\t\tif (!el || el === event.target || event.composedPath().includes(el)) return;\n\t\tif (\"detail\" in event && event.detail === 0) shouldListen = !shouldIgnore(event);\n\t\tif (!shouldListen) {\n\t\t\tshouldListen = true;\n\t\t\treturn;\n\t\t}\n\t\thandler(event);\n\t};\n\tlet isProcessingClick = false;\n\tconst cleanup = [\n\t\tuseEventListener(window$1, \"click\", (event) => {\n\t\t\tif (!isProcessingClick) {\n\t\t\t\tisProcessingClick = true;\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tisProcessingClick = false;\n\t\t\t\t}, 0);\n\t\t\t\tlistener(event);\n\t\t\t}\n\t\t}, {\n\t\t\tpassive: true,\n\t\t\tcapture\n\t\t}),\n\t\tuseEventListener(window$1, \"pointerdown\", (e) => {\n\t\t\tconst el = unrefElement(target);\n\t\t\tshouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));\n\t\t}, { passive: true }),\n\t\tdetectIframe && useEventListener(window$1, \"blur\", (event) => {\n\t\t\tsetTimeout(() => {\n\t\t\t\tvar _window$document$acti;\n\t\t\t\tconst el = unrefElement(target);\n\t\t\t\tif (((_window$document$acti = window$1.document.activeElement) === null || _window$document$acti === void 0 ? void 0 : _window$document$acti.tagName) === \"IFRAME\" && !(el === null || el === void 0 ? void 0 : el.contains(window$1.document.activeElement))) handler(event);\n\t\t\t}, 0);\n\t\t}, { passive: true })\n\t].filter(Boolean);\n\tconst stop = () => cleanup.forEach((fn) => fn());\n\tif (controls) return {\n\t\tstop,\n\t\tcancel: () => {\n\t\t\tshouldListen = false;\n\t\t},\n\t\ttrigger: (event) => {\n\t\t\tshouldListen = true;\n\t\t\tlistener(event);\n\t\t\tshouldListen = false;\n\t\t}\n\t};\n\treturn stop;\n}\n\n//#endregion\n//#region useMounted/index.ts\n/**\n* Mounted state in ref.\n*\n* @see https://vueuse.org/useMounted\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useMounted() {\n\tconst isMounted = shallowRef(false);\n\tconst instance = getCurrentInstance();\n\tif (instance) onMounted(() => {\n\t\tisMounted.value = true;\n\t}, instance);\n\treturn isMounted;\n}\n\n//#endregion\n//#region useSupported/index.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction useSupported(callback) {\n\tconst isMounted = useMounted();\n\treturn computed(() => {\n\t\tisMounted.value;\n\t\treturn Boolean(callback());\n\t});\n}\n\n//#endregion\n//#region useMutationObserver/index.ts\n/**\n* Watch for changes being made to the DOM tree.\n*\n* @see https://vueuse.org/useMutationObserver\n* @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver MutationObserver MDN\n* @param target\n* @param callback\n* @param options\n*/\nfunction useMutationObserver(target, callback, options = {}) {\n\tconst { window: window$1 = defaultWindow,...mutationOptions } = options;\n\tlet observer;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => window$1 && \"MutationObserver\" in window$1);\n\tconst cleanup = () => {\n\t\tif (observer) {\n\t\t\tobserver.disconnect();\n\t\t\tobserver = void 0;\n\t\t}\n\t};\n\tconst stopWatch = watch(computed(() => {\n\t\tconst items = toArray(toValue(target)).map(unrefElement).filter(notNullish);\n\t\treturn new Set(items);\n\t}), (newTargets) => {\n\t\tcleanup();\n\t\tif (isSupported.value && newTargets.size) {\n\t\t\tobserver = new MutationObserver(callback);\n\t\t\tnewTargets.forEach((el) => observer.observe(el, mutationOptions));\n\t\t}\n\t}, {\n\t\timmediate: true,\n\t\tflush: \"post\"\n\t});\n\tconst takeRecords = () => {\n\t\treturn observer === null || observer === void 0 ? void 0 : observer.takeRecords();\n\t};\n\tconst stop = () => {\n\t\tstopWatch();\n\t\tcleanup();\n\t};\n\ttryOnScopeDispose(stop);\n\treturn {\n\t\tisSupported,\n\t\tstop,\n\t\ttakeRecords\n\t};\n}\n\n//#endregion\n//#region onElementRemoval/index.ts\n/**\n* Fires when the element or any element containing it is removed.\n*\n* @param target\n* @param callback\n* @param options\n*/\nfunction onElementRemoval(target, callback, options = {}) {\n\tconst { window: window$1 = defaultWindow, document: document$1 = window$1 === null || window$1 === void 0 ? void 0 : window$1.document, flush = \"sync\" } = options;\n\tif (!window$1 || !document$1) return noop;\n\tlet stopFn;\n\tconst cleanupAndUpdate = (fn) => {\n\t\tstopFn === null || stopFn === void 0 || stopFn();\n\t\tstopFn = fn;\n\t};\n\tconst stopWatch = watchEffect(() => {\n\t\tconst el = unrefElement(target);\n\t\tif (el) {\n\t\t\tconst { stop } = useMutationObserver(document$1, (mutationsList) => {\n\t\t\t\tif (mutationsList.map((mutation) => [...mutation.removedNodes]).flat().some((node) => node === el || node.contains(el))) callback(mutationsList);\n\t\t\t}, {\n\t\t\t\twindow: window$1,\n\t\t\t\tchildList: true,\n\t\t\t\tsubtree: true\n\t\t\t});\n\t\t\tcleanupAndUpdate(stop);\n\t\t}\n\t}, { flush });\n\tconst stopHandle = () => {\n\t\tstopWatch();\n\t\tcleanupAndUpdate();\n\t};\n\ttryOnScopeDispose(stopHandle);\n\treturn stopHandle;\n}\n\n//#endregion\n//#region onKeyStroke/index.ts\nfunction createKeyPredicate(keyFilter) {\n\tif (typeof keyFilter === \"function\") return keyFilter;\n\telse if (typeof keyFilter === \"string\") return (event) => event.key === keyFilter;\n\telse if (Array.isArray(keyFilter)) return (event) => keyFilter.includes(event.key);\n\treturn () => true;\n}\nfunction onKeyStroke(...args) {\n\tlet key;\n\tlet handler;\n\tlet options = {};\n\tif (args.length === 3) {\n\t\tkey = args[0];\n\t\thandler = args[1];\n\t\toptions = args[2];\n\t} else if (args.length === 2) if (typeof args[1] === \"object\") {\n\t\tkey = true;\n\t\thandler = args[0];\n\t\toptions = args[1];\n\t} else {\n\t\tkey = args[0];\n\t\thandler = args[1];\n\t}\n\telse {\n\t\tkey = true;\n\t\thandler = args[0];\n\t}\n\tconst { target = defaultWindow, eventName = \"keydown\", passive = false, dedupe = false } = options;\n\tconst predicate = createKeyPredicate(key);\n\tconst listener = (e) => {\n\t\tif (e.repeat && toValue(dedupe)) return;\n\t\tif (predicate(e)) handler(e);\n\t};\n\treturn useEventListener(target, eventName, listener, passive);\n}\n/**\n* Listen to the keydown event of the given key.\n*\n* @see https://vueuse.org/onKeyStroke\n* @param key\n* @param handler\n* @param options\n*/\nfunction onKeyDown(key, handler, options = {}) {\n\treturn onKeyStroke(key, handler, {\n\t\t...options,\n\t\teventName: \"keydown\"\n\t});\n}\n/**\n* Listen to the keypress event of the given key.\n*\n* @see https://vueuse.org/onKeyStroke\n* @param key\n* @param handler\n* @param options\n*/\nfunction onKeyPressed(key, handler, options = {}) {\n\treturn onKeyStroke(key, handler, {\n\t\t...options,\n\t\teventName: \"keypress\"\n\t});\n}\n/**\n* Listen to the keyup event of the given key.\n*\n* @see https://vueuse.org/onKeyStroke\n* @param key\n* @param handler\n* @param options\n*/\nfunction onKeyUp(key, handler, options = {}) {\n\treturn onKeyStroke(key, handler, {\n\t\t...options,\n\t\teventName: \"keyup\"\n\t});\n}\n\n//#endregion\n//#region onLongPress/index.ts\nconst DEFAULT_DELAY = 500;\nconst DEFAULT_THRESHOLD = 10;\nfunction onLongPress(target, handler, options) {\n\tvar _options$modifiers10, _options$modifiers11;\n\tconst elementRef = computed(() => unrefElement(target));\n\tlet timeout;\n\tlet posStart;\n\tlet startTimestamp;\n\tlet hasLongPressed = false;\n\tfunction clear() {\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = void 0;\n\t\t}\n\t\tposStart = void 0;\n\t\tstartTimestamp = void 0;\n\t\thasLongPressed = false;\n\t}\n\tfunction getDelay(ev) {\n\t\tconst delay = options === null || options === void 0 ? void 0 : options.delay;\n\t\tif (typeof delay === \"function\") return delay(ev);\n\t\treturn delay !== null && delay !== void 0 ? delay : DEFAULT_DELAY;\n\t}\n\tfunction onRelease(ev) {\n\t\tvar _options$modifiers, _options$modifiers2, _options$modifiers3;\n\t\tconst [_startTimestamp, _posStart, _hasLongPressed] = [\n\t\t\tstartTimestamp,\n\t\t\tposStart,\n\t\t\thasLongPressed\n\t\t];\n\t\tclear();\n\t\tif (!(options === null || options === void 0 ? void 0 : options.onMouseUp) || !_posStart || !_startTimestamp) return;\n\t\tif ((options === null || options === void 0 || (_options$modifiers = options.modifiers) === null || _options$modifiers === void 0 ? void 0 : _options$modifiers.self) && ev.target !== elementRef.value) return;\n\t\tif (options === null || options === void 0 || (_options$modifiers2 = options.modifiers) === null || _options$modifiers2 === void 0 ? void 0 : _options$modifiers2.prevent) ev.preventDefault();\n\t\tif (options === null || options === void 0 || (_options$modifiers3 = options.modifiers) === null || _options$modifiers3 === void 0 ? void 0 : _options$modifiers3.stop) ev.stopPropagation();\n\t\tconst dx = ev.x - _posStart.x;\n\t\tconst dy = ev.y - _posStart.y;\n\t\tconst distance = Math.sqrt(dx * dx + dy * dy);\n\t\toptions.onMouseUp(ev.timeStamp - _startTimestamp, distance, _hasLongPressed);\n\t}\n\tfunction onDown(ev) {\n\t\tvar _options$modifiers4, _options$modifiers5, _options$modifiers6;\n\t\tif ((options === null || options === void 0 || (_options$modifiers4 = options.modifiers) === null || _options$modifiers4 === void 0 ? void 0 : _options$modifiers4.self) && ev.target !== elementRef.value) return;\n\t\tclear();\n\t\tif (options === null || options === void 0 || (_options$modifiers5 = options.modifiers) === null || _options$modifiers5 === void 0 ? void 0 : _options$modifiers5.prevent) ev.preventDefault();\n\t\tif (options === null || options === void 0 || (_options$modifiers6 = options.modifiers) === null || _options$modifiers6 === void 0 ? void 0 : _options$modifiers6.stop) ev.stopPropagation();\n\t\tposStart = {\n\t\t\tx: ev.x,\n\t\t\ty: ev.y\n\t\t};\n\t\tstartTimestamp = ev.timeStamp;\n\t\ttimeout = setTimeout(() => {\n\t\t\thasLongPressed = true;\n\t\t\thandler(ev);\n\t\t}, getDelay(ev));\n\t}\n\tfunction onMove(ev) {\n\t\tvar _options$modifiers7, _options$modifiers8, _options$modifiers9, _options$distanceThre;\n\t\tif ((options === null || options === void 0 || (_options$modifiers7 = options.modifiers) === null || _options$modifiers7 === void 0 ? void 0 : _options$modifiers7.self) && ev.target !== elementRef.value) return;\n\t\tif (!posStart || (options === null || options === void 0 ? void 0 : options.distanceThreshold) === false) return;\n\t\tif (options === null || options === void 0 || (_options$modifiers8 = options.modifiers) === null || _options$modifiers8 === void 0 ? void 0 : _options$modifiers8.prevent) ev.preventDefault();\n\t\tif (options === null || options === void 0 || (_options$modifiers9 = options.modifiers) === null || _options$modifiers9 === void 0 ? void 0 : _options$modifiers9.stop) ev.stopPropagation();\n\t\tconst dx = ev.x - posStart.x;\n\t\tconst dy = ev.y - posStart.y;\n\t\tif (Math.sqrt(dx * dx + dy * dy) >= ((_options$distanceThre = options === null || options === void 0 ? void 0 : options.distanceThreshold) !== null && _options$distanceThre !== void 0 ? _options$distanceThre : DEFAULT_THRESHOLD)) clear();\n\t}\n\tconst listenerOptions = {\n\t\tcapture: options === null || options === void 0 || (_options$modifiers10 = options.modifiers) === null || _options$modifiers10 === void 0 ? void 0 : _options$modifiers10.capture,\n\t\tonce: options === null || options === void 0 || (_options$modifiers11 = options.modifiers) === null || _options$modifiers11 === void 0 ? void 0 : _options$modifiers11.once\n\t};\n\tconst cleanup = [\n\t\tuseEventListener(elementRef, \"pointerdown\", onDown, listenerOptions),\n\t\tuseEventListener(elementRef, \"pointermove\", onMove, listenerOptions),\n\t\tuseEventListener(elementRef, [\"pointerup\", \"pointerleave\"], onRelease, listenerOptions)\n\t];\n\tconst stop = () => cleanup.forEach((fn) => fn());\n\treturn stop;\n}\n\n//#endregion\n//#region onStartTyping/index.ts\nfunction isFocusedElementEditable() {\n\tconst { activeElement, body } = document;\n\tif (!activeElement) return false;\n\tif (activeElement === body) return false;\n\tswitch (activeElement.tagName) {\n\t\tcase \"INPUT\":\n\t\tcase \"TEXTAREA\": return true;\n\t}\n\treturn activeElement.hasAttribute(\"contenteditable\");\n}\nfunction isTypedCharValid({ keyCode, metaKey, ctrlKey, altKey }) {\n\tif (metaKey || ctrlKey || altKey) return false;\n\tif (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105) return true;\n\tif (keyCode >= 65 && keyCode <= 90) return true;\n\treturn false;\n}\n/**\n* Fires when users start typing on non-editable elements.\n*\n* @see https://vueuse.org/onStartTyping\n* @param callback\n* @param options\n*/\nfunction onStartTyping(callback, options = {}) {\n\tconst { document: document$1 = defaultDocument } = options;\n\tconst keydown = (event) => {\n\t\tif (!isFocusedElementEditable() && isTypedCharValid(event)) callback(event);\n\t};\n\tif (document$1) useEventListener(document$1, \"keydown\", keydown, { passive: true });\n}\n\n//#endregion\n//#region templateRef/index.ts\n/**\n* @deprecated Use Vue's built-in `useTemplateRef` instead.\n*\n* Shorthand for binding ref to template element.\n*\n* @see https://vueuse.org/templateRef\n* @param key\n* @param initialValue\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction templateRef(key, initialValue = null) {\n\tconst instance = getCurrentInstance();\n\tlet _trigger = () => {};\n\tconst element = customRef((track, trigger) => {\n\t\t_trigger = trigger;\n\t\treturn {\n\t\t\tget() {\n\t\t\t\tvar _instance$proxy$$refs, _instance$proxy;\n\t\t\t\ttrack();\n\t\t\t\treturn (_instance$proxy$$refs = instance === null || instance === void 0 || (_instance$proxy = instance.proxy) === null || _instance$proxy === void 0 ? void 0 : _instance$proxy.$refs[key]) !== null && _instance$proxy$$refs !== void 0 ? _instance$proxy$$refs : initialValue;\n\t\t\t},\n\t\t\tset() {}\n\t\t};\n\t});\n\ttryOnMounted(_trigger);\n\tonUpdated(_trigger);\n\treturn element;\n}\n\n//#endregion\n//#region useActiveElement/index.ts\n/**\n* Reactive `document.activeElement`\n*\n* @see https://vueuse.org/useActiveElement\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useActiveElement(options = {}) {\n\tvar _options$document;\n\tconst { window: window$1 = defaultWindow, deep = true, triggerOnRemoval = false } = options;\n\tconst document$1 = (_options$document = options.document) !== null && _options$document !== void 0 ? _options$document : window$1 === null || window$1 === void 0 ? void 0 : window$1.document;\n\tconst getDeepActiveElement = () => {\n\t\tlet element = document$1 === null || document$1 === void 0 ? void 0 : document$1.activeElement;\n\t\tif (deep) {\n\t\t\tvar _element$shadowRoot;\n\t\t\twhile (element === null || element === void 0 ? void 0 : element.shadowRoot) element = element === null || element === void 0 || (_element$shadowRoot = element.shadowRoot) === null || _element$shadowRoot === void 0 ? void 0 : _element$shadowRoot.activeElement;\n\t\t}\n\t\treturn element;\n\t};\n\tconst activeElement = shallowRef();\n\tconst trigger = () => {\n\t\tactiveElement.value = getDeepActiveElement();\n\t};\n\tif (window$1) {\n\t\tconst listenerOptions = {\n\t\t\tcapture: true,\n\t\t\tpassive: true\n\t\t};\n\t\tuseEventListener(window$1, \"blur\", (event) => {\n\t\t\tif (event.relatedTarget !== null) return;\n\t\t\ttrigger();\n\t\t}, listenerOptions);\n\t\tuseEventListener(window$1, \"focus\", trigger, listenerOptions);\n\t}\n\tif (triggerOnRemoval) onElementRemoval(activeElement, trigger, { document: document$1 });\n\ttrigger();\n\treturn activeElement;\n}\n\n//#endregion\n//#region useRafFn/index.ts\n/**\n* Call function on every `requestAnimationFrame`. With controls of pausing and resuming.\n*\n* @see https://vueuse.org/useRafFn\n* @param fn\n* @param options\n*/\nfunction useRafFn(fn, options = {}) {\n\tconst { immediate = true, fpsLimit = null, window: window$1 = defaultWindow, once = false } = options;\n\tconst isActive = shallowRef(false);\n\tconst intervalLimit = computed(() => {\n\t\tconst limit = toValue(fpsLimit);\n\t\treturn limit ? 1e3 / limit : null;\n\t});\n\tlet previousFrameTimestamp = 0;\n\tlet rafId = null;\n\tfunction loop(timestamp$1) {\n\t\tif (!isActive.value || !window$1) return;\n\t\tif (!previousFrameTimestamp) previousFrameTimestamp = timestamp$1;\n\t\tconst delta = timestamp$1 - previousFrameTimestamp;\n\t\tif (intervalLimit.value && delta < intervalLimit.value) {\n\t\t\trafId = window$1.requestAnimationFrame(loop);\n\t\t\treturn;\n\t\t}\n\t\tpreviousFrameTimestamp = timestamp$1;\n\t\tfn({\n\t\t\tdelta,\n\t\t\ttimestamp: timestamp$1\n\t\t});\n\t\tif (once) {\n\t\t\tisActive.value = false;\n\t\t\trafId = null;\n\t\t\treturn;\n\t\t}\n\t\trafId = window$1.requestAnimationFrame(loop);\n\t}\n\tfunction resume() {\n\t\tif (!isActive.value && window$1) {\n\t\t\tisActive.value = true;\n\t\t\tpreviousFrameTimestamp = 0;\n\t\t\trafId = window$1.requestAnimationFrame(loop);\n\t\t}\n\t}\n\tfunction pause() {\n\t\tisActive.value = false;\n\t\tif (rafId != null && window$1) {\n\t\t\twindow$1.cancelAnimationFrame(rafId);\n\t\t\trafId = null;\n\t\t}\n\t}\n\tif (immediate) resume();\n\ttryOnScopeDispose(pause);\n\treturn {\n\t\tisActive: readonly(isActive),\n\t\tpause,\n\t\tresume\n\t};\n}\n\n//#endregion\n//#region useAnimate/index.ts\n/**\n* Reactive Web Animations API\n*\n* @see https://vueuse.org/useAnimate\n* @param target\n* @param keyframes\n* @param options\n*/\nfunction useAnimate(target, keyframes, options) {\n\tlet config;\n\tlet animateOptions;\n\tif (isObject(options)) {\n\t\tconfig = options;\n\t\tanimateOptions = objectOmit(options, [\n\t\t\t\"window\",\n\t\t\t\"immediate\",\n\t\t\t\"commitStyles\",\n\t\t\t\"persist\",\n\t\t\t\"onReady\",\n\t\t\t\"onError\"\n\t\t]);\n\t} else {\n\t\tconfig = { duration: options };\n\t\tanimateOptions = options;\n\t}\n\tconst { window: window$1 = defaultWindow, immediate = true, commitStyles, persist, playbackRate: _playbackRate = 1, onReady, onError = (e) => {\n\t\tconsole.error(e);\n\t} } = config;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => window$1 && HTMLElement && \"animate\" in HTMLElement.prototype);\n\tconst animate = shallowRef(void 0);\n\tconst store = shallowReactive({\n\t\tstartTime: null,\n\t\tcurrentTime: null,\n\t\ttimeline: null,\n\t\tplaybackRate: _playbackRate,\n\t\tpending: false,\n\t\tplayState: immediate ? \"idle\" : \"paused\",\n\t\treplaceState: \"active\"\n\t});\n\tconst pending = computed(() => store.pending);\n\tconst playState = computed(() => store.playState);\n\tconst replaceState = computed(() => store.replaceState);\n\tconst startTime = computed({\n\t\tget() {\n\t\t\treturn store.startTime;\n\t\t},\n\t\tset(value) {\n\t\t\tstore.startTime = value;\n\t\t\tif (animate.value) animate.value.startTime = value;\n\t\t}\n\t});\n\tconst currentTime = computed({\n\t\tget() {\n\t\t\treturn store.currentTime;\n\t\t},\n\t\tset(value) {\n\t\t\tstore.currentTime = value;\n\t\t\tif (animate.value) {\n\t\t\t\tanimate.value.currentTime = value;\n\t\t\t\tsyncResume();\n\t\t\t}\n\t\t}\n\t});\n\tconst timeline = computed({\n\t\tget() {\n\t\t\treturn store.timeline;\n\t\t},\n\t\tset(value) {\n\t\t\tstore.timeline = value;\n\t\t\tif (animate.value) animate.value.timeline = value;\n\t\t}\n\t});\n\tconst playbackRate = computed({\n\t\tget() {\n\t\t\treturn store.playbackRate;\n\t\t},\n\t\tset(value) {\n\t\t\tstore.playbackRate = value;\n\t\t\tif (animate.value) animate.value.playbackRate = value;\n\t\t}\n\t});\n\tconst play = () => {\n\t\tif (animate.value) try {\n\t\t\tanimate.value.play();\n\t\t\tsyncResume();\n\t\t} catch (e) {\n\t\t\tsyncPause();\n\t\t\tonError(e);\n\t\t}\n\t\telse update();\n\t};\n\tconst pause = () => {\n\t\ttry {\n\t\t\tvar _animate$value;\n\t\t\t(_animate$value = animate.value) === null || _animate$value === void 0 || _animate$value.pause();\n\t\t\tsyncPause();\n\t\t} catch (e) {\n\t\t\tonError(e);\n\t\t}\n\t};\n\tconst reverse = () => {\n\t\tif (!animate.value) update();\n\t\ttry {\n\t\t\tvar _animate$value2;\n\t\t\t(_animate$value2 = animate.value) === null || _animate$value2 === void 0 || _animate$value2.reverse();\n\t\t\tsyncResume();\n\t\t} catch (e) {\n\t\t\tsyncPause();\n\t\t\tonError(e);\n\t\t}\n\t};\n\tconst finish = () => {\n\t\ttry {\n\t\t\tvar _animate$value3;\n\t\t\t(_animate$value3 = animate.value) === null || _animate$value3 === void 0 || _animate$value3.finish();\n\t\t\tsyncPause();\n\t\t} catch (e) {\n\t\t\tonError(e);\n\t\t}\n\t};\n\tconst cancel = () => {\n\t\ttry {\n\t\t\tvar _animate$value4;\n\t\t\t(_animate$value4 = animate.value) === null || _animate$value4 === void 0 || _animate$value4.cancel();\n\t\t\tsyncPause();\n\t\t} catch (e) {\n\t\t\tonError(e);\n\t\t}\n\t};\n\twatch(() => unrefElement(target), (el) => {\n\t\tif (el) update(true);\n\t\telse animate.value = void 0;\n\t});\n\twatch(() => keyframes, (value) => {\n\t\tif (animate.value) {\n\t\t\tupdate();\n\t\t\tconst targetEl = unrefElement(target);\n\t\t\tif (targetEl) animate.value.effect = new KeyframeEffect(targetEl, toValue(value), animateOptions);\n\t\t}\n\t}, { deep: true });\n\ttryOnMounted(() => update(true), false);\n\ttryOnScopeDispose(cancel);\n\tfunction update(init) {\n\t\tconst el = unrefElement(target);\n\t\tif (!isSupported.value || !el) return;\n\t\tif (!animate.value) animate.value = el.animate(toValue(keyframes), animateOptions);\n\t\tif (persist) animate.value.persist();\n\t\tif (_playbackRate !== 1) animate.value.playbackRate = _playbackRate;\n\t\tif (init && !immediate) animate.value.pause();\n\t\telse syncResume();\n\t\tonReady === null || onReady === void 0 || onReady(animate.value);\n\t}\n\tconst listenerOptions = { passive: true };\n\tuseEventListener(animate, [\n\t\t\"cancel\",\n\t\t\"finish\",\n\t\t\"remove\"\n\t], syncPause, listenerOptions);\n\tuseEventListener(animate, \"finish\", () => {\n\t\tvar _animate$value5;\n\t\tif (commitStyles) (_animate$value5 = animate.value) === null || _animate$value5 === void 0 || _animate$value5.commitStyles();\n\t}, listenerOptions);\n\tconst { resume: resumeRef, pause: pauseRef } = useRafFn(() => {\n\t\tif (!animate.value) return;\n\t\tstore.pending = animate.value.pending;\n\t\tstore.playState = animate.value.playState;\n\t\tstore.replaceState = animate.value.replaceState;\n\t\tstore.startTime = animate.value.startTime;\n\t\tstore.currentTime = animate.value.currentTime;\n\t\tstore.timeline = animate.value.timeline;\n\t\tstore.playbackRate = animate.value.playbackRate;\n\t}, { immediate: false });\n\tfunction syncResume() {\n\t\tif (isSupported.value) resumeRef();\n\t}\n\tfunction syncPause() {\n\t\tif (isSupported.value && window$1) window$1.requestAnimationFrame(pauseRef);\n\t}\n\treturn {\n\t\tisSupported,\n\t\tanimate,\n\t\tplay,\n\t\tpause,\n\t\treverse,\n\t\tfinish,\n\t\tcancel,\n\t\tpending,\n\t\tplayState,\n\t\treplaceState,\n\t\tstartTime,\n\t\tcurrentTime,\n\t\ttimeline,\n\t\tplaybackRate\n\t};\n}\n\n//#endregion\n//#region useAsyncQueue/index.ts\n/**\n* Asynchronous queue task controller.\n*\n* @see https://vueuse.org/useAsyncQueue\n* @param tasks\n* @param options\n*/\nfunction useAsyncQueue(tasks, options) {\n\tconst { interrupt = true, onError = noop, onFinished = noop, signal } = options || {};\n\tconst promiseState = {\n\t\taborted: \"aborted\",\n\t\tfulfilled: \"fulfilled\",\n\t\tpending: \"pending\",\n\t\trejected: \"rejected\"\n\t};\n\tconst result = reactive(Array.from(Array.from({ length: tasks.length }), () => ({\n\t\tstate: promiseState.pending,\n\t\tdata: null\n\t})));\n\tconst activeIndex = shallowRef(-1);\n\tif (!tasks || tasks.length === 0) {\n\t\tonFinished();\n\t\treturn {\n\t\t\tactiveIndex,\n\t\t\tresult\n\t\t};\n\t}\n\tfunction updateResult(state, res) {\n\t\tactiveIndex.value++;\n\t\tresult[activeIndex.value].data = res;\n\t\tresult[activeIndex.value].state = state;\n\t}\n\ttasks.reduce((prev, curr) => {\n\t\treturn prev.then((prevRes) => {\n\t\t\tvar _result$activeIndex$v;\n\t\t\tif (signal === null || signal === void 0 ? void 0 : signal.aborted) {\n\t\t\t\tupdateResult(promiseState.aborted, /* @__PURE__ */ new Error(\"aborted\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (((_result$activeIndex$v = result[activeIndex.value]) === null || _result$activeIndex$v === void 0 ? void 0 : _result$activeIndex$v.state) === promiseState.rejected && interrupt) {\n\t\t\t\tonFinished();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst done = curr(prevRes).then((currentRes) => {\n\t\t\t\tupdateResult(promiseState.fulfilled, currentRes);\n\t\t\t\tif (activeIndex.value === tasks.length - 1) onFinished();\n\t\t\t\treturn currentRes;\n\t\t\t});\n\t\t\tif (!signal) return done;\n\t\t\treturn Promise.race([done, whenAborted(signal)]);\n\t\t}).catch((e) => {\n\t\t\tif (signal === null || signal === void 0 ? void 0 : signal.aborted) {\n\t\t\t\tupdateResult(promiseState.aborted, e);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tupdateResult(promiseState.rejected, e);\n\t\t\tonError();\n\t\t\tif (activeIndex.value === tasks.length - 1) onFinished();\n\t\t\treturn e;\n\t\t});\n\t}, Promise.resolve());\n\treturn {\n\t\tactiveIndex,\n\t\tresult\n\t};\n}\nfunction whenAborted(signal) {\n\treturn new Promise((resolve, reject) => {\n\t\tconst error = /* @__PURE__ */ new Error(\"aborted\");\n\t\tif (signal.aborted) reject(error);\n\t\telse signal.addEventListener(\"abort\", () => reject(error), { once: true });\n\t});\n}\n\n//#endregion\n//#region useAsyncState/index.ts\n/**\n* Reactive async state. Will not block your setup function and will trigger changes once\n* the promise is ready.\n*\n* @see https://vueuse.org/useAsyncState\n* @param promise         The promise / async function to be resolved\n* @param initialState    The initial state, used until the first evaluation finishes\n* @param options\n*/\nfunction useAsyncState(promise, initialState, options) {\n\tvar _globalThis$reportErr;\n\tconst { immediate = true, delay = 0, onError = (_globalThis$reportErr = globalThis.reportError) !== null && _globalThis$reportErr !== void 0 ? _globalThis$reportErr : noop, onSuccess = noop, resetOnExecute = true, shallow = true, throwError } = options !== null && options !== void 0 ? options : {};\n\tconst state = shallow ? shallowRef(initialState) : ref(initialState);\n\tconst isReady = shallowRef(false);\n\tconst isLoading = shallowRef(false);\n\tconst error = shallowRef(void 0);\n\tlet executionsCount = 0;\n\tasync function execute(delay$1 = 0, ...args) {\n\t\tconst executionId = executionsCount += 1;\n\t\tif (resetOnExecute) state.value = toValue(initialState);\n\t\terror.value = void 0;\n\t\tisReady.value = false;\n\t\tisLoading.value = true;\n\t\tif (delay$1 > 0) await promiseTimeout(delay$1);\n\t\tconst _promise = typeof promise === \"function\" ? promise(...args) : promise;\n\t\ttry {\n\t\t\tconst data = await _promise;\n\t\t\tif (executionId === executionsCount) {\n\t\t\t\tstate.value = data;\n\t\t\t\tisReady.value = true;\n\t\t\t}\n\t\t\tonSuccess(data);\n\t\t\treturn data;\n\t\t} catch (e) {\n\t\t\tif (executionId === executionsCount) error.value = e;\n\t\t\tonError(e);\n\t\t\tif (throwError) throw e;\n\t\t} finally {\n\t\t\tif (executionId === executionsCount) isLoading.value = false;\n\t\t}\n\t}\n\tif (immediate) execute(delay);\n\tconst shell = {\n\t\tstate,\n\t\tisReady,\n\t\tisLoading,\n\t\terror,\n\t\texecute,\n\t\texecuteImmediate: (...args) => execute(0, ...args)\n\t};\n\tfunction waitUntilIsLoaded() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuntil(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);\n\t\t});\n\t}\n\treturn {\n\t\t...shell,\n\t\tthen(onFulfilled, onRejected) {\n\t\t\treturn waitUntilIsLoaded().then(onFulfilled, onRejected);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region useBase64/serialization.ts\nconst defaults = {\n\tarray: (v) => JSON.stringify(v),\n\tobject: (v) => JSON.stringify(v),\n\tset: (v) => JSON.stringify(Array.from(v)),\n\tmap: (v) => JSON.stringify(Object.fromEntries(v)),\n\tnull: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n\tif (!target) return defaults.null;\n\tif (target instanceof Map) return defaults.map;\n\telse if (target instanceof Set) return defaults.set;\n\telse if (Array.isArray(target)) return defaults.array;\n\telse return defaults.object;\n}\n\n//#endregion\n//#region useBase64/index.ts\nfunction useBase64(target, options) {\n\tconst base64 = shallowRef(\"\");\n\tconst promise = shallowRef();\n\tfunction execute() {\n\t\tif (!isClient) return;\n\t\tpromise.value = new Promise((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tconst _target = toValue(target);\n\t\t\t\tif (_target == null) resolve(\"\");\n\t\t\t\telse if (typeof _target === \"string\") resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n\t\t\t\telse if (_target instanceof Blob) resolve(blobToBase64(_target));\n\t\t\t\telse if (_target instanceof ArrayBuffer) resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n\t\t\t\telse if (_target instanceof HTMLCanvasElement) resolve(_target.toDataURL(options === null || options === void 0 ? void 0 : options.type, options === null || options === void 0 ? void 0 : options.quality));\n\t\t\t\telse if (_target instanceof HTMLImageElement) {\n\t\t\t\t\tconst img = _target.cloneNode(false);\n\t\t\t\t\timg.crossOrigin = \"Anonymous\";\n\t\t\t\t\timgLoaded(img).then(() => {\n\t\t\t\t\t\tconst canvas = document.createElement(\"canvas\");\n\t\t\t\t\t\tconst ctx = canvas.getContext(\"2d\");\n\t\t\t\t\t\tcanvas.width = img.width;\n\t\t\t\t\t\tcanvas.height = img.height;\n\t\t\t\t\t\tctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\t\t\t\t\t\tresolve(canvas.toDataURL(options === null || options === void 0 ? void 0 : options.type, options === null || options === void 0 ? void 0 : options.quality));\n\t\t\t\t\t}).catch(reject);\n\t\t\t\t} else if (typeof _target === \"object\") {\n\t\t\t\t\tconst serialized = ((options === null || options === void 0 ? void 0 : options.serializer) || getDefaultSerialization(_target))(_target);\n\t\t\t\t\treturn resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n\t\t\t\t} else reject(/* @__PURE__ */ new Error(\"target is unsupported types\"));\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t\tpromise.value.then((res) => {\n\t\t\tbase64.value = (options === null || options === void 0 ? void 0 : options.dataUrl) === false ? res.replace(/^data:.*?;base64,/, \"\") : res;\n\t\t});\n\t\treturn promise.value;\n\t}\n\tif (isRef(target) || typeof target === \"function\") watch(target, execute, { immediate: true });\n\telse execute();\n\treturn {\n\t\tbase64,\n\t\tpromise,\n\t\texecute\n\t};\n}\nfunction imgLoaded(img) {\n\treturn new Promise((resolve, reject) => {\n\t\tif (!img.complete) {\n\t\t\timg.onload = () => {\n\t\t\t\tresolve();\n\t\t\t};\n\t\t\timg.onerror = reject;\n\t\t} else resolve();\n\t});\n}\nfunction blobToBase64(blob) {\n\treturn new Promise((resolve, reject) => {\n\t\tconst fr = new FileReader();\n\t\tfr.onload = (e) => {\n\t\t\tresolve(e.target.result);\n\t\t};\n\t\tfr.onerror = reject;\n\t\tfr.readAsDataURL(blob);\n\t});\n}\n\n//#endregion\n//#region useBattery/index.ts\n/**\n* Reactive Battery Status API.\n*\n* @see https://vueuse.org/useBattery\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useBattery(options = {}) {\n\tconst { navigator: navigator$1 = defaultNavigator } = options;\n\tconst events$1 = [\n\t\t\"chargingchange\",\n\t\t\"chargingtimechange\",\n\t\t\"dischargingtimechange\",\n\t\t\"levelchange\"\n\t];\n\tconst isSupported = /* @__PURE__ */ useSupported(() => navigator$1 && \"getBattery\" in navigator$1 && typeof navigator$1.getBattery === \"function\");\n\tconst charging = shallowRef(false);\n\tconst chargingTime = shallowRef(0);\n\tconst dischargingTime = shallowRef(0);\n\tconst level = shallowRef(1);\n\tlet battery;\n\tfunction updateBatteryInfo() {\n\t\tcharging.value = this.charging;\n\t\tchargingTime.value = this.chargingTime || 0;\n\t\tdischargingTime.value = this.dischargingTime || 0;\n\t\tlevel.value = this.level;\n\t}\n\tif (isSupported.value) navigator$1.getBattery().then((_battery) => {\n\t\tbattery = _battery;\n\t\tupdateBatteryInfo.call(battery);\n\t\tuseEventListener(battery, events$1, updateBatteryInfo, { passive: true });\n\t});\n\treturn {\n\t\tisSupported,\n\t\tcharging,\n\t\tchargingTime,\n\t\tdischargingTime,\n\t\tlevel\n\t};\n}\n\n//#endregion\n//#region useBluetooth/index.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction useBluetooth(options) {\n\tlet { acceptAllDevices = false } = options || {};\n\tconst { filters = void 0, optionalServices = void 0, navigator: navigator$1 = defaultNavigator } = options || {};\n\tconst isSupported = /* @__PURE__ */ useSupported(() => navigator$1 && \"bluetooth\" in navigator$1);\n\tconst device = shallowRef();\n\tconst error = shallowRef(null);\n\twatch(device, () => {\n\t\tconnectToBluetoothGATTServer();\n\t});\n\tasync function requestDevice() {\n\t\tif (!isSupported.value) return;\n\t\terror.value = null;\n\t\tif (filters && filters.length > 0) acceptAllDevices = false;\n\t\ttry {\n\t\t\tdevice.value = await (navigator$1 === null || navigator$1 === void 0 ? void 0 : navigator$1.bluetooth.requestDevice({\n\t\t\t\tacceptAllDevices,\n\t\t\t\tfilters,\n\t\t\t\toptionalServices\n\t\t\t}));\n\t\t} catch (err) {\n\t\t\terror.value = err;\n\t\t}\n\t}\n\tconst server = shallowRef();\n\tconst isConnected = shallowRef(false);\n\tfunction reset() {\n\t\tisConnected.value = false;\n\t\tdevice.value = void 0;\n\t\tserver.value = void 0;\n\t}\n\tasync function connectToBluetoothGATTServer() {\n\t\terror.value = null;\n\t\tif (device.value && device.value.gatt) {\n\t\t\tuseEventListener(device, \"gattserverdisconnected\", reset, { passive: true });\n\t\t\ttry {\n\t\t\t\tserver.value = await device.value.gatt.connect();\n\t\t\t\tisConnected.value = server.value.connected;\n\t\t\t} catch (err) {\n\t\t\t\terror.value = err;\n\t\t\t}\n\t\t}\n\t}\n\ttryOnMounted(() => {\n\t\tvar _device$value$gatt;\n\t\tif (device.value) (_device$value$gatt = device.value.gatt) === null || _device$value$gatt === void 0 || _device$value$gatt.connect();\n\t});\n\ttryOnScopeDispose(() => {\n\t\tvar _device$value$gatt2;\n\t\tif (device.value) (_device$value$gatt2 = device.value.gatt) === null || _device$value$gatt2 === void 0 || _device$value$gatt2.disconnect();\n\t});\n\treturn {\n\t\tisSupported,\n\t\tisConnected: readonly(isConnected),\n\t\tdevice,\n\t\trequestDevice,\n\t\tserver,\n\t\terror\n\t};\n}\n\n//#endregion\n//#region useSSRWidth/index.ts\nconst ssrWidthSymbol = Symbol(\"vueuse-ssr-width\");\n/* @__NO_SIDE_EFFECTS__ */\nfunction useSSRWidth() {\n\tconst ssrWidth = hasInjectionContext() ? injectLocal(ssrWidthSymbol, null) : null;\n\treturn typeof ssrWidth === \"number\" ? ssrWidth : void 0;\n}\nfunction provideSSRWidth(width, app) {\n\tif (app !== void 0) app.provide(ssrWidthSymbol, width);\n\telse provideLocal(ssrWidthSymbol, width);\n}\n\n//#endregion\n//#region useMediaQuery/index.ts\n/**\n* Reactive Media Query.\n*\n* @see https://vueuse.org/useMediaQuery\n* @param query\n* @param options\n*/\nfunction useMediaQuery(query, options = {}) {\n\tconst { window: window$1 = defaultWindow, ssrWidth = /* @__PURE__ */ useSSRWidth() } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => window$1 && \"matchMedia\" in window$1 && typeof window$1.matchMedia === \"function\");\n\tconst ssrSupport = shallowRef(typeof ssrWidth === \"number\");\n\tconst mediaQuery = shallowRef();\n\tconst matches = shallowRef(false);\n\tconst handler = (event) => {\n\t\tmatches.value = event.matches;\n\t};\n\twatchEffect(() => {\n\t\tif (ssrSupport.value) {\n\t\t\tssrSupport.value = !isSupported.value;\n\t\t\tmatches.value = toValue(query).split(\",\").some((queryString) => {\n\t\t\t\tconst not = queryString.includes(\"not all\");\n\t\t\t\tconst minWidth = queryString.match(/\\(\\s*min-width:\\s*(-?\\d+(?:\\.\\d*)?[a-z]+\\s*)\\)/);\n\t\t\t\tconst maxWidth = queryString.match(/\\(\\s*max-width:\\s*(-?\\d+(?:\\.\\d*)?[a-z]+\\s*)\\)/);\n\t\t\t\tlet res = Boolean(minWidth || maxWidth);\n\t\t\t\tif (minWidth && res) res = ssrWidth >= pxValue(minWidth[1]);\n\t\t\t\tif (maxWidth && res) res = ssrWidth <= pxValue(maxWidth[1]);\n\t\t\t\treturn not ? !res : res;\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tif (!isSupported.value) return;\n\t\tmediaQuery.value = window$1.matchMedia(toValue(query));\n\t\tmatches.value = mediaQuery.value.matches;\n\t});\n\tuseEventListener(mediaQuery, \"change\", handler, { passive: true });\n\treturn computed(() => matches.value);\n}\n\n//#endregion\n//#region useBreakpoints/breakpoints.ts\n/**\n* Breakpoints from Tailwind V2\n*\n* @see https://tailwindcss.com/docs/breakpoints\n*/\nconst breakpointsTailwind = {\n\t\"sm\": 640,\n\t\"md\": 768,\n\t\"lg\": 1024,\n\t\"xl\": 1280,\n\t\"2xl\": 1536\n};\n/**\n* Breakpoints from Bootstrap V5\n*\n* @see https://getbootstrap.com/docs/5.0/layout/breakpoints\n*/\nconst breakpointsBootstrapV5 = {\n\txs: 0,\n\tsm: 576,\n\tmd: 768,\n\tlg: 992,\n\txl: 1200,\n\txxl: 1400\n};\n/**\n* Breakpoints from Vuetify V2\n*\n* @see https://v2.vuetifyjs.com/en/features/breakpoints/\n*/\nconst breakpointsVuetifyV2 = {\n\txs: 0,\n\tsm: 600,\n\tmd: 960,\n\tlg: 1264,\n\txl: 1904\n};\n/**\n* Breakpoints from Vuetify V3\n*\n* @see https://vuetifyjs.com/en/styles/float/#overview\n*/\nconst breakpointsVuetifyV3 = {\n\txs: 0,\n\tsm: 600,\n\tmd: 960,\n\tlg: 1280,\n\txl: 1920,\n\txxl: 2560\n};\n/**\n* Alias to `breakpointsVuetifyV2`\n*\n* @deprecated explictly use `breakpointsVuetifyV2` or `breakpointsVuetifyV3` instead\n*/\nconst breakpointsVuetify = breakpointsVuetifyV2;\n/**\n* Breakpoints from Ant Design\n*\n* @see https://ant.design/components/layout/#breakpoint-width\n*/\nconst breakpointsAntDesign = {\n\txs: 480,\n\tsm: 576,\n\tmd: 768,\n\tlg: 992,\n\txl: 1200,\n\txxl: 1600\n};\n/**\n* Breakpoints from Quasar V2\n*\n* @see https://quasar.dev/style/breakpoints\n*/\nconst breakpointsQuasar = {\n\txs: 0,\n\tsm: 600,\n\tmd: 1024,\n\tlg: 1440,\n\txl: 1920\n};\n/**\n* Sematic Breakpoints\n*/\nconst breakpointsSematic = {\n\tmobileS: 320,\n\tmobileM: 375,\n\tmobileL: 425,\n\ttablet: 768,\n\tlaptop: 1024,\n\tlaptopL: 1440,\n\tdesktop4K: 2560\n};\n/**\n* Breakpoints from Master CSS\n*\n* @see https://docs.master.co/css/breakpoints\n*/\nconst breakpointsMasterCss = {\n\t\"3xs\": 360,\n\t\"2xs\": 480,\n\t\"xs\": 600,\n\t\"sm\": 768,\n\t\"md\": 1024,\n\t\"lg\": 1280,\n\t\"xl\": 1440,\n\t\"2xl\": 1600,\n\t\"3xl\": 1920,\n\t\"4xl\": 2560\n};\n/**\n* Breakpoints from PrimeFlex\n*\n* @see https://primeflex.org/installation\n*/\nconst breakpointsPrimeFlex = {\n\tsm: 576,\n\tmd: 768,\n\tlg: 992,\n\txl: 1200\n};\n/**\n* Breakpoints from ElementUI/ElementPlus\n*\n* @see https://element.eleme.io/#/en-US/component/layout\n* @see https://element-plus.org/en-US/component/layout.html\n*/\nconst breakpointsElement = {\n\txs: 0,\n\tsm: 768,\n\tmd: 992,\n\tlg: 1200,\n\txl: 1920\n};\n\n//#endregion\n//#region useBreakpoints/index.ts\n/**\n* Reactively viewport breakpoints\n*\n* @see https://vueuse.org/useBreakpoints\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useBreakpoints(breakpoints, options = {}) {\n\tfunction getValue$1(k, delta) {\n\t\tlet v = toValue(breakpoints[toValue(k)]);\n\t\tif (delta != null) v = increaseWithUnit(v, delta);\n\t\tif (typeof v === \"number\") v = `${v}px`;\n\t\treturn v;\n\t}\n\tconst { window: window$1 = defaultWindow, strategy = \"min-width\", ssrWidth = /* @__PURE__ */ useSSRWidth() } = options;\n\tconst ssrSupport = typeof ssrWidth === \"number\";\n\tconst mounted = ssrSupport ? shallowRef(false) : { value: true };\n\tif (ssrSupport) tryOnMounted(() => mounted.value = !!window$1);\n\tfunction match(query, size) {\n\t\tif (!mounted.value && ssrSupport) return query === \"min\" ? ssrWidth >= pxValue(size) : ssrWidth <= pxValue(size);\n\t\tif (!window$1) return false;\n\t\treturn window$1.matchMedia(`(${query}-width: ${size})`).matches;\n\t}\n\tconst greaterOrEqual = (k) => {\n\t\treturn useMediaQuery(() => `(min-width: ${getValue$1(k)})`, options);\n\t};\n\tconst smallerOrEqual = (k) => {\n\t\treturn useMediaQuery(() => `(max-width: ${getValue$1(k)})`, options);\n\t};\n\tconst shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n\t\tObject.defineProperty(shortcuts, k, {\n\t\t\tget: () => strategy === \"min-width\" ? greaterOrEqual(k) : smallerOrEqual(k),\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true\n\t\t});\n\t\treturn shortcuts;\n\t}, {});\n\tfunction current() {\n\t\tconst points = Object.keys(breakpoints).map((k) => [\n\t\t\tk,\n\t\t\tshortcutMethods[k],\n\t\t\tpxValue(getValue$1(k))\n\t\t]).sort((a, b) => a[2] - b[2]);\n\t\treturn computed(() => points.filter(([, v]) => v.value).map(([k]) => k));\n\t}\n\treturn Object.assign(shortcutMethods, {\n\t\tgreaterOrEqual,\n\t\tsmallerOrEqual,\n\t\tgreater(k) {\n\t\t\treturn useMediaQuery(() => `(min-width: ${getValue$1(k, .1)})`, options);\n\t\t},\n\t\tsmaller(k) {\n\t\t\treturn useMediaQuery(() => `(max-width: ${getValue$1(k, -.1)})`, options);\n\t\t},\n\t\tbetween(a, b) {\n\t\t\treturn useMediaQuery(() => `(min-width: ${getValue$1(a)}) and (max-width: ${getValue$1(b, -.1)})`, options);\n\t\t},\n\t\tisGreater(k) {\n\t\t\treturn match(\"min\", getValue$1(k, .1));\n\t\t},\n\t\tisGreaterOrEqual(k) {\n\t\t\treturn match(\"min\", getValue$1(k));\n\t\t},\n\t\tisSmaller(k) {\n\t\t\treturn match(\"max\", getValue$1(k, -.1));\n\t\t},\n\t\tisSmallerOrEqual(k) {\n\t\t\treturn match(\"max\", getValue$1(k));\n\t\t},\n\t\tisInBetween(a, b) {\n\t\t\treturn match(\"min\", getValue$1(a)) && match(\"max\", getValue$1(b, -.1));\n\t\t},\n\t\tcurrent,\n\t\tactive() {\n\t\t\tconst bps = current();\n\t\t\treturn computed(() => bps.value.length === 0 ? \"\" : bps.value.at(strategy === \"min-width\" ? -1 : 0));\n\t\t}\n\t});\n}\n\n//#endregion\n//#region useBroadcastChannel/index.ts\n/**\n* Reactive BroadcastChannel\n*\n* @see https://vueuse.org/useBroadcastChannel\n* @see https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel\n* @param options\n*\n*/\nfunction useBroadcastChannel(options) {\n\tconst { name, window: window$1 = defaultWindow } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => window$1 && \"BroadcastChannel\" in window$1);\n\tconst isClosed = shallowRef(false);\n\tconst channel = ref();\n\tconst data = ref();\n\tconst error = shallowRef(null);\n\tconst post = (data$1) => {\n\t\tif (channel.value) channel.value.postMessage(data$1);\n\t};\n\tconst close = () => {\n\t\tif (channel.value) channel.value.close();\n\t\tisClosed.value = true;\n\t};\n\tif (isSupported.value) tryOnMounted(() => {\n\t\terror.value = null;\n\t\tchannel.value = new BroadcastChannel(name);\n\t\tconst listenerOptions = { passive: true };\n\t\tuseEventListener(channel, \"message\", (e) => {\n\t\t\tdata.value = e.data;\n\t\t}, listenerOptions);\n\t\tuseEventListener(channel, \"messageerror\", (e) => {\n\t\t\terror.value = e;\n\t\t}, listenerOptions);\n\t\tuseEventListener(channel, \"close\", () => {\n\t\t\tisClosed.value = true;\n\t\t}, listenerOptions);\n\t});\n\ttryOnScopeDispose(() => {\n\t\tclose();\n\t});\n\treturn {\n\t\tisSupported,\n\t\tchannel,\n\t\tdata,\n\t\tpost,\n\t\tclose,\n\t\terror,\n\t\tisClosed\n\t};\n}\n\n//#endregion\n//#region useBrowserLocation/index.ts\nconst WRITABLE_PROPERTIES = [\n\t\"hash\",\n\t\"host\",\n\t\"hostname\",\n\t\"href\",\n\t\"pathname\",\n\t\"port\",\n\t\"protocol\",\n\t\"search\"\n];\n/**\n* Reactive browser location.\n*\n* @see https://vueuse.org/useBrowserLocation\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useBrowserLocation(options = {}) {\n\tconst { window: window$1 = defaultWindow } = options;\n\tconst refs = Object.fromEntries(WRITABLE_PROPERTIES.map((key) => [key, ref()]));\n\tfor (const [key, ref$1] of objectEntries(refs)) watch(ref$1, (value) => {\n\t\tif (!(window$1 === null || window$1 === void 0 ? void 0 : window$1.location) || window$1.location[key] === value) return;\n\t\twindow$1.location[key] = value;\n\t});\n\tconst buildState = (trigger) => {\n\t\tvar _window$location;\n\t\tconst { state: state$1, length } = (window$1 === null || window$1 === void 0 ? void 0 : window$1.history) || {};\n\t\tconst { origin } = (window$1 === null || window$1 === void 0 ? void 0 : window$1.location) || {};\n\t\tfor (const key of WRITABLE_PROPERTIES) refs[key].value = window$1 === null || window$1 === void 0 || (_window$location = window$1.location) === null || _window$location === void 0 ? void 0 : _window$location[key];\n\t\treturn reactive({\n\t\t\ttrigger,\n\t\t\tstate: state$1,\n\t\t\tlength,\n\t\t\torigin,\n\t\t\t...refs\n\t\t});\n\t};\n\tconst state = ref(buildState(\"load\"));\n\tif (window$1) {\n\t\tconst listenerOptions = { passive: true };\n\t\tuseEventListener(window$1, \"popstate\", () => state.value = buildState(\"popstate\"), listenerOptions);\n\t\tuseEventListener(window$1, \"hashchange\", () => state.value = buildState(\"hashchange\"), listenerOptions);\n\t}\n\treturn state;\n}\n\n//#endregion\n//#region useCached/index.ts\nfunction useCached(refValue, comparator = (a, b) => a === b, options) {\n\tconst { deepRefs = true,...watchOptions } = options || {};\n\tconst cachedValue = createRef(refValue.value, deepRefs);\n\twatch(() => refValue.value, (value) => {\n\t\tif (!comparator(value, cachedValue.value)) cachedValue.value = value;\n\t}, watchOptions);\n\treturn cachedValue;\n}\n\n//#endregion\n//#region usePermission/index.ts\n/**\n* Reactive Permissions API.\n*\n* @see https://vueuse.org/usePermission\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction usePermission(permissionDesc, options = {}) {\n\tconst { controls = false, navigator: navigator$1 = defaultNavigator } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => navigator$1 && \"permissions\" in navigator$1);\n\tconst permissionStatus = shallowRef();\n\tconst desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n\tconst state = shallowRef();\n\tconst update = () => {\n\t\tvar _permissionStatus$val, _permissionStatus$val2;\n\t\tstate.value = (_permissionStatus$val = (_permissionStatus$val2 = permissionStatus.value) === null || _permissionStatus$val2 === void 0 ? void 0 : _permissionStatus$val2.state) !== null && _permissionStatus$val !== void 0 ? _permissionStatus$val : \"prompt\";\n\t};\n\tuseEventListener(permissionStatus, \"change\", update, { passive: true });\n\tconst query = createSingletonPromise(async () => {\n\t\tif (!isSupported.value) return;\n\t\tif (!permissionStatus.value) try {\n\t\t\tpermissionStatus.value = await navigator$1.permissions.query(desc);\n\t\t} catch (_unused) {\n\t\t\tpermissionStatus.value = void 0;\n\t\t} finally {\n\t\t\tupdate();\n\t\t}\n\t\tif (controls) return toRaw(permissionStatus.value);\n\t});\n\tquery();\n\tif (controls) return {\n\t\tstate,\n\t\tisSupported,\n\t\tquery\n\t};\n\telse return state;\n}\n\n//#endregion\n//#region useClipboard/index.ts\nfunction useClipboard(options = {}) {\n\tconst { navigator: navigator$1 = defaultNavigator, read = false, source, copiedDuring = 1500, legacy = false } = options;\n\tconst isClipboardApiSupported = /* @__PURE__ */ useSupported(() => navigator$1 && \"clipboard\" in navigator$1);\n\tconst permissionRead = usePermission(\"clipboard-read\");\n\tconst permissionWrite = usePermission(\"clipboard-write\");\n\tconst isSupported = computed(() => isClipboardApiSupported.value || legacy);\n\tconst text = shallowRef(\"\");\n\tconst copied = shallowRef(false);\n\tconst timeout = useTimeoutFn(() => copied.value = false, copiedDuring, { immediate: false });\n\tasync function updateText() {\n\t\tlet useLegacy = !(isClipboardApiSupported.value && isAllowed(permissionRead.value));\n\t\tif (!useLegacy) try {\n\t\t\ttext.value = await navigator$1.clipboard.readText();\n\t\t} catch (_unused) {\n\t\t\tuseLegacy = true;\n\t\t}\n\t\tif (useLegacy) text.value = legacyRead();\n\t}\n\tif (isSupported.value && read) useEventListener([\"copy\", \"cut\"], updateText, { passive: true });\n\tasync function copy(value = toValue(source)) {\n\t\tif (isSupported.value && value != null) {\n\t\t\tlet useLegacy = !(isClipboardApiSupported.value && isAllowed(permissionWrite.value));\n\t\t\tif (!useLegacy) try {\n\t\t\t\tawait navigator$1.clipboard.writeText(value);\n\t\t\t} catch (_unused2) {\n\t\t\t\tuseLegacy = true;\n\t\t\t}\n\t\t\tif (useLegacy) legacyCopy(value);\n\t\t\ttext.value = value;\n\t\t\tcopied.value = true;\n\t\t\ttimeout.start();\n\t\t}\n\t}\n\tfunction legacyCopy(value) {\n\t\tconst ta = document.createElement(\"textarea\");\n\t\tta.value = value;\n\t\tta.style.position = \"absolute\";\n\t\tta.style.opacity = \"0\";\n\t\tta.setAttribute(\"readonly\", \"\");\n\t\tdocument.body.appendChild(ta);\n\t\tta.select();\n\t\tdocument.execCommand(\"copy\");\n\t\tta.remove();\n\t}\n\tfunction legacyRead() {\n\t\tvar _document$getSelectio, _document, _document$getSelectio2;\n\t\treturn (_document$getSelectio = (_document = document) === null || _document === void 0 || (_document$getSelectio2 = _document.getSelection) === null || _document$getSelectio2 === void 0 || (_document$getSelectio2 = _document$getSelectio2.call(_document)) === null || _document$getSelectio2 === void 0 ? void 0 : _document$getSelectio2.toString()) !== null && _document$getSelectio !== void 0 ? _document$getSelectio : \"\";\n\t}\n\tfunction isAllowed(status) {\n\t\treturn status === \"granted\" || status === \"prompt\";\n\t}\n\treturn {\n\t\tisSupported,\n\t\ttext: readonly(text),\n\t\tcopied: readonly(copied),\n\t\tcopy\n\t};\n}\n\n//#endregion\n//#region useClipboardItems/index.ts\nfunction useClipboardItems(options = {}) {\n\tconst { navigator: navigator$1 = defaultNavigator, read = false, source, copiedDuring = 1500 } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => navigator$1 && \"clipboard\" in navigator$1);\n\tconst content = ref([]);\n\tconst copied = shallowRef(false);\n\tconst timeout = useTimeoutFn(() => copied.value = false, copiedDuring, { immediate: false });\n\tfunction updateContent() {\n\t\tif (isSupported.value) navigator$1.clipboard.read().then((items) => {\n\t\t\tcontent.value = items;\n\t\t});\n\t}\n\tif (isSupported.value && read) useEventListener([\"copy\", \"cut\"], updateContent, { passive: true });\n\tasync function copy(value = toValue(source)) {\n\t\tif (isSupported.value && value != null) {\n\t\t\tawait navigator$1.clipboard.write(value);\n\t\t\tcontent.value = value;\n\t\t\tcopied.value = true;\n\t\t\ttimeout.start();\n\t\t}\n\t}\n\treturn {\n\t\tisSupported,\n\t\tcontent: shallowReadonly(content),\n\t\tcopied: readonly(copied),\n\t\tcopy,\n\t\tread: updateContent\n\t};\n}\n\n//#endregion\n//#region useCloned/index.ts\nfunction cloneFnJSON(source) {\n\treturn JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n\tconst cloned = ref({});\n\tconst isModified = shallowRef(false);\n\tlet _lastSync = false;\n\tconst { manual, clone = cloneFnJSON, deep = true, immediate = true } = options;\n\twatch(cloned, () => {\n\t\tif (_lastSync) {\n\t\t\t_lastSync = false;\n\t\t\treturn;\n\t\t}\n\t\tisModified.value = true;\n\t}, {\n\t\tdeep: true,\n\t\tflush: \"sync\"\n\t});\n\tfunction sync() {\n\t\t_lastSync = true;\n\t\tisModified.value = false;\n\t\tcloned.value = clone(toValue(source));\n\t}\n\tif (!manual && (isRef(source) || typeof source === \"function\")) watch(source, sync, {\n\t\t...options,\n\t\tdeep,\n\t\timmediate\n\t});\n\telse sync();\n\treturn {\n\t\tcloned,\n\t\tisModified,\n\t\tsync\n\t};\n}\n\n//#endregion\n//#region ssr-handlers.ts\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\nconst handlers = /* @__PURE__ */ getHandlers();\nfunction getHandlers() {\n\tif (!(globalKey in _global)) _global[globalKey] = _global[globalKey] || {};\n\treturn _global[globalKey];\n}\nfunction getSSRHandler(key, fallback) {\n\treturn handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n\thandlers[key] = fn;\n}\n\n//#endregion\n//#region usePreferredDark/index.ts\n/**\n* Reactive dark theme preference.\n*\n* @see https://vueuse.org/usePreferredDark\n* @param [options]\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction usePreferredDark(options) {\n\treturn useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\n//#endregion\n//#region useStorage/guess.ts\nfunction guessSerializerType(rawInit) {\n\treturn rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\n//#endregion\n//#region useStorage/index.ts\nconst StorageSerializers = {\n\tboolean: {\n\t\tread: (v) => v === \"true\",\n\t\twrite: (v) => String(v)\n\t},\n\tobject: {\n\t\tread: (v) => JSON.parse(v),\n\t\twrite: (v) => JSON.stringify(v)\n\t},\n\tnumber: {\n\t\tread: (v) => Number.parseFloat(v),\n\t\twrite: (v) => String(v)\n\t},\n\tany: {\n\t\tread: (v) => v,\n\t\twrite: (v) => String(v)\n\t},\n\tstring: {\n\t\tread: (v) => v,\n\t\twrite: (v) => String(v)\n\t},\n\tmap: {\n\t\tread: (v) => new Map(JSON.parse(v)),\n\t\twrite: (v) => JSON.stringify(Array.from(v.entries()))\n\t},\n\tset: {\n\t\tread: (v) => new Set(JSON.parse(v)),\n\t\twrite: (v) => JSON.stringify(Array.from(v))\n\t},\n\tdate: {\n\t\tread: (v) => new Date(v),\n\t\twrite: (v) => v.toISOString()\n\t}\n};\nconst customStorageEventName = \"vueuse-storage\";\n/**\n* Reactive LocalStorage/SessionStorage.\n*\n* @see https://vueuse.org/useStorage\n*/\nfunction useStorage(key, defaults$1, storage, options = {}) {\n\tvar _options$serializer;\n\tconst { flush = \"pre\", deep = true, listenToStorageChanges = true, writeDefaults = true, mergeDefaults = false, shallow, window: window$1 = defaultWindow, eventFilter, onError = (e) => {\n\t\tconsole.error(e);\n\t}, initOnMounted } = options;\n\tconst data = (shallow ? shallowRef : ref)(typeof defaults$1 === \"function\" ? defaults$1() : defaults$1);\n\tconst keyComputed = computed(() => toValue(key));\n\tif (!storage) try {\n\t\tstorage = getSSRHandler(\"getDefaultStorage\", () => defaultWindow === null || defaultWindow === void 0 ? void 0 : defaultWindow.localStorage)();\n\t} catch (e) {\n\t\tonError(e);\n\t}\n\tif (!storage) return data;\n\tconst rawInit = toValue(defaults$1);\n\tconst type = guessSerializerType(rawInit);\n\tconst serializer = (_options$serializer = options.serializer) !== null && _options$serializer !== void 0 ? _options$serializer : StorageSerializers[type];\n\tconst { pause: pauseWatch, resume: resumeWatch } = watchPausable(data, (newValue) => write(newValue), {\n\t\tflush,\n\t\tdeep,\n\t\teventFilter\n\t});\n\twatch(keyComputed, () => update(), { flush });\n\tlet firstMounted = false;\n\tconst onStorageEvent = (ev) => {\n\t\tif (initOnMounted && !firstMounted) return;\n\t\tupdate(ev);\n\t};\n\tconst onStorageCustomEvent = (ev) => {\n\t\tif (initOnMounted && !firstMounted) return;\n\t\tupdateFromCustomEvent(ev);\n\t};\n\t/**\n\t* The custom event is needed for same-document syncing when using custom\n\t* storage backends, but it doesn't work across different documents.\n\t*\n\t* TODO: Consider implementing a BroadcastChannel-based solution that fixes this.\n\t*/\n\tif (window$1 && listenToStorageChanges) if (storage instanceof Storage) useEventListener(window$1, \"storage\", onStorageEvent, { passive: true });\n\telse useEventListener(window$1, customStorageEventName, onStorageCustomEvent);\n\tif (initOnMounted) tryOnMounted(() => {\n\t\tfirstMounted = true;\n\t\tupdate();\n\t});\n\telse update();\n\tfunction dispatchWriteEvent(oldValue, newValue) {\n\t\tif (window$1) {\n\t\t\tconst payload = {\n\t\t\t\tkey: keyComputed.value,\n\t\t\t\toldValue,\n\t\t\t\tnewValue,\n\t\t\t\tstorageArea: storage\n\t\t\t};\n\t\t\twindow$1.dispatchEvent(storage instanceof Storage ? new StorageEvent(\"storage\", payload) : new CustomEvent(customStorageEventName, { detail: payload }));\n\t\t}\n\t}\n\tfunction write(v) {\n\t\ttry {\n\t\t\tconst oldValue = storage.getItem(keyComputed.value);\n\t\t\tif (v == null) {\n\t\t\t\tdispatchWriteEvent(oldValue, null);\n\t\t\t\tstorage.removeItem(keyComputed.value);\n\t\t\t} else {\n\t\t\t\tconst serialized = serializer.write(v);\n\t\t\t\tif (oldValue !== serialized) {\n\t\t\t\t\tstorage.setItem(keyComputed.value, serialized);\n\t\t\t\t\tdispatchWriteEvent(oldValue, serialized);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tonError(e);\n\t\t}\n\t}\n\tfunction read(event) {\n\t\tconst rawValue = event ? event.newValue : storage.getItem(keyComputed.value);\n\t\tif (rawValue == null) {\n\t\t\tif (writeDefaults && rawInit != null) storage.setItem(keyComputed.value, serializer.write(rawInit));\n\t\t\treturn rawInit;\n\t\t} else if (!event && mergeDefaults) {\n\t\t\tconst value = serializer.read(rawValue);\n\t\t\tif (typeof mergeDefaults === \"function\") return mergeDefaults(value, rawInit);\n\t\t\telse if (type === \"object\" && !Array.isArray(value)) return {\n\t\t\t\t...rawInit,\n\t\t\t\t...value\n\t\t\t};\n\t\t\treturn value;\n\t\t} else if (typeof rawValue !== \"string\") return rawValue;\n\t\telse return serializer.read(rawValue);\n\t}\n\tfunction update(event) {\n\t\tif (event && event.storageArea !== storage) return;\n\t\tif (event && event.key == null) {\n\t\t\tdata.value = rawInit;\n\t\t\treturn;\n\t\t}\n\t\tif (event && event.key !== keyComputed.value) return;\n\t\tpauseWatch();\n\t\ttry {\n\t\t\tconst serializedData = serializer.write(data.value);\n\t\t\tif (event === void 0 || (event === null || event === void 0 ? void 0 : event.newValue) !== serializedData) data.value = read(event);\n\t\t} catch (e) {\n\t\t\tonError(e);\n\t\t} finally {\n\t\t\tif (event) nextTick(resumeWatch);\n\t\t\telse resumeWatch();\n\t\t}\n\t}\n\tfunction updateFromCustomEvent(event) {\n\t\tupdate(event.detail);\n\t}\n\treturn data;\n}\n\n//#endregion\n//#region useColorMode/index.ts\nconst CSS_DISABLE_TRANS = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\n/**\n* Reactive color mode with auto data persistence.\n*\n* @see https://vueuse.org/useColorMode\n* @param options\n*/\nfunction useColorMode(options = {}) {\n\tconst { selector = \"html\", attribute = \"class\", initialValue = \"auto\", window: window$1 = defaultWindow, storage, storageKey = \"vueuse-color-scheme\", listenToStorageChanges = true, storageRef, emitAuto, disableTransition = true } = options;\n\tconst modes = {\n\t\tauto: \"\",\n\t\tlight: \"light\",\n\t\tdark: \"dark\",\n\t\t...options.modes || {}\n\t};\n\tconst preferredDark = usePreferredDark({ window: window$1 });\n\tconst system = computed(() => preferredDark.value ? \"dark\" : \"light\");\n\tconst store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, {\n\t\twindow: window$1,\n\t\tlistenToStorageChanges\n\t}));\n\tconst state = computed(() => store.value === \"auto\" ? system.value : store.value);\n\tconst updateHTMLAttrs = getSSRHandler(\"updateHTMLAttrs\", (selector$1, attribute$1, value) => {\n\t\tconst el = typeof selector$1 === \"string\" ? window$1 === null || window$1 === void 0 ? void 0 : window$1.document.querySelector(selector$1) : unrefElement(selector$1);\n\t\tif (!el) return;\n\t\tconst classesToAdd = /* @__PURE__ */ new Set();\n\t\tconst classesToRemove = /* @__PURE__ */ new Set();\n\t\tlet attributeToChange = null;\n\t\tif (attribute$1 === \"class\") {\n\t\t\tconst current = value.split(/\\s/g);\n\t\t\tObject.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n\t\t\t\tif (current.includes(v)) classesToAdd.add(v);\n\t\t\t\telse classesToRemove.add(v);\n\t\t\t});\n\t\t} else attributeToChange = {\n\t\t\tkey: attribute$1,\n\t\t\tvalue\n\t\t};\n\t\tif (classesToAdd.size === 0 && classesToRemove.size === 0 && attributeToChange === null) return;\n\t\tlet style;\n\t\tif (disableTransition) {\n\t\t\tstyle = window$1.document.createElement(\"style\");\n\t\t\tstyle.appendChild(document.createTextNode(CSS_DISABLE_TRANS));\n\t\t\twindow$1.document.head.appendChild(style);\n\t\t}\n\t\tfor (const c of classesToAdd) el.classList.add(c);\n\t\tfor (const c of classesToRemove) el.classList.remove(c);\n\t\tif (attributeToChange) el.setAttribute(attributeToChange.key, attributeToChange.value);\n\t\tif (disableTransition) {\n\t\t\twindow$1.getComputedStyle(style).opacity;\n\t\t\tdocument.head.removeChild(style);\n\t\t}\n\t});\n\tfunction defaultOnChanged(mode) {\n\t\tvar _modes$mode;\n\t\tupdateHTMLAttrs(selector, attribute, (_modes$mode = modes[mode]) !== null && _modes$mode !== void 0 ? _modes$mode : mode);\n\t}\n\tfunction onChanged(mode) {\n\t\tif (options.onChanged) options.onChanged(mode, defaultOnChanged);\n\t\telse defaultOnChanged(mode);\n\t}\n\twatch(state, onChanged, {\n\t\tflush: \"post\",\n\t\timmediate: true\n\t});\n\ttryOnMounted(() => onChanged(state.value));\n\tconst auto = computed({\n\t\tget() {\n\t\t\treturn emitAuto ? store.value : state.value;\n\t\t},\n\t\tset(v) {\n\t\t\tstore.value = v;\n\t\t}\n\t});\n\treturn Object.assign(auto, {\n\t\tstore,\n\t\tsystem,\n\t\tstate\n\t});\n}\n\n//#endregion\n//#region useConfirmDialog/index.ts\n/**\n* Hooks for creating confirm dialogs. Useful for modal windows, popups and logins.\n*\n* @see https://vueuse.org/useConfirmDialog/\n* @param revealed `boolean` `ref` that handles a modal window\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useConfirmDialog(revealed = shallowRef(false)) {\n\tconst confirmHook = createEventHook();\n\tconst cancelHook = createEventHook();\n\tconst revealHook = createEventHook();\n\tlet _resolve = noop;\n\tconst reveal = (data) => {\n\t\trevealHook.trigger(data);\n\t\trevealed.value = true;\n\t\treturn new Promise((resolve) => {\n\t\t\t_resolve = resolve;\n\t\t});\n\t};\n\tconst confirm = (data) => {\n\t\trevealed.value = false;\n\t\tconfirmHook.trigger(data);\n\t\t_resolve({\n\t\t\tdata,\n\t\t\tisCanceled: false\n\t\t});\n\t};\n\tconst cancel = (data) => {\n\t\trevealed.value = false;\n\t\tcancelHook.trigger(data);\n\t\t_resolve({\n\t\t\tdata,\n\t\t\tisCanceled: true\n\t\t});\n\t};\n\treturn {\n\t\tisRevealed: computed(() => revealed.value),\n\t\treveal,\n\t\tconfirm,\n\t\tcancel,\n\t\tonReveal: revealHook.on,\n\t\tonConfirm: confirmHook.on,\n\t\tonCancel: cancelHook.on\n\t};\n}\n\n//#endregion\n//#region useCountdown/index.ts\nfunction getDefaultScheduler$8(options) {\n\tif (\"interval\" in options || \"immediate\" in options) {\n\t\tconst { interval = 1e3, immediate = false } = options;\n\t\treturn (cb) => useIntervalFn(cb, interval, { immediate });\n\t}\n\treturn (cb) => useIntervalFn(cb, 1e3, { immediate: false });\n}\n/**\n* Reactive countdown timer in seconds.\n*\n* @param initialCountdown\n* @param options\n*\n* @see https://vueuse.org/useCountdown\n*/\nfunction useCountdown(initialCountdown, options = {}) {\n\tconst remaining = shallowRef(toValue(initialCountdown));\n\tconst { scheduler = getDefaultScheduler$8(options), onTick, onComplete } = options;\n\tconst controls = scheduler(() => {\n\t\tconst value = remaining.value - 1;\n\t\tremaining.value = value < 0 ? 0 : value;\n\t\tonTick === null || onTick === void 0 || onTick();\n\t\tif (remaining.value <= 0) {\n\t\t\tcontrols.pause();\n\t\t\tonComplete === null || onComplete === void 0 || onComplete();\n\t\t}\n\t});\n\tconst reset = (countdown) => {\n\t\tvar _toValue;\n\t\tremaining.value = (_toValue = toValue(countdown)) !== null && _toValue !== void 0 ? _toValue : toValue(initialCountdown);\n\t};\n\tconst stop = () => {\n\t\tcontrols.pause();\n\t\treset();\n\t};\n\tconst resume = () => {\n\t\tif (!controls.isActive.value) {\n\t\t\tif (remaining.value > 0) controls.resume();\n\t\t}\n\t};\n\tconst start = (countdown) => {\n\t\treset(countdown);\n\t\tcontrols.resume();\n\t};\n\treturn {\n\t\tremaining,\n\t\treset,\n\t\tstop,\n\t\tstart,\n\t\tpause: controls.pause,\n\t\tresume,\n\t\tisActive: controls.isActive\n\t};\n}\n\n//#endregion\n//#region useCssSupports/index.ts\nfunction useCssSupports(...args) {\n\tlet options = {};\n\tif (typeof toValue(args.at(-1)) === \"object\") options = args.pop();\n\tconst [prop, value] = args;\n\tconst { window: window$1 = defaultWindow, ssrValue = false } = options;\n\tconst isMounted = useMounted();\n\treturn { isSupported: computed(() => {\n\t\tisMounted.value;\n\t\tif (!isClient) return ssrValue;\n\t\treturn args.length === 2 ? window$1 === null || window$1 === void 0 ? void 0 : window$1.CSS.supports(toValue(prop), toValue(value)) : window$1 === null || window$1 === void 0 ? void 0 : window$1.CSS.supports(toValue(prop));\n\t}) };\n}\n\n//#endregion\n//#region useCssVar/index.ts\n/**\n* Manipulate CSS variables.\n*\n* @see https://vueuse.org/useCssVar\n* @param prop\n* @param target\n* @param options\n*/\nfunction useCssVar(prop, target, options = {}) {\n\tconst { window: window$1 = defaultWindow, initialValue, observe = false } = options;\n\tconst variable = shallowRef(initialValue);\n\tconst elRef = computed(() => {\n\t\tvar _window$document;\n\t\treturn unrefElement(target) || (window$1 === null || window$1 === void 0 || (_window$document = window$1.document) === null || _window$document === void 0 ? void 0 : _window$document.documentElement);\n\t});\n\tfunction updateCssVar() {\n\t\tconst key = toValue(prop);\n\t\tconst el = toValue(elRef);\n\t\tif (el && window$1 && key) {\n\t\t\tvar _window$getComputedSt;\n\t\t\tvariable.value = ((_window$getComputedSt = window$1.getComputedStyle(el).getPropertyValue(key)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.trim()) || variable.value || initialValue;\n\t\t}\n\t}\n\tif (observe) useMutationObserver(elRef, updateCssVar, {\n\t\tattributeFilter: [\"style\", \"class\"],\n\t\twindow: window$1\n\t});\n\twatch([elRef, () => toValue(prop)], (_, old) => {\n\t\tif (old[0] && old[1]) old[0].style.removeProperty(old[1]);\n\t\tupdateCssVar();\n\t}, { immediate: true });\n\twatch([variable, elRef], ([val, el]) => {\n\t\tconst raw_prop = toValue(prop);\n\t\tif ((el === null || el === void 0 ? void 0 : el.style) && raw_prop) if (val == null) el.style.removeProperty(raw_prop);\n\t\telse el.style.setProperty(raw_prop, val);\n\t}, { immediate: true });\n\treturn variable;\n}\n\n//#endregion\n//#region useCurrentElement/index.ts\nfunction useCurrentElement(rootComponent) {\n\tconst vm = getCurrentInstance();\n\tconst currentElement = computedWithControl(() => null, () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el);\n\tonUpdated(currentElement.trigger);\n\tonMounted(currentElement.trigger);\n\treturn currentElement;\n}\n\n//#endregion\n//#region useCycleList/index.ts\n/**\n* Cycle through a list of items\n*\n* @see https://vueuse.org/useCycleList\n*/\nfunction useCycleList(list, options) {\n\tconst state = shallowRef(getInitialValue());\n\tconst listRef = toRef(list);\n\tconst index = computed({\n\t\tget() {\n\t\t\tvar _options$fallbackInde;\n\t\t\tconst targetList = listRef.value;\n\t\t\tlet index$1 = (options === null || options === void 0 ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);\n\t\t\tif (index$1 < 0) index$1 = (_options$fallbackInde = options === null || options === void 0 ? void 0 : options.fallbackIndex) !== null && _options$fallbackInde !== void 0 ? _options$fallbackInde : 0;\n\t\t\treturn index$1;\n\t\t},\n\t\tset(v) {\n\t\t\tset(v);\n\t\t}\n\t});\n\tfunction set(i) {\n\t\tconst targetList = listRef.value;\n\t\tconst length = targetList.length;\n\t\tconst value = targetList[(i % length + length) % length];\n\t\tstate.value = value;\n\t\treturn value;\n\t}\n\tfunction shift(delta = 1) {\n\t\treturn set(index.value + delta);\n\t}\n\tfunction next(n = 1) {\n\t\treturn shift(n);\n\t}\n\tfunction prev(n = 1) {\n\t\treturn shift(-n);\n\t}\n\tfunction getInitialValue() {\n\t\tvar _toValue, _options$initialValue;\n\t\treturn (_toValue = toValue((_options$initialValue = options === null || options === void 0 ? void 0 : options.initialValue) !== null && _options$initialValue !== void 0 ? _options$initialValue : toValue(list)[0])) !== null && _toValue !== void 0 ? _toValue : void 0;\n\t}\n\twatch(listRef, () => set(index.value));\n\treturn {\n\t\tstate,\n\t\tindex,\n\t\tnext,\n\t\tprev,\n\t\tgo: set\n\t};\n}\n\n//#endregion\n//#region useDark/index.ts\n/**\n* Reactive dark mode with auto data persistence.\n*\n* @see https://vueuse.org/useDark\n* @param options\n*/\nfunction useDark(options = {}) {\n\tconst { valueDark = \"dark\", valueLight = \"\" } = options;\n\tconst mode = useColorMode({\n\t\t...options,\n\t\tonChanged: (mode$1, defaultHandler) => {\n\t\t\tvar _options$onChanged;\n\t\t\tif (options.onChanged) (_options$onChanged = options.onChanged) === null || _options$onChanged === void 0 || _options$onChanged.call(options, mode$1 === \"dark\", defaultHandler, mode$1);\n\t\t\telse defaultHandler(mode$1);\n\t\t},\n\t\tmodes: {\n\t\t\tdark: valueDark,\n\t\t\tlight: valueLight\n\t\t}\n\t});\n\tconst system = computed(() => mode.system.value);\n\treturn computed({\n\t\tget() {\n\t\t\treturn mode.value === \"dark\";\n\t\t},\n\t\tset(v) {\n\t\t\tconst modeVal = v ? \"dark\" : \"light\";\n\t\t\tif (system.value === modeVal) mode.value = \"auto\";\n\t\t\telse mode.value = modeVal;\n\t\t}\n\t});\n}\n\n//#endregion\n//#region useManualRefHistory/index.ts\nfunction fnBypass(v) {\n\treturn v;\n}\nfunction fnSetSource(source, value) {\n\treturn source.value = value;\n}\nfunction defaultDump(clone) {\n\treturn clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n\treturn clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\n/**\n* Track the change history of a ref, also provides undo and redo functionality.\n*\n* @see https://vueuse.org/useManualRefHistory\n* @param source\n* @param options\n*/\nfunction useManualRefHistory(source, options = {}) {\n\tconst { clone = false, dump = defaultDump(clone), parse = defaultParse(clone), setSource = fnSetSource } = options;\n\tfunction _createHistoryRecord() {\n\t\treturn markRaw({\n\t\t\tsnapshot: dump(source.value),\n\t\t\ttimestamp: timestamp()\n\t\t});\n\t}\n\tconst last = ref(_createHistoryRecord());\n\tconst undoStack = ref([]);\n\tconst redoStack = ref([]);\n\tconst _setSource = (record) => {\n\t\tsetSource(source, parse(record.snapshot));\n\t\tlast.value = record;\n\t};\n\tconst commit = () => {\n\t\tundoStack.value.unshift(last.value);\n\t\tlast.value = _createHistoryRecord();\n\t\tif (options.capacity && undoStack.value.length > options.capacity) undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY);\n\t\tif (redoStack.value.length) redoStack.value.splice(0, redoStack.value.length);\n\t};\n\tconst clear = () => {\n\t\tundoStack.value.splice(0, undoStack.value.length);\n\t\tredoStack.value.splice(0, redoStack.value.length);\n\t};\n\tconst undo = () => {\n\t\tconst state = undoStack.value.shift();\n\t\tif (state) {\n\t\t\tredoStack.value.unshift(last.value);\n\t\t\t_setSource(state);\n\t\t}\n\t};\n\tconst redo = () => {\n\t\tconst state = redoStack.value.shift();\n\t\tif (state) {\n\t\t\tundoStack.value.unshift(last.value);\n\t\t\t_setSource(state);\n\t\t}\n\t};\n\tconst reset = () => {\n\t\t_setSource(last.value);\n\t};\n\treturn {\n\t\tsource,\n\t\tundoStack,\n\t\tredoStack,\n\t\tlast,\n\t\thistory: computed(() => [last.value, ...undoStack.value]),\n\t\tcanUndo: computed(() => undoStack.value.length > 0),\n\t\tcanRedo: computed(() => redoStack.value.length > 0),\n\t\tclear,\n\t\tcommit,\n\t\treset,\n\t\tundo,\n\t\tredo\n\t};\n}\n\n//#endregion\n//#region useRefHistory/index.ts\n/**\n* Track the change history of a ref, also provides undo and redo functionality.\n*\n* @see https://vueuse.org/useRefHistory\n* @param source\n* @param options\n*/\nfunction useRefHistory(source, options = {}) {\n\tconst { deep = false, flush = \"pre\", eventFilter, shouldCommit = () => true } = options;\n\tconst { eventFilter: composedFilter, pause, resume: resumeTracking, isActive: isTracking } = pausableFilter(eventFilter);\n\tlet lastRawValue = source.value;\n\tconst { ignoreUpdates, ignorePrevAsyncUpdates, stop } = watchIgnorable(source, commit, {\n\t\tdeep,\n\t\tflush,\n\t\teventFilter: composedFilter\n\t});\n\tfunction setSource(source$1, value) {\n\t\tignorePrevAsyncUpdates();\n\t\tignoreUpdates(() => {\n\t\t\tsource$1.value = value;\n\t\t\tlastRawValue = value;\n\t\t});\n\t}\n\tconst manualHistory = useManualRefHistory(source, {\n\t\t...options,\n\t\tclone: options.clone || deep,\n\t\tsetSource\n\t});\n\tconst { clear, commit: manualCommit } = manualHistory;\n\tfunction commit() {\n\t\tignorePrevAsyncUpdates();\n\t\tif (!shouldCommit(lastRawValue, source.value)) return;\n\t\tlastRawValue = source.value;\n\t\tmanualCommit();\n\t}\n\tfunction resume(commitNow) {\n\t\tresumeTracking();\n\t\tif (commitNow) commit();\n\t}\n\tfunction batch(fn) {\n\t\tlet canceled = false;\n\t\tconst cancel = () => canceled = true;\n\t\tignoreUpdates(() => {\n\t\t\tfn(cancel);\n\t\t});\n\t\tif (!canceled) commit();\n\t}\n\tfunction dispose() {\n\t\tstop();\n\t\tclear();\n\t}\n\treturn {\n\t\t...manualHistory,\n\t\tisTracking,\n\t\tpause,\n\t\tresume,\n\t\tcommit,\n\t\tbatch,\n\t\tdispose\n\t};\n}\n\n//#endregion\n//#region useDebouncedRefHistory/index.ts\n/**\n* Shorthand for [useRefHistory](https://vueuse.org/useRefHistory) with debounce filter.\n*\n* @see https://vueuse.org/useDebouncedRefHistory\n* @param source\n* @param options\n*/\nfunction useDebouncedRefHistory(source, options = {}) {\n\tconst filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n\treturn { ...useRefHistory(source, {\n\t\t...options,\n\t\teventFilter: filter\n\t}) };\n}\n\n//#endregion\n//#region useDeviceMotion/index.ts\n/**\n* Reactive DeviceMotionEvent.\n*\n* @see https://vueuse.org/useDeviceMotion\n* @param options\n*/\nfunction useDeviceMotion(options = {}) {\n\tconst { window: window$1 = defaultWindow, requestPermissions = false, eventFilter = bypassFilter } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => typeof DeviceMotionEvent !== \"undefined\");\n\tconst requirePermissions = /* @__PURE__ */ useSupported(() => isSupported.value && \"requestPermission\" in DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === \"function\");\n\tconst permissionGranted = shallowRef(false);\n\tconst acceleration = ref({\n\t\tx: null,\n\t\ty: null,\n\t\tz: null\n\t});\n\tconst rotationRate = ref({\n\t\talpha: null,\n\t\tbeta: null,\n\t\tgamma: null\n\t});\n\tconst interval = shallowRef(0);\n\tconst accelerationIncludingGravity = ref({\n\t\tx: null,\n\t\ty: null,\n\t\tz: null\n\t});\n\tfunction init() {\n\t\tif (window$1) useEventListener(window$1, \"devicemotion\", createFilterWrapper(eventFilter, (event) => {\n\t\t\tvar _event$acceleration, _event$acceleration2, _event$acceleration3, _event$accelerationIn, _event$accelerationIn2, _event$accelerationIn3, _event$rotationRate, _event$rotationRate2, _event$rotationRate3;\n\t\t\tacceleration.value = {\n\t\t\t\tx: ((_event$acceleration = event.acceleration) === null || _event$acceleration === void 0 ? void 0 : _event$acceleration.x) || null,\n\t\t\t\ty: ((_event$acceleration2 = event.acceleration) === null || _event$acceleration2 === void 0 ? void 0 : _event$acceleration2.y) || null,\n\t\t\t\tz: ((_event$acceleration3 = event.acceleration) === null || _event$acceleration3 === void 0 ? void 0 : _event$acceleration3.z) || null\n\t\t\t};\n\t\t\taccelerationIncludingGravity.value = {\n\t\t\t\tx: ((_event$accelerationIn = event.accelerationIncludingGravity) === null || _event$accelerationIn === void 0 ? void 0 : _event$accelerationIn.x) || null,\n\t\t\t\ty: ((_event$accelerationIn2 = event.accelerationIncludingGravity) === null || _event$accelerationIn2 === void 0 ? void 0 : _event$accelerationIn2.y) || null,\n\t\t\t\tz: ((_event$accelerationIn3 = event.accelerationIncludingGravity) === null || _event$accelerationIn3 === void 0 ? void 0 : _event$accelerationIn3.z) || null\n\t\t\t};\n\t\t\trotationRate.value = {\n\t\t\t\talpha: ((_event$rotationRate = event.rotationRate) === null || _event$rotationRate === void 0 ? void 0 : _event$rotationRate.alpha) || null,\n\t\t\t\tbeta: ((_event$rotationRate2 = event.rotationRate) === null || _event$rotationRate2 === void 0 ? void 0 : _event$rotationRate2.beta) || null,\n\t\t\t\tgamma: ((_event$rotationRate3 = event.rotationRate) === null || _event$rotationRate3 === void 0 ? void 0 : _event$rotationRate3.gamma) || null\n\t\t\t};\n\t\t\tinterval.value = event.interval;\n\t\t}), { passive: true });\n\t}\n\tconst ensurePermissions = async () => {\n\t\tif (!requirePermissions.value) permissionGranted.value = true;\n\t\tif (permissionGranted.value) return;\n\t\tif (requirePermissions.value) {\n\t\t\tconst requestPermission = DeviceMotionEvent.requestPermission;\n\t\t\ttry {\n\t\t\t\tif (await requestPermission() === \"granted\") {\n\t\t\t\t\tpermissionGranted.value = true;\n\t\t\t\t\tinit();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t}\n\t};\n\tif (isSupported.value) if (requestPermissions && requirePermissions.value) ensurePermissions().then(() => init());\n\telse init();\n\treturn {\n\t\tacceleration,\n\t\taccelerationIncludingGravity,\n\t\trotationRate,\n\t\tinterval,\n\t\tisSupported,\n\t\trequirePermissions,\n\t\tensurePermissions,\n\t\tpermissionGranted\n\t};\n}\n\n//#endregion\n//#region useDeviceOrientation/index.ts\n/**\n* Reactive DeviceOrientationEvent.\n*\n* @see https://vueuse.org/useDeviceOrientation\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useDeviceOrientation(options = {}) {\n\tconst { window: window$1 = defaultWindow } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => window$1 && \"DeviceOrientationEvent\" in window$1);\n\tconst isAbsolute = shallowRef(false);\n\tconst alpha = shallowRef(null);\n\tconst beta = shallowRef(null);\n\tconst gamma = shallowRef(null);\n\tif (window$1 && isSupported.value) useEventListener(window$1, \"deviceorientation\", (event) => {\n\t\tisAbsolute.value = event.absolute;\n\t\talpha.value = event.alpha;\n\t\tbeta.value = event.beta;\n\t\tgamma.value = event.gamma;\n\t}, { passive: true });\n\treturn {\n\t\tisSupported,\n\t\tisAbsolute,\n\t\talpha,\n\t\tbeta,\n\t\tgamma\n\t};\n}\n\n//#endregion\n//#region useDevicePixelRatio/index.ts\n/**\n* Reactively track `window.devicePixelRatio`.\n*\n* @see https://vueuse.org/useDevicePixelRatio\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useDevicePixelRatio(options = {}) {\n\tconst { window: window$1 = defaultWindow } = options;\n\tconst pixelRatio = shallowRef(1);\n\tconst query = useMediaQuery(() => `(resolution: ${pixelRatio.value}dppx)`, options);\n\tlet stop = noop;\n\tif (window$1) stop = watchImmediate(query, () => pixelRatio.value = window$1.devicePixelRatio);\n\treturn {\n\t\tpixelRatio: readonly(pixelRatio),\n\t\tstop\n\t};\n}\n\n//#endregion\n//#region useDevicesList/index.ts\n/**\n* Reactive `enumerateDevices` listing available input/output devices\n*\n* @see https://vueuse.org/useDevicesList\n* @param options\n*/\nfunction useDevicesList(options = {}) {\n\tconst { navigator: navigator$1 = defaultNavigator, requestPermissions = false, constraints = {\n\t\taudio: true,\n\t\tvideo: true\n\t}, onUpdated: onUpdated$1 } = options;\n\tconst devices = ref([]);\n\tconst videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n\tconst audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n\tconst audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n\tconst isSupported = /* @__PURE__ */ useSupported(() => navigator$1 && navigator$1.mediaDevices && navigator$1.mediaDevices.enumerateDevices);\n\tconst permissionGranted = shallowRef(false);\n\tlet stream;\n\tasync function update() {\n\t\tif (!isSupported.value) return;\n\t\tdevices.value = await navigator$1.mediaDevices.enumerateDevices();\n\t\tonUpdated$1 === null || onUpdated$1 === void 0 || onUpdated$1(devices.value);\n\t\tif (stream) {\n\t\t\tstream.getTracks().forEach((t) => t.stop());\n\t\t\tstream = null;\n\t\t}\n\t}\n\tasync function ensurePermissions() {\n\t\tconst deviceName = constraints.video ? \"camera\" : \"microphone\";\n\t\tif (!isSupported.value) return false;\n\t\tif (permissionGranted.value) return true;\n\t\tconst { state, query } = usePermission(deviceName, { controls: true });\n\t\tawait query();\n\t\tif (state.value !== \"granted\") {\n\t\t\tlet granted = true;\n\t\t\ttry {\n\t\t\t\tconst allDevices = await navigator$1.mediaDevices.enumerateDevices();\n\t\t\t\tconst hasCamera = allDevices.some((device) => device.kind === \"videoinput\");\n\t\t\t\tconst hasMicrophone = allDevices.some((device) => device.kind === \"audioinput\" || device.kind === \"audiooutput\");\n\t\t\t\tconstraints.video = hasCamera ? constraints.video : false;\n\t\t\t\tconstraints.audio = hasMicrophone ? constraints.audio : false;\n\t\t\t\tstream = await navigator$1.mediaDevices.getUserMedia(constraints);\n\t\t\t} catch (_unused) {\n\t\t\t\tstream = null;\n\t\t\t\tgranted = false;\n\t\t\t}\n\t\t\tupdate();\n\t\t\tpermissionGranted.value = granted;\n\t\t} else permissionGranted.value = true;\n\t\treturn permissionGranted.value;\n\t}\n\tif (isSupported.value) {\n\t\tif (requestPermissions) ensurePermissions();\n\t\tuseEventListener(navigator$1.mediaDevices, \"devicechange\", update, { passive: true });\n\t\tupdate();\n\t}\n\treturn {\n\t\tdevices,\n\t\tensurePermissions,\n\t\tpermissionGranted,\n\t\tvideoInputs,\n\t\taudioInputs,\n\t\taudioOutputs,\n\t\tisSupported\n\t};\n}\n\n//#endregion\n//#region useDisplayMedia/index.ts\n/**\n* Reactive `mediaDevices.getDisplayMedia` streaming\n*\n* @see https://vueuse.org/useDisplayMedia\n* @param options\n*/\nfunction useDisplayMedia(options = {}) {\n\tvar _options$enabled;\n\tconst enabled = shallowRef((_options$enabled = options.enabled) !== null && _options$enabled !== void 0 ? _options$enabled : false);\n\tconst video = options.video;\n\tconst audio = options.audio;\n\tconst { navigator: navigator$1 = defaultNavigator } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => {\n\t\tvar _navigator$mediaDevic;\n\t\treturn navigator$1 === null || navigator$1 === void 0 || (_navigator$mediaDevic = navigator$1.mediaDevices) === null || _navigator$mediaDevic === void 0 ? void 0 : _navigator$mediaDevic.getDisplayMedia;\n\t});\n\tconst constraint = {\n\t\taudio,\n\t\tvideo\n\t};\n\tconst stream = shallowRef();\n\tasync function _start() {\n\t\tvar _stream$value;\n\t\tif (!isSupported.value || stream.value) return;\n\t\tstream.value = await navigator$1.mediaDevices.getDisplayMedia(constraint);\n\t\t(_stream$value = stream.value) === null || _stream$value === void 0 || _stream$value.getTracks().forEach((t) => useEventListener(t, \"ended\", stop, { passive: true }));\n\t\treturn stream.value;\n\t}\n\tasync function _stop() {\n\t\tvar _stream$value2;\n\t\t(_stream$value2 = stream.value) === null || _stream$value2 === void 0 || _stream$value2.getTracks().forEach((t) => t.stop());\n\t\tstream.value = void 0;\n\t}\n\tfunction stop() {\n\t\t_stop();\n\t\tenabled.value = false;\n\t}\n\tasync function start() {\n\t\tawait _start();\n\t\tif (stream.value) enabled.value = true;\n\t\treturn stream.value;\n\t}\n\twatch(enabled, (v) => {\n\t\tif (v) _start();\n\t\telse _stop();\n\t}, { immediate: true });\n\treturn {\n\t\tisSupported,\n\t\tstream,\n\t\tstart,\n\t\tstop,\n\t\tenabled\n\t};\n}\n\n//#endregion\n//#region useDocumentVisibility/index.ts\n/**\n* Reactively track `document.visibilityState`.\n*\n* @see https://vueuse.org/useDocumentVisibility\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useDocumentVisibility(options = {}) {\n\tconst { document: document$1 = defaultDocument } = options;\n\tif (!document$1) return shallowRef(\"visible\");\n\tconst visibility = shallowRef(document$1.visibilityState);\n\tuseEventListener(document$1, \"visibilitychange\", () => {\n\t\tvisibility.value = document$1.visibilityState;\n\t}, { passive: true });\n\treturn visibility;\n}\n\n//#endregion\n//#region useDraggable/index.ts\nconst defaultScrollConfig = {\n\tspeed: 2,\n\tmargin: 30,\n\tdirection: \"both\"\n};\nfunction clampContainerScroll(container) {\n\tif (container.scrollLeft > container.scrollWidth - container.clientWidth) container.scrollLeft = Math.max(0, container.scrollWidth - container.clientWidth);\n\tif (container.scrollTop > container.scrollHeight - container.clientHeight) container.scrollTop = Math.max(0, container.scrollHeight - container.clientHeight);\n}\n/**\n* Make elements draggable.\n*\n* @see https://vueuse.org/useDraggable\n* @param target\n* @param options\n*/\nfunction useDraggable(target, options = {}) {\n\tvar _toValue, _toValue2, _toValue3, _scrollConfig$directi;\n\tconst { pointerTypes, preventDefault: preventDefault$1, stopPropagation, exact, onMove, onEnd, onStart, initialValue, axis = \"both\", draggingElement = defaultWindow, containerElement, handle: draggingHandle = target, buttons = [0], restrictInView, autoScroll = false } = options;\n\tconst position = ref((_toValue = toValue(initialValue)) !== null && _toValue !== void 0 ? _toValue : {\n\t\tx: 0,\n\t\ty: 0\n\t});\n\tconst pressedDelta = ref();\n\tconst filterEvent = (e) => {\n\t\tif (pointerTypes) return pointerTypes.includes(e.pointerType);\n\t\treturn true;\n\t};\n\tconst handleEvent = (e) => {\n\t\tif (toValue(preventDefault$1)) e.preventDefault();\n\t\tif (toValue(stopPropagation)) e.stopPropagation();\n\t};\n\tconst scrollConfig = toValue(autoScroll);\n\tconst scrollSettings = typeof scrollConfig === \"object\" ? {\n\t\tspeed: (_toValue2 = toValue(scrollConfig.speed)) !== null && _toValue2 !== void 0 ? _toValue2 : defaultScrollConfig.speed,\n\t\tmargin: (_toValue3 = toValue(scrollConfig.margin)) !== null && _toValue3 !== void 0 ? _toValue3 : defaultScrollConfig.margin,\n\t\tdirection: (_scrollConfig$directi = scrollConfig.direction) !== null && _scrollConfig$directi !== void 0 ? _scrollConfig$directi : defaultScrollConfig.direction\n\t} : defaultScrollConfig;\n\tconst getScrollAxisValues = (value) => typeof value === \"number\" ? [value, value] : [value.x, value.y];\n\tconst handleAutoScroll = (container, targetRect, position$1) => {\n\t\tconst { clientWidth, clientHeight, scrollLeft, scrollTop, scrollWidth, scrollHeight } = container;\n\t\tconst [marginX, marginY] = getScrollAxisValues(scrollSettings.margin);\n\t\tconst [speedX, speedY] = getScrollAxisValues(scrollSettings.speed);\n\t\tlet deltaX = 0;\n\t\tlet deltaY = 0;\n\t\tif (scrollSettings.direction === \"x\" || scrollSettings.direction === \"both\") {\n\t\t\tif (position$1.x < marginX && scrollLeft > 0) deltaX = -speedX;\n\t\t\telse if (position$1.x + targetRect.width > clientWidth - marginX && scrollLeft < scrollWidth - clientWidth) deltaX = speedX;\n\t\t}\n\t\tif (scrollSettings.direction === \"y\" || scrollSettings.direction === \"both\") {\n\t\t\tif (position$1.y < marginY && scrollTop > 0) deltaY = -speedY;\n\t\t\telse if (position$1.y + targetRect.height > clientHeight - marginY && scrollTop < scrollHeight - clientHeight) deltaY = speedY;\n\t\t}\n\t\tif (deltaX || deltaY) container.scrollBy({\n\t\t\tleft: deltaX,\n\t\t\ttop: deltaY,\n\t\t\tbehavior: \"auto\"\n\t\t});\n\t};\n\tlet autoScrollInterval = null;\n\tconst startAutoScroll = () => {\n\t\tconst container = toValue(containerElement);\n\t\tif (container && !autoScrollInterval) autoScrollInterval = setInterval(() => {\n\t\t\tconst targetRect = toValue(target).getBoundingClientRect();\n\t\t\tconst { x, y } = position.value;\n\t\t\tconst relativePosition = {\n\t\t\t\tx: x - container.scrollLeft,\n\t\t\t\ty: y - container.scrollTop\n\t\t\t};\n\t\t\tif (relativePosition.x >= 0 && relativePosition.y >= 0) {\n\t\t\t\thandleAutoScroll(container, targetRect, relativePosition);\n\t\t\t\trelativePosition.x += container.scrollLeft;\n\t\t\t\trelativePosition.y += container.scrollTop;\n\t\t\t\tposition.value = relativePosition;\n\t\t\t}\n\t\t}, 1e3 / 60);\n\t};\n\tconst stopAutoScroll = () => {\n\t\tif (autoScrollInterval) {\n\t\t\tclearInterval(autoScrollInterval);\n\t\t\tautoScrollInterval = null;\n\t\t}\n\t};\n\tconst isPointerNearEdge = (pointer, container, margin, targetRect) => {\n\t\tconst [marginX, marginY] = typeof margin === \"number\" ? [margin, margin] : [margin.x, margin.y];\n\t\tconst { clientWidth, clientHeight } = container;\n\t\treturn pointer.x < marginX || pointer.x + targetRect.width > clientWidth - marginX || pointer.y < marginY || pointer.y + targetRect.height > clientHeight - marginY;\n\t};\n\tconst checkAutoScroll = () => {\n\t\tif (toValue(options.disabled) || !pressedDelta.value) return;\n\t\tconst container = toValue(containerElement);\n\t\tif (!container) return;\n\t\tconst targetRect = toValue(target).getBoundingClientRect();\n\t\tconst { x, y } = position.value;\n\t\tif (isPointerNearEdge({\n\t\t\tx: x - container.scrollLeft,\n\t\t\ty: y - container.scrollTop\n\t\t}, container, scrollSettings.margin, targetRect)) startAutoScroll();\n\t\telse stopAutoScroll();\n\t};\n\tif (toValue(autoScroll)) watch(position, checkAutoScroll);\n\tconst start = (e) => {\n\t\tvar _container$getBoundin;\n\t\tif (!toValue(buttons).includes(e.button)) return;\n\t\tif (toValue(options.disabled) || !filterEvent(e)) return;\n\t\tif (toValue(exact) && e.target !== toValue(target)) return;\n\t\tconst container = toValue(containerElement);\n\t\tconst containerRect = container === null || container === void 0 || (_container$getBoundin = container.getBoundingClientRect) === null || _container$getBoundin === void 0 ? void 0 : _container$getBoundin.call(container);\n\t\tconst targetRect = toValue(target).getBoundingClientRect();\n\t\tconst pos = {\n\t\t\tx: e.clientX - (container ? targetRect.left - containerRect.left + (autoScroll ? 0 : container.scrollLeft) : targetRect.left),\n\t\t\ty: e.clientY - (container ? targetRect.top - containerRect.top + (autoScroll ? 0 : container.scrollTop) : targetRect.top)\n\t\t};\n\t\tif ((onStart === null || onStart === void 0 ? void 0 : onStart(pos, e)) === false) return;\n\t\tpressedDelta.value = pos;\n\t\thandleEvent(e);\n\t};\n\tconst move = (e) => {\n\t\tif (toValue(options.disabled) || !filterEvent(e)) return;\n\t\tif (!pressedDelta.value) return;\n\t\tconst container = toValue(containerElement);\n\t\tif (container instanceof HTMLElement) clampContainerScroll(container);\n\t\tconst targetRect = toValue(target).getBoundingClientRect();\n\t\tlet { x, y } = position.value;\n\t\tif (axis === \"x\" || axis === \"both\") {\n\t\t\tx = e.clientX - pressedDelta.value.x;\n\t\t\tif (container) x = Math.min(Math.max(0, x), container.scrollWidth - targetRect.width);\n\t\t}\n\t\tif (axis === \"y\" || axis === \"both\") {\n\t\t\ty = e.clientY - pressedDelta.value.y;\n\t\t\tif (container) y = Math.min(Math.max(0, y), container.scrollHeight - targetRect.height);\n\t\t}\n\t\tif (toValue(autoScroll) && container) {\n\t\t\tif (autoScrollInterval === null) handleAutoScroll(container, targetRect, {\n\t\t\t\tx,\n\t\t\t\ty\n\t\t\t});\n\t\t\tx += container.scrollLeft;\n\t\t\ty += container.scrollTop;\n\t\t}\n\t\tif (container && (restrictInView || autoScroll)) {\n\t\t\tif (axis !== \"y\") {\n\t\t\t\tconst relativeX = x - container.scrollLeft;\n\t\t\t\tif (relativeX < 0) x = container.scrollLeft;\n\t\t\t\telse if (relativeX > container.clientWidth - targetRect.width) x = container.clientWidth - targetRect.width + container.scrollLeft;\n\t\t\t}\n\t\t\tif (axis !== \"x\") {\n\t\t\t\tconst relativeY = y - container.scrollTop;\n\t\t\t\tif (relativeY < 0) y = container.scrollTop;\n\t\t\t\telse if (relativeY > container.clientHeight - targetRect.height) y = container.clientHeight - targetRect.height + container.scrollTop;\n\t\t\t}\n\t\t}\n\t\tposition.value = {\n\t\t\tx,\n\t\t\ty\n\t\t};\n\t\tonMove === null || onMove === void 0 || onMove(position.value, e);\n\t\thandleEvent(e);\n\t};\n\tconst end = (e) => {\n\t\tif (toValue(options.disabled) || !filterEvent(e)) return;\n\t\tif (!pressedDelta.value) return;\n\t\tpressedDelta.value = void 0;\n\t\tif (autoScroll) stopAutoScroll();\n\t\tonEnd === null || onEnd === void 0 || onEnd(position.value, e);\n\t\thandleEvent(e);\n\t};\n\tif (isClient) {\n\t\tconst config = () => {\n\t\t\tvar _options$capture;\n\t\t\treturn {\n\t\t\t\tcapture: (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : true,\n\t\t\t\tpassive: !toValue(preventDefault$1)\n\t\t\t};\n\t\t};\n\t\tuseEventListener(draggingHandle, \"pointerdown\", start, config);\n\t\tuseEventListener(draggingElement, \"pointermove\", move, config);\n\t\tuseEventListener(draggingElement, \"pointerup\", end, config);\n\t}\n\treturn {\n\t\t...toRefs(position),\n\t\tposition,\n\t\tisDragging: computed(() => !!pressedDelta.value),\n\t\tstyle: computed(() => `\n      left: ${position.value.x}px;\n      top: ${position.value.y}px;\n      ${autoScroll ? \"text-wrap: nowrap;\" : \"\"}\n    `)\n\t};\n}\n\n//#endregion\n//#region useDropZone/index.ts\nfunction useDropZone(target, options = {}) {\n\tconst isOverDropZone = shallowRef(false);\n\tconst files = shallowRef(null);\n\tlet counter = 0;\n\tlet isValid = true;\n\tif (isClient) {\n\t\tvar _options$multiple, _options$preventDefau;\n\t\tconst _options = typeof options === \"function\" ? { onDrop: options } : options;\n\t\tconst multiple = (_options$multiple = _options.multiple) !== null && _options$multiple !== void 0 ? _options$multiple : true;\n\t\tconst preventDefaultForUnhandled = (_options$preventDefau = _options.preventDefaultForUnhandled) !== null && _options$preventDefau !== void 0 ? _options$preventDefau : false;\n\t\tconst getFiles = (event) => {\n\t\t\tvar _event$dataTransfer$f, _event$dataTransfer;\n\t\t\tconst list = Array.from((_event$dataTransfer$f = (_event$dataTransfer = event.dataTransfer) === null || _event$dataTransfer === void 0 ? void 0 : _event$dataTransfer.files) !== null && _event$dataTransfer$f !== void 0 ? _event$dataTransfer$f : []);\n\t\t\treturn list.length === 0 ? null : multiple ? list : [list[0]];\n\t\t};\n\t\tconst checkDataTypes = (types) => {\n\t\t\tconst dataTypes = unref(_options.dataTypes);\n\t\t\tif (typeof dataTypes === \"function\") return dataTypes(types);\n\t\t\tif (!(dataTypes === null || dataTypes === void 0 ? void 0 : dataTypes.length)) return true;\n\t\t\tif (types.length === 0) return false;\n\t\t\treturn types.every((type) => dataTypes.some((allowedType) => type.includes(allowedType)));\n\t\t};\n\t\tconst checkValidity = (items) => {\n\t\t\tif (_options.checkValidity) return _options.checkValidity(items);\n\t\t\tconst dataTypesValid = checkDataTypes(Array.from(items !== null && items !== void 0 ? items : []).map((item) => item.type));\n\t\t\tconst multipleFilesValid = multiple || items.length <= 1;\n\t\t\treturn dataTypesValid && multipleFilesValid;\n\t\t};\n\t\tconst isSafari = () => /^(?:(?!chrome|android).)*safari/i.test(navigator.userAgent) && !(\"chrome\" in window);\n\t\tconst handleDragEvent = (event, eventType) => {\n\t\t\tvar _event$dataTransfer2, _ref;\n\t\t\tconst dataTransferItemList = (_event$dataTransfer2 = event.dataTransfer) === null || _event$dataTransfer2 === void 0 ? void 0 : _event$dataTransfer2.items;\n\t\t\tisValid = (_ref = dataTransferItemList && checkValidity(dataTransferItemList)) !== null && _ref !== void 0 ? _ref : false;\n\t\t\tif (preventDefaultForUnhandled) event.preventDefault();\n\t\t\tif (!isSafari() && !isValid) {\n\t\t\t\tif (event.dataTransfer) event.dataTransfer.dropEffect = \"none\";\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tevent.preventDefault();\n\t\t\tif (event.dataTransfer) event.dataTransfer.dropEffect = \"copy\";\n\t\t\tconst currentFiles = getFiles(event);\n\t\t\tswitch (eventType) {\n\t\t\t\tcase \"enter\":\n\t\t\t\t\tvar _options$onEnter;\n\t\t\t\t\tcounter += 1;\n\t\t\t\t\tisOverDropZone.value = true;\n\t\t\t\t\t(_options$onEnter = _options.onEnter) === null || _options$onEnter === void 0 || _options$onEnter.call(_options, null, event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"over\":\n\t\t\t\t\tvar _options$onOver;\n\t\t\t\t\t(_options$onOver = _options.onOver) === null || _options$onOver === void 0 || _options$onOver.call(_options, null, event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"leave\":\n\t\t\t\t\tvar _options$onLeave;\n\t\t\t\t\tcounter -= 1;\n\t\t\t\t\tif (counter === 0) isOverDropZone.value = false;\n\t\t\t\t\t(_options$onLeave = _options.onLeave) === null || _options$onLeave === void 0 || _options$onLeave.call(_options, null, event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"drop\":\n\t\t\t\t\tcounter = 0;\n\t\t\t\t\tisOverDropZone.value = false;\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tvar _options$onDrop;\n\t\t\t\t\t\tfiles.value = currentFiles;\n\t\t\t\t\t\t(_options$onDrop = _options.onDrop) === null || _options$onDrop === void 0 || _options$onDrop.call(_options, currentFiles, event);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t\tuseEventListener(target, \"dragenter\", (event) => handleDragEvent(event, \"enter\"));\n\t\tuseEventListener(target, \"dragover\", (event) => handleDragEvent(event, \"over\"));\n\t\tuseEventListener(target, \"dragleave\", (event) => handleDragEvent(event, \"leave\"));\n\t\tuseEventListener(target, \"drop\", (event) => handleDragEvent(event, \"drop\"));\n\t}\n\treturn {\n\t\tfiles,\n\t\tisOverDropZone\n\t};\n}\n\n//#endregion\n//#region useResizeObserver/index.ts\n/**\n* Reports changes to the dimensions of an Element's content or the border-box\n*\n* @see https://vueuse.org/useResizeObserver\n* @param target\n* @param callback\n* @param options\n*/\nfunction useResizeObserver(target, callback, options = {}) {\n\tconst { window: window$1 = defaultWindow,...observerOptions } = options;\n\tlet observer;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => window$1 && \"ResizeObserver\" in window$1);\n\tconst cleanup = () => {\n\t\tif (observer) {\n\t\t\tobserver.disconnect();\n\t\t\tobserver = void 0;\n\t\t}\n\t};\n\tconst stopWatch = watch(computed(() => {\n\t\tconst _targets = toValue(target);\n\t\treturn Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];\n\t}), (els) => {\n\t\tcleanup();\n\t\tif (isSupported.value && window$1) {\n\t\t\tobserver = new ResizeObserver(callback);\n\t\t\tfor (const _el of els) if (_el) observer.observe(_el, observerOptions);\n\t\t}\n\t}, {\n\t\timmediate: true,\n\t\tflush: \"post\"\n\t});\n\tconst stop = () => {\n\t\tcleanup();\n\t\tstopWatch();\n\t};\n\ttryOnScopeDispose(stop);\n\treturn {\n\t\tisSupported,\n\t\tstop\n\t};\n}\n\n//#endregion\n//#region useElementBounding/index.ts\n/**\n* Reactive bounding box of an HTML element.\n*\n* @see https://vueuse.org/useElementBounding\n* @param target\n*/\nfunction useElementBounding(target, options = {}) {\n\tconst { reset = true, windowResize = true, windowScroll = true, immediate = true, updateTiming = \"sync\" } = options;\n\tconst height = shallowRef(0);\n\tconst bottom = shallowRef(0);\n\tconst left = shallowRef(0);\n\tconst right = shallowRef(0);\n\tconst top = shallowRef(0);\n\tconst width = shallowRef(0);\n\tconst x = shallowRef(0);\n\tconst y = shallowRef(0);\n\tfunction recalculate() {\n\t\tconst el = unrefElement(target);\n\t\tif (!el) {\n\t\t\tif (reset) {\n\t\t\t\theight.value = 0;\n\t\t\t\tbottom.value = 0;\n\t\t\t\tleft.value = 0;\n\t\t\t\tright.value = 0;\n\t\t\t\ttop.value = 0;\n\t\t\t\twidth.value = 0;\n\t\t\t\tx.value = 0;\n\t\t\t\ty.value = 0;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tconst rect = el.getBoundingClientRect();\n\t\theight.value = rect.height;\n\t\tbottom.value = rect.bottom;\n\t\tleft.value = rect.left;\n\t\tright.value = rect.right;\n\t\ttop.value = rect.top;\n\t\twidth.value = rect.width;\n\t\tx.value = rect.x;\n\t\ty.value = rect.y;\n\t}\n\tfunction update() {\n\t\tif (updateTiming === \"sync\") recalculate();\n\t\telse if (updateTiming === \"next-frame\") requestAnimationFrame(() => recalculate());\n\t}\n\tuseResizeObserver(target, update);\n\twatch(() => unrefElement(target), (ele) => !ele && update());\n\tuseMutationObserver(target, update, { attributeFilter: [\"style\", \"class\"] });\n\tif (windowScroll) useEventListener(\"scroll\", update, {\n\t\tcapture: true,\n\t\tpassive: true\n\t});\n\tif (windowResize) useEventListener(\"resize\", update, { passive: true });\n\ttryOnMounted(() => {\n\t\tif (immediate) update();\n\t});\n\treturn {\n\t\theight,\n\t\tbottom,\n\t\tleft,\n\t\tright,\n\t\ttop,\n\t\twidth,\n\t\tx,\n\t\ty,\n\t\tupdate\n\t};\n}\n\n//#endregion\n//#region useElementByPoint/index.ts\nfunction getDefaultScheduler$7(options) {\n\tif (\"interval\" in options || \"immediate\" in options) {\n\t\tconst { interval = \"requestAnimationFrame\", immediate = true } = options;\n\t\treturn interval === \"requestAnimationFrame\" ? (cb) => useRafFn(cb, { immediate }) : (cb) => useIntervalFn(cb, interval, { immediate });\n\t}\n\treturn useRafFn;\n}\n/**\n* Reactive element by point.\n*\n* @see https://vueuse.org/useElementByPoint\n* @param options - UseElementByPointOptions\n*/\nfunction useElementByPoint(options) {\n\tconst { x, y, document: document$1 = defaultDocument, multiple, scheduler = getDefaultScheduler$7(options) } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => {\n\t\tif (toValue(multiple)) return document$1 && \"elementsFromPoint\" in document$1;\n\t\treturn document$1 && \"elementFromPoint\" in document$1;\n\t});\n\tconst element = shallowRef(null);\n\treturn {\n\t\tisSupported,\n\t\telement,\n\t\t...scheduler(() => {\n\t\t\tvar _document$elementsFro, _document$elementFrom;\n\t\t\telement.value = toValue(multiple) ? (_document$elementsFro = document$1 === null || document$1 === void 0 ? void 0 : document$1.elementsFromPoint(toValue(x), toValue(y))) !== null && _document$elementsFro !== void 0 ? _document$elementsFro : [] : (_document$elementFrom = document$1 === null || document$1 === void 0 ? void 0 : document$1.elementFromPoint(toValue(x), toValue(y))) !== null && _document$elementFrom !== void 0 ? _document$elementFrom : null;\n\t\t})\n\t};\n}\n\n//#endregion\n//#region useElementHover/index.ts\nfunction useElementHover(el, options = {}) {\n\tconst { delayEnter = 0, delayLeave = 0, triggerOnRemoval = false, window: window$1 = defaultWindow } = options;\n\tconst isHovered = shallowRef(false);\n\tlet timer;\n\tconst toggle = (entering) => {\n\t\tconst delay = entering ? delayEnter : delayLeave;\n\t\tif (timer) {\n\t\t\tclearTimeout(timer);\n\t\t\ttimer = void 0;\n\t\t}\n\t\tif (delay) timer = setTimeout(() => isHovered.value = entering, delay);\n\t\telse isHovered.value = entering;\n\t};\n\tif (!window$1) return isHovered;\n\tuseEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\n\tuseEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\n\tif (triggerOnRemoval) onElementRemoval(computed(() => unrefElement(el)), () => toggle(false));\n\treturn isHovered;\n}\n\n//#endregion\n//#region useElementSize/index.ts\n/**\n* Reactive size of an HTML element.\n*\n* @see https://vueuse.org/useElementSize\n*/\nfunction useElementSize(target, initialSize = {\n\twidth: 0,\n\theight: 0\n}, options = {}) {\n\tconst { window: window$1 = defaultWindow, box = \"content-box\" } = options;\n\tconst isSVG = computed(() => {\n\t\tvar _unrefElement;\n\t\treturn (_unrefElement = unrefElement(target)) === null || _unrefElement === void 0 || (_unrefElement = _unrefElement.namespaceURI) === null || _unrefElement === void 0 ? void 0 : _unrefElement.includes(\"svg\");\n\t});\n\tconst width = shallowRef(initialSize.width);\n\tconst height = shallowRef(initialSize.height);\n\tconst { stop: stop1 } = useResizeObserver(target, ([entry]) => {\n\t\tconst boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n\t\tif (window$1 && isSVG.value) {\n\t\t\tconst $elem = unrefElement(target);\n\t\t\tif ($elem) {\n\t\t\t\tconst rect = $elem.getBoundingClientRect();\n\t\t\t\twidth.value = rect.width;\n\t\t\t\theight.value = rect.height;\n\t\t\t}\n\t\t} else if (boxSize) {\n\t\t\tconst formatBoxSize = toArray(boxSize);\n\t\t\twidth.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n\t\t\theight.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n\t\t} else {\n\t\t\twidth.value = entry.contentRect.width;\n\t\t\theight.value = entry.contentRect.height;\n\t\t}\n\t}, options);\n\ttryOnMounted(() => {\n\t\tconst ele = unrefElement(target);\n\t\tif (ele) {\n\t\t\twidth.value = \"offsetWidth\" in ele ? ele.offsetWidth : initialSize.width;\n\t\t\theight.value = \"offsetHeight\" in ele ? ele.offsetHeight : initialSize.height;\n\t\t}\n\t});\n\tconst stop2 = watch(() => unrefElement(target), (ele) => {\n\t\twidth.value = ele ? initialSize.width : 0;\n\t\theight.value = ele ? initialSize.height : 0;\n\t});\n\tfunction stop() {\n\t\tstop1();\n\t\tstop2();\n\t}\n\treturn {\n\t\twidth,\n\t\theight,\n\t\tstop\n\t};\n}\n\n//#endregion\n//#region useIntersectionObserver/index.ts\n/**\n* Detects that a target element's visibility.\n*\n* @see https://vueuse.org/useIntersectionObserver\n* @param target\n* @param callback\n* @param options\n*/\nfunction useIntersectionObserver(target, callback, options = {}) {\n\tconst { root, rootMargin, threshold = 0, window: window$1 = defaultWindow, immediate = true } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => window$1 && \"IntersectionObserver\" in window$1);\n\tconst targets = computed(() => {\n\t\treturn toArray(toValue(target)).map(unrefElement).filter(notNullish);\n\t});\n\tlet cleanup = noop;\n\tconst isActive = shallowRef(immediate);\n\tconst stopWatch = isSupported.value ? watch(() => [\n\t\ttargets.value,\n\t\tunrefElement(root),\n\t\ttoValue(rootMargin),\n\t\tisActive.value\n\t], ([targets$1, root$1, rootMargin$1]) => {\n\t\tcleanup();\n\t\tif (!isActive.value) return;\n\t\tif (!targets$1.length) return;\n\t\tconst observer = new IntersectionObserver(callback, {\n\t\t\troot: unrefElement(root$1),\n\t\t\trootMargin: rootMargin$1,\n\t\t\tthreshold\n\t\t});\n\t\ttargets$1.forEach((el) => el && observer.observe(el));\n\t\tcleanup = () => {\n\t\t\tobserver.disconnect();\n\t\t\tcleanup = noop;\n\t\t};\n\t}, {\n\t\timmediate,\n\t\tflush: \"post\"\n\t}) : noop;\n\tconst stop = () => {\n\t\tcleanup();\n\t\tstopWatch();\n\t\tisActive.value = false;\n\t};\n\ttryOnScopeDispose(stop);\n\treturn {\n\t\tisSupported,\n\t\tisActive,\n\t\tpause() {\n\t\t\tcleanup();\n\t\t\tisActive.value = false;\n\t\t},\n\t\tresume() {\n\t\t\tisActive.value = true;\n\t\t},\n\t\tstop\n\t};\n}\n\n//#endregion\n//#region useElementVisibility/index.ts\n/**\n* Tracks the visibility of an element within the viewport.\n*\n* @see https://vueuse.org/useElementVisibility\n*/\nfunction useElementVisibility(element, options = {}) {\n\tconst { window: window$1 = defaultWindow, scrollTarget, threshold = 0, rootMargin, once = false, initialValue = false } = options;\n\tconst elementIsVisible = shallowRef(initialValue);\n\tconst { stop } = useIntersectionObserver(element, (intersectionObserverEntries) => {\n\t\tlet isIntersecting = elementIsVisible.value;\n\t\tlet latestTime = 0;\n\t\tfor (const entry of intersectionObserverEntries) if (entry.time >= latestTime) {\n\t\t\tlatestTime = entry.time;\n\t\t\tisIntersecting = entry.isIntersecting;\n\t\t}\n\t\telementIsVisible.value = isIntersecting;\n\t\tif (once) watchOnce(elementIsVisible, () => {\n\t\t\tstop();\n\t\t});\n\t}, {\n\t\troot: scrollTarget,\n\t\twindow: window$1,\n\t\tthreshold,\n\t\trootMargin\n\t});\n\treturn elementIsVisible;\n}\n\n//#endregion\n//#region useEventBus/internal.ts\nconst events = /* @__PURE__ */ new Map();\n\n//#endregion\n//#region useEventBus/index.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction useEventBus(key) {\n\tconst scope = getCurrentScope();\n\tfunction on(listener) {\n\t\tvar _scope$cleanups;\n\t\tconst listeners = events.get(key) || /* @__PURE__ */ new Set();\n\t\tlisteners.add(listener);\n\t\tevents.set(key, listeners);\n\t\tconst _off = () => off(listener);\n\t\tscope === null || scope === void 0 || (_scope$cleanups = scope.cleanups) === null || _scope$cleanups === void 0 || _scope$cleanups.push(_off);\n\t\treturn _off;\n\t}\n\tfunction once(listener) {\n\t\tfunction _listener(...args) {\n\t\t\toff(_listener);\n\t\t\tlistener(...args);\n\t\t}\n\t\treturn on(_listener);\n\t}\n\tfunction off(listener) {\n\t\tconst listeners = events.get(key);\n\t\tif (!listeners) return;\n\t\tlisteners.delete(listener);\n\t\tif (!listeners.size) reset();\n\t}\n\tfunction reset() {\n\t\tevents.delete(key);\n\t}\n\tfunction emit(event, payload) {\n\t\tvar _events$get;\n\t\t(_events$get = events.get(key)) === null || _events$get === void 0 || _events$get.forEach((v) => v(event, payload));\n\t}\n\treturn {\n\t\ton,\n\t\tonce,\n\t\toff,\n\t\temit,\n\t\treset\n\t};\n}\n\n//#endregion\n//#region useEventSource/index.ts\nfunction resolveNestedOptions$1(options) {\n\tif (options === true) return {};\n\treturn options;\n}\n/**\n* Reactive wrapper for EventSource.\n*\n* @see https://vueuse.org/useEventSource\n* @see https://developer.mozilla.org/en-US/docs/Web/API/EventSource/EventSource EventSource\n* @param url\n* @param events\n* @param options\n*/\nfunction useEventSource(url, events$1 = [], options = {}) {\n\tconst event = shallowRef(null);\n\tconst data = shallowRef(null);\n\tconst status = shallowRef(\"CONNECTING\");\n\tconst eventSource = ref(null);\n\tconst error = shallowRef(null);\n\tconst urlRef = toRef(url);\n\tconst lastEventId = shallowRef(null);\n\tlet explicitlyClosed = false;\n\tlet retried = 0;\n\tconst { withCredentials = false, immediate = true, autoConnect = true, autoReconnect, serializer = { read: (v) => v } } = options;\n\tconst close = () => {\n\t\tif (isClient && eventSource.value) {\n\t\t\teventSource.value.close();\n\t\t\teventSource.value = null;\n\t\t\tstatus.value = \"CLOSED\";\n\t\t\texplicitlyClosed = true;\n\t\t}\n\t};\n\tconst _init = () => {\n\t\tif (explicitlyClosed || typeof urlRef.value === \"undefined\") return;\n\t\tconst es = new EventSource(urlRef.value, { withCredentials });\n\t\tstatus.value = \"CONNECTING\";\n\t\teventSource.value = es;\n\t\tes.onopen = () => {\n\t\t\tstatus.value = \"OPEN\";\n\t\t\terror.value = null;\n\t\t};\n\t\tes.onerror = (e) => {\n\t\t\tstatus.value = \"CLOSED\";\n\t\t\terror.value = e;\n\t\t\tif (es.readyState === 2 && !explicitlyClosed && autoReconnect) {\n\t\t\t\tes.close();\n\t\t\t\tconst { retries = -1, delay = 1e3, onFailed } = resolveNestedOptions$1(autoReconnect);\n\t\t\t\tretried += 1;\n\t\t\t\tif (typeof retries === \"number\" && (retries < 0 || retried < retries)) setTimeout(_init, delay);\n\t\t\t\telse if (typeof retries === \"function\" && retries()) setTimeout(_init, delay);\n\t\t\t\telse onFailed === null || onFailed === void 0 || onFailed();\n\t\t\t}\n\t\t};\n\t\tes.onmessage = (e) => {\n\t\t\tvar _serializer$read;\n\t\t\tevent.value = null;\n\t\t\tdata.value = (_serializer$read = serializer.read(e.data)) !== null && _serializer$read !== void 0 ? _serializer$read : null;\n\t\t\tlastEventId.value = e.lastEventId;\n\t\t};\n\t\tfor (const event_name of events$1) useEventListener(es, event_name, (e) => {\n\t\t\tvar _serializer$read2, _e$lastEventId;\n\t\t\tevent.value = event_name;\n\t\t\tdata.value = (_serializer$read2 = serializer.read(e.data)) !== null && _serializer$read2 !== void 0 ? _serializer$read2 : null;\n\t\t\tlastEventId.value = (_e$lastEventId = e.lastEventId) !== null && _e$lastEventId !== void 0 ? _e$lastEventId : null;\n\t\t}, { passive: true });\n\t};\n\tconst open = () => {\n\t\tif (!isClient) return;\n\t\tclose();\n\t\texplicitlyClosed = false;\n\t\tretried = 0;\n\t\t_init();\n\t};\n\tif (immediate) open();\n\tif (autoConnect) watch(urlRef, open);\n\ttryOnScopeDispose(close);\n\treturn {\n\t\teventSource,\n\t\tevent,\n\t\tdata,\n\t\tstatus,\n\t\terror,\n\t\topen,\n\t\tclose,\n\t\tlastEventId\n\t};\n}\n\n//#endregion\n//#region useEyeDropper/index.ts\n/**\n* Reactive [EyeDropper API](https://developer.mozilla.org/en-US/docs/Web/API/EyeDropper_API)\n*\n* @see https://vueuse.org/useEyeDropper\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useEyeDropper(options = {}) {\n\tconst { initialValue = \"\" } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n\tconst sRGBHex = shallowRef(initialValue);\n\tasync function open(openOptions) {\n\t\tif (!isSupported.value) return;\n\t\tconst result = await new window.EyeDropper().open(openOptions);\n\t\tsRGBHex.value = result.sRGBHex;\n\t\treturn result;\n\t}\n\treturn {\n\t\tisSupported,\n\t\tsRGBHex,\n\t\topen\n\t};\n}\n\n//#endregion\n//#region useFavicon/index.ts\nfunction useFavicon(newIcon = null, options = {}) {\n\tconst { baseUrl = \"\", rel = \"icon\", document: document$1 = defaultDocument } = options;\n\tconst favicon = toRef(newIcon);\n\tconst applyIcon = (icon) => {\n\t\tconst elements = document$1 === null || document$1 === void 0 ? void 0 : document$1.head.querySelectorAll(`link[rel*=\"${rel}\"]`);\n\t\tif (!elements || elements.length === 0) {\n\t\t\tconst link = document$1 === null || document$1 === void 0 ? void 0 : document$1.createElement(\"link\");\n\t\t\tif (link) {\n\t\t\t\tlink.rel = rel;\n\t\t\t\tlink.href = `${baseUrl}${icon}`;\n\t\t\t\tlink.type = `image/${icon.split(\".\").pop()}`;\n\t\t\t\tdocument$1 === null || document$1 === void 0 || document$1.head.append(link);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telements === null || elements === void 0 || elements.forEach((el) => el.href = `${baseUrl}${icon}`);\n\t};\n\twatch(favicon, (i, o) => {\n\t\tif (typeof i === \"string\" && i !== o) applyIcon(i);\n\t}, { immediate: true });\n\treturn favicon;\n}\n\n//#endregion\n//#region useFetch/index.ts\nconst payloadMapping = {\n\tjson: \"application/json\",\n\ttext: \"text/plain\"\n};\n/**\n* !!!IMPORTANT!!!\n*\n* If you update the UseFetchOptions interface, be sure to update this object\n* to include the new options\n*/\nfunction isFetchOptions(obj) {\n\treturn obj && containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\", \"updateDataOnError\");\n}\nconst reAbsolute = /^(?:[a-z][a-z\\d+\\-.]*:)?\\/\\//i;\nfunction isAbsoluteURL(url) {\n\treturn reAbsolute.test(url);\n}\nfunction headersToObject(headers) {\n\tif (typeof Headers !== \"undefined\" && headers instanceof Headers) return Object.fromEntries(headers.entries());\n\treturn headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n\tif (combination === \"overwrite\") return async (ctx) => {\n\t\tlet callback;\n\t\tfor (let i = callbacks.length - 1; i >= 0; i--) if (callbacks[i] != null) {\n\t\t\tcallback = callbacks[i];\n\t\t\tbreak;\n\t\t}\n\t\tif (callback) return {\n\t\t\t...ctx,\n\t\t\t...await callback(ctx)\n\t\t};\n\t\treturn ctx;\n\t};\n\telse return async (ctx) => {\n\t\tfor (const callback of callbacks) if (callback) ctx = {\n\t\t\t...ctx,\n\t\t\t...await callback(ctx)\n\t\t};\n\t\treturn ctx;\n\t};\n}\nfunction createFetch(config = {}) {\n\tconst _combination = config.combination || \"chain\";\n\tconst _options = config.options || {};\n\tconst _fetchOptions = config.fetchOptions || {};\n\tfunction useFactoryFetch(url, ...args) {\n\t\tconst computedUrl = computed(() => {\n\t\t\tconst baseUrl = toValue(config.baseUrl);\n\t\t\tconst targetUrl = toValue(url);\n\t\t\treturn baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n\t\t});\n\t\tlet options = _options;\n\t\tlet fetchOptions = _fetchOptions;\n\t\tif (args.length > 0) if (isFetchOptions(args[0])) options = {\n\t\t\t...options,\n\t\t\t...args[0],\n\t\t\tbeforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n\t\t\tafterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n\t\t\tonFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n\t\t};\n\t\telse fetchOptions = {\n\t\t\t...fetchOptions,\n\t\t\t...args[0],\n\t\t\theaders: {\n\t\t\t\t...headersToObject(fetchOptions.headers) || {},\n\t\t\t\t...headersToObject(args[0].headers) || {}\n\t\t\t}\n\t\t};\n\t\tif (args.length > 1 && isFetchOptions(args[1])) options = {\n\t\t\t...options,\n\t\t\t...args[1],\n\t\t\tbeforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n\t\t\tafterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n\t\t\tonFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n\t\t};\n\t\treturn useFetch(computedUrl, fetchOptions, options);\n\t}\n\treturn useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n\tvar _defaultWindow$fetch, _globalThis;\n\tconst supportsAbort = typeof AbortController === \"function\";\n\tlet fetchOptions = {};\n\tlet options = {\n\t\timmediate: true,\n\t\trefetch: false,\n\t\ttimeout: 0,\n\t\tupdateDataOnError: false\n\t};\n\tconst config = {\n\t\tmethod: \"GET\",\n\t\ttype: \"text\",\n\t\tpayload: void 0\n\t};\n\tif (args.length > 0) if (isFetchOptions(args[0])) options = {\n\t\t...options,\n\t\t...args[0]\n\t};\n\telse fetchOptions = args[0];\n\tif (args.length > 1) {\n\t\tif (isFetchOptions(args[1])) options = {\n\t\t\t...options,\n\t\t\t...args[1]\n\t\t};\n\t}\n\tconst { fetch = (_defaultWindow$fetch = defaultWindow === null || defaultWindow === void 0 ? void 0 : defaultWindow.fetch) !== null && _defaultWindow$fetch !== void 0 ? _defaultWindow$fetch : (_globalThis = globalThis) === null || _globalThis === void 0 ? void 0 : _globalThis.fetch, initialData, timeout } = options;\n\tconst responseEvent = createEventHook();\n\tconst errorEvent = createEventHook();\n\tconst finallyEvent = createEventHook();\n\tconst isFinished = shallowRef(false);\n\tconst isFetching = shallowRef(false);\n\tconst aborted = shallowRef(false);\n\tconst statusCode = shallowRef(null);\n\tconst response = shallowRef(null);\n\tconst error = shallowRef(null);\n\tconst data = shallowRef(initialData || null);\n\tconst canAbort = computed(() => supportsAbort && isFetching.value);\n\tlet controller;\n\tlet timer;\n\tconst abort = (reason) => {\n\t\tif (supportsAbort) {\n\t\t\tcontroller === null || controller === void 0 || controller.abort(reason);\n\t\t\tcontroller = new AbortController();\n\t\t\tcontroller.signal.onabort = () => aborted.value = true;\n\t\t\tfetchOptions = {\n\t\t\t\t...fetchOptions,\n\t\t\t\tsignal: controller.signal\n\t\t\t};\n\t\t}\n\t};\n\tconst loading = (isLoading) => {\n\t\tisFetching.value = isLoading;\n\t\tisFinished.value = !isLoading;\n\t};\n\tif (timeout) timer = useTimeoutFn(abort, timeout, { immediate: false });\n\tlet executeCounter = 0;\n\tconst execute = async (throwOnFailed = false) => {\n\t\tvar _context$options;\n\t\tabort();\n\t\tloading(true);\n\t\terror.value = null;\n\t\tstatusCode.value = null;\n\t\taborted.value = false;\n\t\texecuteCounter += 1;\n\t\tconst currentExecuteCounter = executeCounter;\n\t\tconst defaultFetchOptions = {\n\t\t\tmethod: config.method,\n\t\t\theaders: {}\n\t\t};\n\t\tconst payload = toValue(config.payload);\n\t\tif (payload) {\n\t\t\tvar _payloadMapping$confi;\n\t\t\tconst headers = headersToObject(defaultFetchOptions.headers);\n\t\t\tconst proto = Object.getPrototypeOf(payload);\n\t\t\tif (!config.payloadType && payload && (proto === Object.prototype || Array.isArray(proto)) && !(payload instanceof FormData)) config.payloadType = \"json\";\n\t\t\tif (config.payloadType) headers[\"Content-Type\"] = (_payloadMapping$confi = payloadMapping[config.payloadType]) !== null && _payloadMapping$confi !== void 0 ? _payloadMapping$confi : config.payloadType;\n\t\t\tdefaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n\t\t}\n\t\tlet isCanceled = false;\n\t\tconst context = {\n\t\t\turl: toValue(url),\n\t\t\toptions: {\n\t\t\t\t...defaultFetchOptions,\n\t\t\t\t...fetchOptions\n\t\t\t},\n\t\t\tcancel: () => {\n\t\t\t\tisCanceled = true;\n\t\t\t}\n\t\t};\n\t\tif (options.beforeFetch) Object.assign(context, await options.beforeFetch(context));\n\t\tif (isCanceled || !fetch) {\n\t\t\tloading(false);\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\t\tlet responseData = null;\n\t\tif (timer) timer.start();\n\t\treturn fetch(context.url, {\n\t\t\t...defaultFetchOptions,\n\t\t\t...context.options,\n\t\t\theaders: {\n\t\t\t\t...headersToObject(defaultFetchOptions.headers),\n\t\t\t\t...headersToObject((_context$options = context.options) === null || _context$options === void 0 ? void 0 : _context$options.headers)\n\t\t\t}\n\t\t}).then(async (fetchResponse) => {\n\t\t\tresponse.value = fetchResponse;\n\t\t\tstatusCode.value = fetchResponse.status;\n\t\t\tresponseData = await fetchResponse.clone()[config.type]();\n\t\t\tif (!fetchResponse.ok) {\n\t\t\t\tdata.value = initialData || null;\n\t\t\t\tthrow new Error(fetchResponse.statusText);\n\t\t\t}\n\t\t\tif (options.afterFetch) ({data: responseData} = await options.afterFetch({\n\t\t\t\tdata: responseData,\n\t\t\t\tresponse: fetchResponse,\n\t\t\t\tcontext,\n\t\t\t\texecute\n\t\t\t}));\n\t\t\tdata.value = responseData;\n\t\t\tresponseEvent.trigger(fetchResponse);\n\t\t\treturn fetchResponse;\n\t\t}).catch(async (fetchError) => {\n\t\t\tlet errorData = fetchError.message || fetchError.name;\n\t\t\tif (options.onFetchError) ({error: errorData, data: responseData} = await options.onFetchError({\n\t\t\t\tdata: responseData,\n\t\t\t\terror: fetchError,\n\t\t\t\tresponse: response.value,\n\t\t\t\tcontext,\n\t\t\t\texecute\n\t\t\t}));\n\t\t\terror.value = errorData;\n\t\t\tif (options.updateDataOnError) data.value = responseData;\n\t\t\terrorEvent.trigger(fetchError);\n\t\t\tif (throwOnFailed) throw fetchError;\n\t\t\treturn null;\n\t\t}).finally(() => {\n\t\t\tif (currentExecuteCounter === executeCounter) loading(false);\n\t\t\tif (timer) timer.stop();\n\t\t\tfinallyEvent.trigger(null);\n\t\t});\n\t};\n\tconst refetch = toRef(options.refetch);\n\twatch([refetch, toRef(url)], ([refetch$1]) => refetch$1 && execute(), { deep: true });\n\tconst shell = {\n\t\tisFinished: readonly(isFinished),\n\t\tisFetching: readonly(isFetching),\n\t\tstatusCode,\n\t\tresponse,\n\t\terror,\n\t\tdata,\n\t\tcanAbort,\n\t\taborted,\n\t\tabort,\n\t\texecute,\n\t\tonFetchResponse: responseEvent.on,\n\t\tonFetchError: errorEvent.on,\n\t\tonFetchFinally: finallyEvent.on,\n\t\tget: setMethod(\"GET\"),\n\t\tput: setMethod(\"PUT\"),\n\t\tpost: setMethod(\"POST\"),\n\t\tdelete: setMethod(\"DELETE\"),\n\t\tpatch: setMethod(\"PATCH\"),\n\t\thead: setMethod(\"HEAD\"),\n\t\toptions: setMethod(\"OPTIONS\"),\n\t\tjson: setType(\"json\"),\n\t\ttext: setType(\"text\"),\n\t\tblob: setType(\"blob\"),\n\t\tarrayBuffer: setType(\"arrayBuffer\"),\n\t\tformData: setType(\"formData\")\n\t};\n\tfunction setMethod(method) {\n\t\treturn (payload, payloadType) => {\n\t\t\tif (!isFetching.value) {\n\t\t\t\tconfig.method = method;\n\t\t\t\tconfig.payload = payload;\n\t\t\t\tconfig.payloadType = payloadType;\n\t\t\t\tif (isRef(config.payload)) watch([refetch, toRef(config.payload)], ([refetch$1]) => refetch$1 && execute(), { deep: true });\n\t\t\t\treturn {\n\t\t\t\t\t...shell,\n\t\t\t\t\tthen(onFulfilled, onRejected) {\n\t\t\t\t\t\treturn waitUntilFinished().then(onFulfilled, onRejected);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}\n\tfunction waitUntilFinished() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tuntil(isFinished).toBe(true).then(() => resolve(shell)).catch(reject);\n\t\t});\n\t}\n\tfunction setType(type) {\n\t\treturn () => {\n\t\t\tif (!isFetching.value) {\n\t\t\t\tconfig.type = type;\n\t\t\t\treturn {\n\t\t\t\t\t...shell,\n\t\t\t\t\tthen(onFulfilled, onRejected) {\n\t\t\t\t\t\treturn waitUntilFinished().then(onFulfilled, onRejected);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t}\n\tif (options.immediate) Promise.resolve().then(() => execute());\n\treturn {\n\t\t...shell,\n\t\tthen(onFulfilled, onRejected) {\n\t\t\treturn waitUntilFinished().then(onFulfilled, onRejected);\n\t\t}\n\t};\n}\nfunction joinPaths(start, end) {\n\tif (!start.endsWith(\"/\") && !end.startsWith(\"/\")) return `${start}/${end}`;\n\tif (start.endsWith(\"/\") && end.startsWith(\"/\")) return `${start.slice(0, -1)}${end}`;\n\treturn `${start}${end}`;\n}\n\n//#endregion\n//#region useFileDialog/index.ts\nconst DEFAULT_OPTIONS = {\n\tmultiple: true,\n\taccept: \"*\",\n\treset: false,\n\tdirectory: false\n};\nfunction prepareInitialFiles(files) {\n\tif (!files) return null;\n\tif (files instanceof FileList) return files;\n\tconst dt = new DataTransfer();\n\tfor (const file of files) dt.items.add(file);\n\treturn dt.files;\n}\n/**\n* Open file dialog with ease.\n*\n* @see https://vueuse.org/useFileDialog\n* @param options\n*/\nfunction useFileDialog(options = {}) {\n\tconst { document: document$1 = defaultDocument } = options;\n\tconst files = ref(prepareInitialFiles(options.initialFiles));\n\tconst { on: onChange, trigger: changeTrigger } = createEventHook();\n\tconst { on: onCancel, trigger: cancelTrigger } = createEventHook();\n\tconst inputRef = computed(() => {\n\t\tvar _unrefElement;\n\t\tconst input = (_unrefElement = unrefElement(options.input)) !== null && _unrefElement !== void 0 ? _unrefElement : document$1 ? document$1.createElement(\"input\") : void 0;\n\t\tif (input) {\n\t\t\tinput.type = \"file\";\n\t\t\tinput.onchange = (event) => {\n\t\t\t\tfiles.value = event.target.files;\n\t\t\t\tchangeTrigger(files.value);\n\t\t\t};\n\t\t\tinput.oncancel = () => {\n\t\t\t\tcancelTrigger();\n\t\t\t};\n\t\t}\n\t\treturn input;\n\t});\n\tconst reset = () => {\n\t\tfiles.value = null;\n\t\tif (inputRef.value && inputRef.value.value) {\n\t\t\tinputRef.value.value = \"\";\n\t\t\tchangeTrigger(null);\n\t\t}\n\t};\n\tconst applyOptions = (options$1) => {\n\t\tconst el = inputRef.value;\n\t\tif (!el) return;\n\t\tel.multiple = toValue(options$1.multiple);\n\t\tel.accept = toValue(options$1.accept);\n\t\tel.webkitdirectory = toValue(options$1.directory);\n\t\tif (hasOwn(options$1, \"capture\")) el.capture = toValue(options$1.capture);\n\t};\n\tconst open = (localOptions) => {\n\t\tconst el = inputRef.value;\n\t\tif (!el) return;\n\t\tconst mergedOptions = {\n\t\t\t...DEFAULT_OPTIONS,\n\t\t\t...options,\n\t\t\t...localOptions\n\t\t};\n\t\tapplyOptions(mergedOptions);\n\t\tif (toValue(mergedOptions.reset)) reset();\n\t\tel.click();\n\t};\n\twatchEffect(() => {\n\t\tapplyOptions(options);\n\t});\n\treturn {\n\t\tfiles: readonly(files),\n\t\topen,\n\t\treset,\n\t\tonCancel,\n\t\tonChange\n\t};\n}\n\n//#endregion\n//#region useFileSystemAccess/index.ts\nfunction useFileSystemAccess(options = {}) {\n\tconst { window: _window = defaultWindow, dataType = \"Text\" } = options;\n\tconst window$1 = _window;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => window$1 && \"showSaveFilePicker\" in window$1 && \"showOpenFilePicker\" in window$1);\n\tconst fileHandle = shallowRef();\n\tconst data = shallowRef();\n\tconst file = shallowRef();\n\tconst fileName = computed(() => {\n\t\tvar _file$value$name, _file$value;\n\t\treturn (_file$value$name = (_file$value = file.value) === null || _file$value === void 0 ? void 0 : _file$value.name) !== null && _file$value$name !== void 0 ? _file$value$name : \"\";\n\t});\n\tconst fileMIME = computed(() => {\n\t\tvar _file$value$type, _file$value2;\n\t\treturn (_file$value$type = (_file$value2 = file.value) === null || _file$value2 === void 0 ? void 0 : _file$value2.type) !== null && _file$value$type !== void 0 ? _file$value$type : \"\";\n\t});\n\tconst fileSize = computed(() => {\n\t\tvar _file$value$size, _file$value3;\n\t\treturn (_file$value$size = (_file$value3 = file.value) === null || _file$value3 === void 0 ? void 0 : _file$value3.size) !== null && _file$value$size !== void 0 ? _file$value$size : 0;\n\t});\n\tconst fileLastModified = computed(() => {\n\t\tvar _file$value$lastModif, _file$value4;\n\t\treturn (_file$value$lastModif = (_file$value4 = file.value) === null || _file$value4 === void 0 ? void 0 : _file$value4.lastModified) !== null && _file$value$lastModif !== void 0 ? _file$value$lastModif : 0;\n\t});\n\tasync function open(_options = {}) {\n\t\tif (!isSupported.value) return;\n\t\tconst [handle] = await window$1.showOpenFilePicker({\n\t\t\t...toValue(options),\n\t\t\t..._options\n\t\t});\n\t\tfileHandle.value = handle;\n\t\tawait updateData();\n\t}\n\tasync function create(_options = {}) {\n\t\tif (!isSupported.value) return;\n\t\tfileHandle.value = await window$1.showSaveFilePicker({\n\t\t\t...options,\n\t\t\t..._options\n\t\t});\n\t\tdata.value = void 0;\n\t\tawait updateData();\n\t}\n\tasync function save(_options = {}) {\n\t\tif (!isSupported.value) return;\n\t\tif (!fileHandle.value) return saveAs(_options);\n\t\tif (data.value) {\n\t\t\tconst writableStream = await fileHandle.value.createWritable();\n\t\t\tawait writableStream.write(data.value);\n\t\t\tawait writableStream.close();\n\t\t}\n\t\tawait updateFile();\n\t}\n\tasync function saveAs(_options = {}) {\n\t\tif (!isSupported.value) return;\n\t\tfileHandle.value = await window$1.showSaveFilePicker({\n\t\t\t...options,\n\t\t\t..._options\n\t\t});\n\t\tif (data.value) {\n\t\t\tconst writableStream = await fileHandle.value.createWritable();\n\t\t\tawait writableStream.write(data.value);\n\t\t\tawait writableStream.close();\n\t\t}\n\t\tawait updateFile();\n\t}\n\tasync function updateFile() {\n\t\tvar _fileHandle$value;\n\t\tfile.value = await ((_fileHandle$value = fileHandle.value) === null || _fileHandle$value === void 0 ? void 0 : _fileHandle$value.getFile());\n\t}\n\tasync function updateData() {\n\t\tvar _file$value5, _file$value6;\n\t\tawait updateFile();\n\t\tconst type = toValue(dataType);\n\t\tif (type === \"Text\") data.value = await ((_file$value5 = file.value) === null || _file$value5 === void 0 ? void 0 : _file$value5.text());\n\t\telse if (type === \"ArrayBuffer\") data.value = await ((_file$value6 = file.value) === null || _file$value6 === void 0 ? void 0 : _file$value6.arrayBuffer());\n\t\telse if (type === \"Blob\") data.value = file.value;\n\t}\n\twatch(() => toValue(dataType), updateData);\n\treturn {\n\t\tisSupported,\n\t\tdata,\n\t\tfile,\n\t\tfileName,\n\t\tfileMIME,\n\t\tfileSize,\n\t\tfileLastModified,\n\t\topen,\n\t\tcreate,\n\t\tsave,\n\t\tsaveAs,\n\t\tupdateData\n\t};\n}\n\n//#endregion\n//#region useFocus/index.ts\n/**\n* Track or set the focus state of a DOM element.\n*\n* @see https://vueuse.org/useFocus\n* @param target The target element for the focus and blur events.\n* @param options\n*/\nfunction useFocus(target, options = {}) {\n\tconst { initialValue = false, focusVisible = false, preventScroll = false } = options;\n\tconst innerFocused = shallowRef(false);\n\tconst targetElement = computed(() => unrefElement(target));\n\tconst listenerOptions = { passive: true };\n\tuseEventListener(targetElement, \"focus\", (event) => {\n\t\tvar _matches, _ref;\n\t\tif (!focusVisible || ((_matches = (_ref = event.target).matches) === null || _matches === void 0 ? void 0 : _matches.call(_ref, \":focus-visible\"))) innerFocused.value = true;\n\t}, listenerOptions);\n\tuseEventListener(targetElement, \"blur\", () => innerFocused.value = false, listenerOptions);\n\tconst focused = computed({\n\t\tget: () => innerFocused.value,\n\t\tset(value) {\n\t\t\tvar _targetElement$value, _targetElement$value2;\n\t\t\tif (!value && innerFocused.value) (_targetElement$value = targetElement.value) === null || _targetElement$value === void 0 || _targetElement$value.blur();\n\t\t\telse if (value && !innerFocused.value) (_targetElement$value2 = targetElement.value) === null || _targetElement$value2 === void 0 || _targetElement$value2.focus({ preventScroll });\n\t\t}\n\t});\n\twatch(targetElement, () => {\n\t\tfocused.value = initialValue;\n\t}, {\n\t\timmediate: true,\n\t\tflush: \"post\"\n\t});\n\treturn { focused };\n}\n\n//#endregion\n//#region useFocusWithin/index.ts\nconst EVENT_FOCUS_IN = \"focusin\";\nconst EVENT_FOCUS_OUT = \"focusout\";\nconst PSEUDO_CLASS_FOCUS_WITHIN = \":focus-within\";\n/**\n* Track if focus is contained within the target element\n*\n* @see https://vueuse.org/useFocusWithin\n* @param target The target element to track\n* @param options Focus within options\n*/\nfunction useFocusWithin(target, options = {}) {\n\tconst { window: window$1 = defaultWindow } = options;\n\tconst targetElement = computed(() => unrefElement(target));\n\tconst _focused = shallowRef(false);\n\tconst focused = computed(() => _focused.value);\n\tconst activeElement = useActiveElement(options);\n\tif (!window$1 || !activeElement.value) return { focused };\n\tconst listenerOptions = { passive: true };\n\tuseEventListener(targetElement, EVENT_FOCUS_IN, () => _focused.value = true, listenerOptions);\n\tuseEventListener(targetElement, EVENT_FOCUS_OUT, () => {\n\t\tvar _targetElement$value$, _targetElement$value, _targetElement$value$2;\n\t\treturn _focused.value = (_targetElement$value$ = (_targetElement$value = targetElement.value) === null || _targetElement$value === void 0 || (_targetElement$value$2 = _targetElement$value.matches) === null || _targetElement$value$2 === void 0 ? void 0 : _targetElement$value$2.call(_targetElement$value, PSEUDO_CLASS_FOCUS_WITHIN)) !== null && _targetElement$value$ !== void 0 ? _targetElement$value$ : false;\n\t}, listenerOptions);\n\treturn { focused };\n}\n\n//#endregion\n//#region useFps/index.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction useFps(options) {\n\tvar _options$every;\n\tconst fps = shallowRef(0);\n\tif (typeof performance === \"undefined\") return fps;\n\tconst every = (_options$every = options === null || options === void 0 ? void 0 : options.every) !== null && _options$every !== void 0 ? _options$every : 10;\n\tlet last = performance.now();\n\tlet ticks = 0;\n\tuseRafFn(() => {\n\t\tticks += 1;\n\t\tif (ticks >= every) {\n\t\t\tconst now = performance.now();\n\t\t\tconst diff = now - last;\n\t\t\tfps.value = Math.round(1e3 / (diff / ticks));\n\t\t\tlast = now;\n\t\t\tticks = 0;\n\t\t}\n\t});\n\treturn fps;\n}\n\n//#endregion\n//#region useFullscreen/index.ts\nconst eventHandlers = [\n\t\"fullscreenchange\",\n\t\"webkitfullscreenchange\",\n\t\"webkitendfullscreen\",\n\t\"mozfullscreenchange\",\n\t\"MSFullscreenChange\"\n];\n/**\n* Reactive Fullscreen API.\n*\n* @see https://vueuse.org/useFullscreen\n* @param target\n* @param options\n*/\nfunction useFullscreen(target, options = {}) {\n\tconst { document: document$1 = defaultDocument, autoExit = false } = options;\n\tconst targetRef = computed(() => {\n\t\tvar _unrefElement;\n\t\treturn (_unrefElement = unrefElement(target)) !== null && _unrefElement !== void 0 ? _unrefElement : document$1 === null || document$1 === void 0 ? void 0 : document$1.documentElement;\n\t});\n\tconst isFullscreen = shallowRef(false);\n\tconst requestMethod = computed(() => {\n\t\treturn [\n\t\t\t\"requestFullscreen\",\n\t\t\t\"webkitRequestFullscreen\",\n\t\t\t\"webkitEnterFullscreen\",\n\t\t\t\"webkitEnterFullScreen\",\n\t\t\t\"webkitRequestFullScreen\",\n\t\t\t\"mozRequestFullScreen\",\n\t\t\t\"msRequestFullscreen\"\n\t\t].find((m) => document$1 && m in document$1 || targetRef.value && m in targetRef.value);\n\t});\n\tconst exitMethod = computed(() => {\n\t\treturn [\n\t\t\t\"exitFullscreen\",\n\t\t\t\"webkitExitFullscreen\",\n\t\t\t\"webkitExitFullScreen\",\n\t\t\t\"webkitCancelFullScreen\",\n\t\t\t\"mozCancelFullScreen\",\n\t\t\t\"msExitFullscreen\"\n\t\t].find((m) => document$1 && m in document$1 || targetRef.value && m in targetRef.value);\n\t});\n\tconst fullscreenEnabled = computed(() => {\n\t\treturn [\n\t\t\t\"fullScreen\",\n\t\t\t\"webkitIsFullScreen\",\n\t\t\t\"webkitDisplayingFullscreen\",\n\t\t\t\"mozFullScreen\",\n\t\t\t\"msFullscreenElement\"\n\t\t].find((m) => document$1 && m in document$1 || targetRef.value && m in targetRef.value);\n\t});\n\tconst fullscreenElementMethod = [\n\t\t\"fullscreenElement\",\n\t\t\"webkitFullscreenElement\",\n\t\t\"mozFullScreenElement\",\n\t\t\"msFullscreenElement\"\n\t].find((m) => document$1 && m in document$1);\n\tconst isSupported = /* @__PURE__ */ useSupported(() => targetRef.value && document$1 && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);\n\tconst isCurrentElementFullScreen = () => {\n\t\tif (fullscreenElementMethod) return (document$1 === null || document$1 === void 0 ? void 0 : document$1[fullscreenElementMethod]) === targetRef.value;\n\t\treturn false;\n\t};\n\tconst isElementFullScreen = () => {\n\t\tif (fullscreenEnabled.value) if (document$1 && document$1[fullscreenEnabled.value] != null) return document$1[fullscreenEnabled.value];\n\t\telse {\n\t\t\tconst target$1 = targetRef.value;\n\t\t\tif ((target$1 === null || target$1 === void 0 ? void 0 : target$1[fullscreenEnabled.value]) != null) return Boolean(target$1[fullscreenEnabled.value]);\n\t\t}\n\t\treturn false;\n\t};\n\tasync function exit() {\n\t\tif (!isSupported.value || !isFullscreen.value) return;\n\t\tif (exitMethod.value) if ((document$1 === null || document$1 === void 0 ? void 0 : document$1[exitMethod.value]) != null) await document$1[exitMethod.value]();\n\t\telse {\n\t\t\tconst target$1 = targetRef.value;\n\t\t\tif ((target$1 === null || target$1 === void 0 ? void 0 : target$1[exitMethod.value]) != null) await target$1[exitMethod.value]();\n\t\t}\n\t\tisFullscreen.value = false;\n\t}\n\tasync function enter() {\n\t\tif (!isSupported.value || isFullscreen.value) return;\n\t\tif (isElementFullScreen()) await exit();\n\t\tconst target$1 = targetRef.value;\n\t\tif (requestMethod.value && (target$1 === null || target$1 === void 0 ? void 0 : target$1[requestMethod.value]) != null) {\n\t\t\tawait target$1[requestMethod.value]();\n\t\t\tisFullscreen.value = true;\n\t\t}\n\t}\n\tasync function toggle() {\n\t\tawait (isFullscreen.value ? exit() : enter());\n\t}\n\tconst handlerCallback = () => {\n\t\tconst isElementFullScreenValue = isElementFullScreen();\n\t\tif (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen()) isFullscreen.value = isElementFullScreenValue;\n\t};\n\tconst listenerOptions = {\n\t\tcapture: false,\n\t\tpassive: true\n\t};\n\tuseEventListener(document$1, eventHandlers, handlerCallback, listenerOptions);\n\tuseEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, listenerOptions);\n\ttryOnMounted(handlerCallback, false);\n\tif (autoExit) tryOnScopeDispose(exit);\n\treturn {\n\t\tisSupported,\n\t\tisFullscreen,\n\t\tenter,\n\t\texit,\n\t\ttoggle\n\t};\n}\n\n//#endregion\n//#region useGamepad/index.ts\n/**\n* Maps a standard standard gamepad to an Xbox 360 Controller.\n*/\nfunction mapGamepadToXbox360Controller(gamepad) {\n\treturn computed(() => {\n\t\tif (gamepad.value) return {\n\t\t\tbuttons: {\n\t\t\t\ta: gamepad.value.buttons[0],\n\t\t\t\tb: gamepad.value.buttons[1],\n\t\t\t\tx: gamepad.value.buttons[2],\n\t\t\t\ty: gamepad.value.buttons[3]\n\t\t\t},\n\t\t\tbumper: {\n\t\t\t\tleft: gamepad.value.buttons[4],\n\t\t\t\tright: gamepad.value.buttons[5]\n\t\t\t},\n\t\t\ttriggers: {\n\t\t\t\tleft: gamepad.value.buttons[6],\n\t\t\t\tright: gamepad.value.buttons[7]\n\t\t\t},\n\t\t\tstick: {\n\t\t\t\tleft: {\n\t\t\t\t\thorizontal: gamepad.value.axes[0],\n\t\t\t\t\tvertical: gamepad.value.axes[1],\n\t\t\t\t\tbutton: gamepad.value.buttons[10]\n\t\t\t\t},\n\t\t\t\tright: {\n\t\t\t\t\thorizontal: gamepad.value.axes[2],\n\t\t\t\t\tvertical: gamepad.value.axes[3],\n\t\t\t\t\tbutton: gamepad.value.buttons[11]\n\t\t\t\t}\n\t\t\t},\n\t\t\tdpad: {\n\t\t\t\tup: gamepad.value.buttons[12],\n\t\t\t\tdown: gamepad.value.buttons[13],\n\t\t\t\tleft: gamepad.value.buttons[14],\n\t\t\t\tright: gamepad.value.buttons[15]\n\t\t\t},\n\t\t\tback: gamepad.value.buttons[8],\n\t\t\tstart: gamepad.value.buttons[9]\n\t\t};\n\t\treturn null;\n\t});\n}\n/* @__NO_SIDE_EFFECTS__ */\nfunction useGamepad(options = {}) {\n\tconst { navigator: navigator$1 = defaultNavigator } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => navigator$1 && \"getGamepads\" in navigator$1);\n\tconst gamepads = ref([]);\n\tconst onConnectedHook = createEventHook();\n\tconst onDisconnectedHook = createEventHook();\n\tconst stateFromGamepad = (gamepad) => {\n\t\tconst hapticActuators = [];\n\t\tconst vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n\t\tif (vibrationActuator) hapticActuators.push(vibrationActuator);\n\t\tif (gamepad.hapticActuators) hapticActuators.push(...gamepad.hapticActuators);\n\t\treturn {\n\t\t\tid: gamepad.id,\n\t\t\tindex: gamepad.index,\n\t\t\tconnected: gamepad.connected,\n\t\t\tmapping: gamepad.mapping,\n\t\t\ttimestamp: gamepad.timestamp,\n\t\t\tvibrationActuator: gamepad.vibrationActuator,\n\t\t\thapticActuators,\n\t\t\taxes: gamepad.axes.map((axes) => axes),\n\t\t\tbuttons: gamepad.buttons.map((button) => ({\n\t\t\t\tpressed: button.pressed,\n\t\t\t\ttouched: button.touched,\n\t\t\t\tvalue: button.value\n\t\t\t}))\n\t\t};\n\t};\n\tconst updateGamepadState = () => {\n\t\tconst _gamepads = (navigator$1 === null || navigator$1 === void 0 ? void 0 : navigator$1.getGamepads()) || [];\n\t\tfor (const gamepad of _gamepads) if (gamepad && gamepads.value[gamepad.index]) gamepads.value[gamepad.index] = stateFromGamepad(gamepad);\n\t};\n\tconst { isActive, pause, resume } = useRafFn(updateGamepadState);\n\tconst onGamepadConnected = (gamepad) => {\n\t\tif (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n\t\t\tgamepads.value.push(stateFromGamepad(gamepad));\n\t\t\tonConnectedHook.trigger(gamepad.index);\n\t\t}\n\t\tresume();\n\t};\n\tconst onGamepadDisconnected = (gamepad) => {\n\t\tgamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n\t\tonDisconnectedHook.trigger(gamepad.index);\n\t};\n\tconst listenerOptions = { passive: true };\n\tuseEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad), listenerOptions);\n\tuseEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad), listenerOptions);\n\ttryOnMounted(() => {\n\t\tconst _gamepads = (navigator$1 === null || navigator$1 === void 0 ? void 0 : navigator$1.getGamepads()) || [];\n\t\tfor (const gamepad of _gamepads) if (gamepad && gamepads.value[gamepad.index]) onGamepadConnected(gamepad);\n\t});\n\tpause();\n\treturn {\n\t\tisSupported,\n\t\tonConnected: onConnectedHook.on,\n\t\tonDisconnected: onDisconnectedHook.on,\n\t\tgamepads,\n\t\tpause,\n\t\tresume,\n\t\tisActive\n\t};\n}\n\n//#endregion\n//#region useGeolocation/index.ts\n/**\n* Reactive Geolocation API.\n*\n* @see https://vueuse.org/useGeolocation\n* @param options\n*/\nfunction useGeolocation(options = {}) {\n\tconst { enableHighAccuracy = true, maximumAge = 3e4, timeout = 27e3, navigator: navigator$1 = defaultNavigator, immediate = true } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => navigator$1 && \"geolocation\" in navigator$1);\n\tconst locatedAt = shallowRef(null);\n\tconst error = shallowRef(null);\n\tconst coords = ref({\n\t\taccuracy: 0,\n\t\tlatitude: Number.POSITIVE_INFINITY,\n\t\tlongitude: Number.POSITIVE_INFINITY,\n\t\taltitude: null,\n\t\taltitudeAccuracy: null,\n\t\theading: null,\n\t\tspeed: null\n\t});\n\tfunction updatePosition(position) {\n\t\tlocatedAt.value = position.timestamp;\n\t\tcoords.value = position.coords;\n\t\terror.value = null;\n\t}\n\tlet watcher;\n\tfunction resume() {\n\t\tif (isSupported.value) watcher = navigator$1.geolocation.watchPosition(updatePosition, (err) => error.value = err, {\n\t\t\tenableHighAccuracy,\n\t\t\tmaximumAge,\n\t\t\ttimeout\n\t\t});\n\t}\n\tif (immediate) resume();\n\tfunction pause() {\n\t\tif (watcher && navigator$1) navigator$1.geolocation.clearWatch(watcher);\n\t}\n\ttryOnScopeDispose(() => {\n\t\tpause();\n\t});\n\treturn {\n\t\tisSupported,\n\t\tcoords,\n\t\tlocatedAt,\n\t\terror,\n\t\tresume,\n\t\tpause\n\t};\n}\n\n//#endregion\n//#region useIdle/index.ts\nconst defaultEvents$1 = [\n\t\"mousemove\",\n\t\"mousedown\",\n\t\"resize\",\n\t\"keydown\",\n\t\"touchstart\",\n\t\"wheel\"\n];\nconst oneMinute = 6e4;\n/**\n* Tracks whether the user is being inactive.\n*\n* @see https://vueuse.org/useIdle\n* @param timeout default to 1 minute\n* @param options IdleOptions\n*/\nfunction useIdle(timeout = oneMinute, options = {}) {\n\tconst { initialState = false, listenForVisibilityChange = true, events: events$1 = defaultEvents$1, window: window$1 = defaultWindow, eventFilter = throttleFilter(50) } = options;\n\tconst idle = shallowRef(initialState);\n\tconst lastActive = shallowRef(timestamp());\n\tconst isPending = shallowRef(false);\n\tlet timer;\n\tconst reset = () => {\n\t\tidle.value = false;\n\t\tclearTimeout(timer);\n\t\ttimer = setTimeout(() => idle.value = true, timeout);\n\t};\n\tconst onEvent = createFilterWrapper(eventFilter, () => {\n\t\tlastActive.value = timestamp();\n\t\treset();\n\t});\n\tif (window$1) {\n\t\tconst document$1 = window$1.document;\n\t\tconst listenerOptions = { passive: true };\n\t\tfor (const event of events$1) useEventListener(window$1, event, () => {\n\t\t\tif (!isPending.value) return;\n\t\t\tonEvent();\n\t\t}, listenerOptions);\n\t\tif (listenForVisibilityChange) useEventListener(document$1, \"visibilitychange\", () => {\n\t\t\tif (document$1.hidden || !isPending.value) return;\n\t\t\tonEvent();\n\t\t}, listenerOptions);\n\t\tstart();\n\t}\n\tfunction start() {\n\t\tif (isPending.value) return;\n\t\tisPending.value = true;\n\t\tif (!initialState) reset();\n\t}\n\tfunction stop() {\n\t\tidle.value = initialState;\n\t\tclearTimeout(timer);\n\t\tisPending.value = false;\n\t}\n\treturn {\n\t\tidle,\n\t\tlastActive,\n\t\treset,\n\t\tstop,\n\t\tstart,\n\t\tisPending: shallowReadonly(isPending)\n\t};\n}\n\n//#endregion\n//#region useImage/index.ts\nasync function loadImage(options) {\n\treturn new Promise((resolve, reject) => {\n\t\tconst img = new Image();\n\t\tconst { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy, width, height, decoding, fetchPriority, ismap, usemap } = options;\n\t\timg.src = src;\n\t\tif (srcset != null) img.srcset = srcset;\n\t\tif (sizes != null) img.sizes = sizes;\n\t\tif (clazz != null) img.className = clazz;\n\t\tif (loading != null) img.loading = loading;\n\t\tif (crossorigin != null) img.crossOrigin = crossorigin;\n\t\tif (referrerPolicy != null) img.referrerPolicy = referrerPolicy;\n\t\tif (width != null) img.width = width;\n\t\tif (height != null) img.height = height;\n\t\tif (decoding != null) img.decoding = decoding;\n\t\tif (fetchPriority != null) img.fetchPriority = fetchPriority;\n\t\tif (ismap != null) img.isMap = ismap;\n\t\tif (usemap != null) img.useMap = usemap;\n\t\timg.onload = () => resolve(img);\n\t\timg.onerror = reject;\n\t});\n}\n/**\n* Reactive load an image in the browser, you can wait the result to display it or show a fallback.\n*\n* @see https://vueuse.org/useImage\n* @param options Image attributes, as used in the <img> tag\n* @param asyncStateOptions\n*/\nfunction useImage(options, asyncStateOptions = {}) {\n\tconst state = useAsyncState(() => loadImage(toValue(options)), void 0, {\n\t\tresetOnExecute: true,\n\t\t...asyncStateOptions\n\t});\n\twatch(() => toValue(options), () => state.execute(asyncStateOptions.delay), { deep: true });\n\treturn state;\n}\n\n//#endregion\n//#region _resolve-element.ts\n/**\n* Resolves an element from a given element, window, or document.\n*\n* @internal\n*/\nfunction resolveElement(el) {\n\tif (typeof Window !== \"undefined\" && el instanceof Window) return el.document.documentElement;\n\tif (typeof Document !== \"undefined\" && el instanceof Document) return el.documentElement;\n\treturn el;\n}\n\n//#endregion\n//#region useScroll/index.ts\n/**\n* We have to check if the scroll amount is close enough to some threshold in order to\n* more accurately calculate arrivedState. This is because scrollTop/scrollLeft are non-rounded\n* numbers, while scrollHeight/scrollWidth and clientHeight/clientWidth are rounded.\n* https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#determine_if_an_element_has_been_totally_scrolled\n*/\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\n/**\n* Reactive scroll.\n*\n* @see https://vueuse.org/useScroll\n* @param element\n* @param options\n*/\nfunction useScroll(element, options = {}) {\n\tconst { throttle = 0, idle = 200, onStop = noop, onScroll = noop, offset = {\n\t\tleft: 0,\n\t\tright: 0,\n\t\ttop: 0,\n\t\tbottom: 0\n\t}, observe: _observe = { mutation: false }, eventListenerOptions = {\n\t\tcapture: false,\n\t\tpassive: true\n\t}, behavior = \"auto\", window: window$1 = defaultWindow, onError = (e) => {\n\t\tconsole.error(e);\n\t} } = options;\n\tconst observe = typeof _observe === \"boolean\" ? { mutation: _observe } : _observe;\n\tconst internalX = shallowRef(0);\n\tconst internalY = shallowRef(0);\n\tconst x = computed({\n\t\tget() {\n\t\t\treturn internalX.value;\n\t\t},\n\t\tset(x$1) {\n\t\t\tscrollTo(x$1, void 0);\n\t\t}\n\t});\n\tconst y = computed({\n\t\tget() {\n\t\t\treturn internalY.value;\n\t\t},\n\t\tset(y$1) {\n\t\t\tscrollTo(void 0, y$1);\n\t\t}\n\t});\n\tfunction scrollTo(_x, _y) {\n\t\tvar _ref, _toValue, _toValue2, _document;\n\t\tif (!window$1) return;\n\t\tconst _element = toValue(element);\n\t\tif (!_element) return;\n\t\t(_ref = _element instanceof Document ? window$1.document.body : _element) === null || _ref === void 0 || _ref.scrollTo({\n\t\t\ttop: (_toValue = toValue(_y)) !== null && _toValue !== void 0 ? _toValue : y.value,\n\t\t\tleft: (_toValue2 = toValue(_x)) !== null && _toValue2 !== void 0 ? _toValue2 : x.value,\n\t\t\tbehavior: toValue(behavior)\n\t\t});\n\t\tconst scrollContainer = (_element === null || _element === void 0 || (_document = _element.document) === null || _document === void 0 ? void 0 : _document.documentElement) || (_element === null || _element === void 0 ? void 0 : _element.documentElement) || _element;\n\t\tif (x != null) internalX.value = scrollContainer.scrollLeft;\n\t\tif (y != null) internalY.value = scrollContainer.scrollTop;\n\t}\n\tconst isScrolling = shallowRef(false);\n\tconst arrivedState = reactive({\n\t\tleft: true,\n\t\tright: false,\n\t\ttop: true,\n\t\tbottom: false\n\t});\n\tconst directions = reactive({\n\t\tleft: false,\n\t\tright: false,\n\t\ttop: false,\n\t\tbottom: false\n\t});\n\tconst onScrollEnd = (e) => {\n\t\tif (!isScrolling.value) return;\n\t\tisScrolling.value = false;\n\t\tdirections.left = false;\n\t\tdirections.right = false;\n\t\tdirections.top = false;\n\t\tdirections.bottom = false;\n\t\tonStop(e);\n\t};\n\tconst onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);\n\tconst setArrivedState = (target) => {\n\t\tvar _document2;\n\t\tif (!window$1) return;\n\t\tconst el = (target === null || target === void 0 || (_document2 = target.document) === null || _document2 === void 0 ? void 0 : _document2.documentElement) || (target === null || target === void 0 ? void 0 : target.documentElement) || unrefElement(target);\n\t\tconst { display, flexDirection, direction } = window$1.getComputedStyle(el);\n\t\tconst directionMultipler = direction === \"rtl\" ? -1 : 1;\n\t\tconst scrollLeft = el.scrollLeft;\n\t\tdirections.left = scrollLeft < internalX.value;\n\t\tdirections.right = scrollLeft > internalX.value;\n\t\tconst left = Math.abs(scrollLeft * directionMultipler) <= (offset.left || 0);\n\t\tconst right = Math.abs(scrollLeft * directionMultipler) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n\t\tif (display === \"flex\" && flexDirection === \"row-reverse\") {\n\t\t\tarrivedState.left = right;\n\t\t\tarrivedState.right = left;\n\t\t} else {\n\t\t\tarrivedState.left = left;\n\t\t\tarrivedState.right = right;\n\t\t}\n\t\tinternalX.value = scrollLeft;\n\t\tlet scrollTop = el.scrollTop;\n\t\tif (target === window$1.document && !scrollTop) scrollTop = window$1.document.body.scrollTop;\n\t\tdirections.top = scrollTop < internalY.value;\n\t\tdirections.bottom = scrollTop > internalY.value;\n\t\tconst top = Math.abs(scrollTop) <= (offset.top || 0);\n\t\tconst bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n\t\t/**\n\t\t* reverse columns and rows behave exactly the other way around,\n\t\t* bottom is treated as top and top is treated as the negative version of bottom\n\t\t*/\n\t\tif (display === \"flex\" && flexDirection === \"column-reverse\") {\n\t\t\tarrivedState.top = bottom;\n\t\t\tarrivedState.bottom = top;\n\t\t} else {\n\t\t\tarrivedState.top = top;\n\t\t\tarrivedState.bottom = bottom;\n\t\t}\n\t\tinternalY.value = scrollTop;\n\t};\n\tconst onScrollHandler = (e) => {\n\t\tvar _documentElement;\n\t\tif (!window$1) return;\n\t\tsetArrivedState((_documentElement = e.target.documentElement) !== null && _documentElement !== void 0 ? _documentElement : e.target);\n\t\tisScrolling.value = true;\n\t\tonScrollEndDebounced(e);\n\t\tonScroll(e);\n\t};\n\tuseEventListener(element, \"scroll\", throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler, eventListenerOptions);\n\ttryOnMounted(() => {\n\t\ttry {\n\t\t\tconst _element = toValue(element);\n\t\t\tif (!_element) return;\n\t\t\tsetArrivedState(_element);\n\t\t} catch (e) {\n\t\t\tonError(e);\n\t\t}\n\t});\n\tif ((observe === null || observe === void 0 ? void 0 : observe.mutation) && element != null && element !== window$1 && element !== document) useMutationObserver(element, () => {\n\t\tconst _element = toValue(element);\n\t\tif (!_element) return;\n\t\tsetArrivedState(_element);\n\t}, {\n\t\tattributes: true,\n\t\tchildList: true,\n\t\tsubtree: true\n\t});\n\tuseEventListener(element, \"scrollend\", onScrollEnd, eventListenerOptions);\n\treturn {\n\t\tx,\n\t\ty,\n\t\tisScrolling,\n\t\tarrivedState,\n\t\tdirections,\n\t\tmeasure() {\n\t\t\tconst _element = toValue(element);\n\t\t\tif (window$1 && _element) setArrivedState(_element);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region useInfiniteScroll/index.ts\n/**\n* Reactive infinite scroll.\n*\n* @see https://vueuse.org/useInfiniteScroll\n*/\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n\tvar _options$distance;\n\tconst { direction = \"bottom\", interval = 100, canLoadMore = () => true } = options;\n\tconst state = reactive(useScroll(element, {\n\t\t...options,\n\t\toffset: {\n\t\t\t[direction]: (_options$distance = options.distance) !== null && _options$distance !== void 0 ? _options$distance : 0,\n\t\t\t...options.offset\n\t\t}\n\t}));\n\tconst promise = ref();\n\tconst isLoading = computed(() => !!promise.value);\n\tconst observedElement = computed(() => {\n\t\treturn resolveElement(toValue(element));\n\t});\n\tconst isElementVisible = useElementVisibility(observedElement);\n\tconst canLoad = computed(() => {\n\t\tif (!observedElement.value) return false;\n\t\treturn canLoadMore(observedElement.value);\n\t});\n\tfunction checkAndLoad() {\n\t\tstate.measure();\n\t\tif (!observedElement.value || !isElementVisible.value || !canLoad.value || promise.value) return;\n\t\tconst { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value;\n\t\tconst isNarrower = direction === \"bottom\" || direction === \"top\" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;\n\t\tif (state.arrivedState[direction] || isNarrower) promise.value = Promise.all([onLoadMore(state), new Promise((resolve) => setTimeout(resolve, interval))]).finally(() => {\n\t\t\tpromise.value = null;\n\t\t\tnextTick(() => checkAndLoad());\n\t\t});\n\t}\n\ttryOnUnmounted(watch(() => [\n\t\tstate.arrivedState[direction],\n\t\tisElementVisible.value,\n\t\tcanLoad.value\n\t], checkAndLoad, {\n\t\timmediate: true,\n\t\tflush: \"post\"\n\t}));\n\treturn {\n\t\tisLoading,\n\t\treset() {\n\t\t\tnextTick(() => checkAndLoad());\n\t\t}\n\t};\n}\n\n//#endregion\n//#region useKeyModifier/index.ts\nconst defaultEvents = [\n\t\"mousedown\",\n\t\"mouseup\",\n\t\"keydown\",\n\t\"keyup\"\n];\n/* @__NO_SIDE_EFFECTS__ */\nfunction useKeyModifier(modifier, options = {}) {\n\tconst { events: events$1 = defaultEvents, document: document$1 = defaultDocument, initial = null } = options;\n\tconst state = shallowRef(initial);\n\tif (document$1) events$1.forEach((listenerEvent) => {\n\t\tuseEventListener(document$1, listenerEvent, (evt) => {\n\t\t\tif (typeof evt.getModifierState === \"function\") state.value = evt.getModifierState(modifier);\n\t\t}, { passive: true });\n\t});\n\treturn state;\n}\n\n//#endregion\n//#region useLocalStorage/index.ts\n/**\n* Reactive LocalStorage.\n*\n* @see https://vueuse.org/useLocalStorage\n* @param key\n* @param initialValue\n* @param options\n*/\nfunction useLocalStorage(key, initialValue, options = {}) {\n\tconst { window: window$1 = defaultWindow } = options;\n\treturn useStorage(key, initialValue, window$1 === null || window$1 === void 0 ? void 0 : window$1.localStorage, options);\n}\n\n//#endregion\n//#region useMagicKeys/aliasMap.ts\nconst DefaultMagicKeysAliasMap = {\n\tctrl: \"control\",\n\tcommand: \"meta\",\n\tcmd: \"meta\",\n\toption: \"alt\",\n\tup: \"arrowup\",\n\tdown: \"arrowdown\",\n\tleft: \"arrowleft\",\n\tright: \"arrowright\"\n};\n\n//#endregion\n//#region useMagicKeys/index.ts\n/**\n* Reactive keys pressed state, with magical keys combination support.\n*\n* @see https://vueuse.org/useMagicKeys\n*/\nfunction useMagicKeys(options = {}) {\n\tconst { reactive: useReactive = false, target = defaultWindow, aliasMap = DefaultMagicKeysAliasMap, passive = true, onEventFired = noop } = options;\n\tconst current = reactive(/* @__PURE__ */ new Set());\n\tconst obj = {\n\t\ttoJSON() {\n\t\t\treturn {};\n\t\t},\n\t\tcurrent\n\t};\n\tconst refs = useReactive ? reactive(obj) : obj;\n\tconst metaDeps = /* @__PURE__ */ new Set();\n\tconst depsMap = new Map([\n\t\t[\"Meta\", metaDeps],\n\t\t[\"Shift\", /* @__PURE__ */ new Set()],\n\t\t[\"Alt\", /* @__PURE__ */ new Set()]\n\t]);\n\tconst usedKeys = /* @__PURE__ */ new Set();\n\tfunction setRefs(key, value) {\n\t\tif (key in refs) if (useReactive) refs[key] = value;\n\t\telse refs[key].value = value;\n\t}\n\tfunction reset() {\n\t\tcurrent.clear();\n\t\tfor (const key of usedKeys) setRefs(key, false);\n\t}\n\tfunction updateDeps(value, e, keys$1) {\n\t\tif (!value || typeof e.getModifierState !== \"function\") return;\n\t\tfor (const [modifier, depsSet] of depsMap) if (e.getModifierState(modifier)) {\n\t\t\tkeys$1.forEach((key) => depsSet.add(key));\n\t\t\tbreak;\n\t\t}\n\t}\n\tfunction clearDeps(value, key) {\n\t\tif (value) return;\n\t\tconst depsMapKey = `${key[0].toUpperCase()}${key.slice(1)}`;\n\t\tconst deps = depsMap.get(depsMapKey);\n\t\tif (![\"shift\", \"alt\"].includes(key) || !deps) return;\n\t\tconst depsArray = Array.from(deps);\n\t\tconst depsIndex = depsArray.indexOf(key);\n\t\tdepsArray.forEach((key$1, index) => {\n\t\t\tif (index >= depsIndex) {\n\t\t\t\tcurrent.delete(key$1);\n\t\t\t\tsetRefs(key$1, false);\n\t\t\t}\n\t\t});\n\t\tdeps.clear();\n\t}\n\tfunction updateRefs(e, value) {\n\t\tvar _e$key, _e$code;\n\t\tconst key = (_e$key = e.key) === null || _e$key === void 0 ? void 0 : _e$key.toLowerCase();\n\t\tconst values = [(_e$code = e.code) === null || _e$code === void 0 ? void 0 : _e$code.toLowerCase(), key].filter(Boolean);\n\t\tif (!key) return;\n\t\tif (key) if (value) current.add(key);\n\t\telse current.delete(key);\n\t\tfor (const key$1 of values) {\n\t\t\tusedKeys.add(key$1);\n\t\t\tsetRefs(key$1, value);\n\t\t}\n\t\tupdateDeps(value, e, [...current, ...values]);\n\t\tclearDeps(value, key);\n\t\tif (key === \"meta\" && !value) {\n\t\t\tmetaDeps.forEach((key$1) => {\n\t\t\t\tcurrent.delete(key$1);\n\t\t\t\tsetRefs(key$1, false);\n\t\t\t});\n\t\t\tmetaDeps.clear();\n\t\t}\n\t}\n\tuseEventListener(target, \"keydown\", (e) => {\n\t\tupdateRefs(e, true);\n\t\treturn onEventFired(e);\n\t}, { passive });\n\tuseEventListener(target, \"keyup\", (e) => {\n\t\tupdateRefs(e, false);\n\t\treturn onEventFired(e);\n\t}, { passive });\n\tuseEventListener(\"blur\", reset, { passive });\n\tuseEventListener(\"focus\", reset, { passive });\n\tconst proxy = new Proxy(refs, { get(target$1, prop, rec) {\n\t\tif (typeof prop !== \"string\") return Reflect.get(target$1, prop, rec);\n\t\tprop = prop.toLowerCase();\n\t\tif (prop in aliasMap) prop = aliasMap[prop];\n\t\tif (!(prop in refs)) if (/[+_-]/.test(prop)) {\n\t\t\tconst keys$1 = prop.split(/[+_-]/g).map((i) => i.trim());\n\t\t\trefs[prop] = computed(() => keys$1.map((key) => toValue(proxy[key])).every(Boolean));\n\t\t} else refs[prop] = shallowRef(false);\n\t\tconst r = Reflect.get(target$1, prop, rec);\n\t\treturn useReactive ? toValue(r) : r;\n\t} });\n\treturn proxy;\n}\n\n//#endregion\n//#region useMediaControls/index.ts\n/**\n* Automatically check if the ref exists and if it does run the cb fn\n*/\nfunction usingElRef(source, cb) {\n\tif (toValue(source)) cb(toValue(source));\n}\n/**\n* Converts a TimeRange object to an array\n*/\nfunction timeRangeToArray(timeRanges) {\n\tlet ranges = [];\n\tfor (let i = 0; i < timeRanges.length; ++i) ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n\treturn ranges;\n}\n/**\n* Converts a TextTrackList object to an array of `UseMediaTextTrack`\n*/\nfunction tracksToArray(tracks) {\n\treturn Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({\n\t\tid,\n\t\tlabel,\n\t\tkind,\n\t\tlanguage,\n\t\tmode,\n\t\tactiveCues,\n\t\tcues,\n\t\tinBandMetadataTrackDispatchType\n\t}));\n}\nconst defaultOptions = {\n\tsrc: \"\",\n\ttracks: []\n};\nfunction useMediaControls(target, options = {}) {\n\ttarget = toRef(target);\n\toptions = {\n\t\t...defaultOptions,\n\t\t...options\n\t};\n\tconst { document: document$1 = defaultDocument } = options;\n\tconst listenerOptions = { passive: true };\n\tconst currentTime = shallowRef(0);\n\tconst duration = shallowRef(0);\n\tconst seeking = shallowRef(false);\n\tconst volume = shallowRef(1);\n\tconst waiting = shallowRef(false);\n\tconst ended = shallowRef(false);\n\tconst playing = shallowRef(false);\n\tconst rate = shallowRef(1);\n\tconst stalled = shallowRef(false);\n\tconst buffered = ref([]);\n\tconst tracks = ref([]);\n\tconst selectedTrack = shallowRef(-1);\n\tconst isPictureInPicture = shallowRef(false);\n\tconst muted = shallowRef(false);\n\tconst supportsPictureInPicture = Boolean(document$1 && \"pictureInPictureEnabled\" in document$1);\n\tconst sourceErrorEvent = createEventHook();\n\tconst playbackErrorEvent = createEventHook();\n\t/**\n\t* Disables the specified track. If no track is specified then\n\t* all tracks will be disabled\n\t*\n\t* @param track The id of the track to disable\n\t*/\n\tconst disableTrack = (track) => {\n\t\tusingElRef(target, (el) => {\n\t\t\tif (track) {\n\t\t\t\tconst id = typeof track === \"number\" ? track : track.id;\n\t\t\t\tel.textTracks[id].mode = \"disabled\";\n\t\t\t} else for (let i = 0; i < el.textTracks.length; ++i) el.textTracks[i].mode = \"disabled\";\n\t\t\tselectedTrack.value = -1;\n\t\t});\n\t};\n\t/**\n\t* Enables the specified track and disables the\n\t* other tracks unless otherwise specified\n\t*\n\t* @param track The track of the id of the track to enable\n\t* @param disableTracks Disable all other tracks\n\t*/\n\tconst enableTrack = (track, disableTracks = true) => {\n\t\tusingElRef(target, (el) => {\n\t\t\tconst id = typeof track === \"number\" ? track : track.id;\n\t\t\tif (disableTracks) disableTrack();\n\t\t\tel.textTracks[id].mode = \"showing\";\n\t\t\tselectedTrack.value = id;\n\t\t});\n\t};\n\t/**\n\t* Toggle picture in picture mode for the player.\n\t*/\n\tconst togglePictureInPicture = () => {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tusingElRef(target, async (el) => {\n\t\t\t\tif (supportsPictureInPicture) if (!isPictureInPicture.value) el.requestPictureInPicture().then(resolve).catch(reject);\n\t\t\t\telse document$1.exitPictureInPicture().then(resolve).catch(reject);\n\t\t\t});\n\t\t});\n\t};\n\t/**\n\t* This will automatically inject sources to the media element. The sources will be\n\t* appended as children to the media element as `<source>` elements.\n\t*/\n\twatchEffect(() => {\n\t\tif (!document$1) return;\n\t\tconst el = toValue(target);\n\t\tif (!el) return;\n\t\tconst src = toValue(options.src);\n\t\tlet sources = [];\n\t\tif (!src) return;\n\t\tif (typeof src === \"string\") sources = [{ src }];\n\t\telse if (Array.isArray(src)) sources = src;\n\t\telse if (isObject(src)) sources = [src];\n\t\tel.querySelectorAll(\"source\").forEach((e) => {\n\t\t\te.remove();\n\t\t});\n\t\tsources.forEach(({ src: src$1, type, media }) => {\n\t\t\tconst source = document$1.createElement(\"source\");\n\t\t\tsource.setAttribute(\"src\", src$1);\n\t\t\tsource.setAttribute(\"type\", type || \"\");\n\t\t\tsource.setAttribute(\"media\", media || \"\");\n\t\t\tuseEventListener(source, \"error\", sourceErrorEvent.trigger, listenerOptions);\n\t\t\tel.appendChild(source);\n\t\t});\n\t\tel.load();\n\t});\n\t/**\n\t* Apply composable state to the element, also when element is changed\n\t*/\n\twatch([target, volume], () => {\n\t\tconst el = toValue(target);\n\t\tif (!el) return;\n\t\tel.volume = volume.value;\n\t});\n\twatch([target, muted], () => {\n\t\tconst el = toValue(target);\n\t\tif (!el) return;\n\t\tel.muted = muted.value;\n\t});\n\twatch([target, rate], () => {\n\t\tconst el = toValue(target);\n\t\tif (!el) return;\n\t\tel.playbackRate = rate.value;\n\t});\n\t/**\n\t* Load Tracks\n\t*/\n\twatchEffect(() => {\n\t\tif (!document$1) return;\n\t\tconst textTracks = toValue(options.tracks);\n\t\tconst el = toValue(target);\n\t\tif (!textTracks || !textTracks.length || !el) return;\n\t\t/**\n\t\t* The MediaAPI provides an API for adding text tracks, but they don't currently\n\t\t* have an API for removing text tracks, so instead we will just create and remove\n\t\t* the tracks manually using the HTML api.\n\t\t*/\n\t\tel.querySelectorAll(\"track\").forEach((e) => e.remove());\n\t\ttextTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n\t\t\tconst track = document$1.createElement(\"track\");\n\t\t\ttrack.default = isDefault || false;\n\t\t\ttrack.kind = kind;\n\t\t\ttrack.label = label;\n\t\t\ttrack.src = src;\n\t\t\ttrack.srclang = srcLang;\n\t\t\tif (track.default) selectedTrack.value = i;\n\t\t\tel.appendChild(track);\n\t\t});\n\t});\n\t/**\n\t* This will allow us to update the current time from the timeupdate event\n\t* without setting the medias current position, but if the user changes the\n\t* current time via the ref, then the media will seek.\n\t*\n\t* If we did not use an ignorable watch, then the current time update from\n\t* the timeupdate event would cause the media to stutter.\n\t*/\n\tconst { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n\t\tconst el = toValue(target);\n\t\tif (!el) return;\n\t\tel.currentTime = time;\n\t});\n\t/**\n\t* Using an ignorable watch so we can control the play state using a ref and not\n\t* a function\n\t*/\n\tconst { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n\t\tconst el = toValue(target);\n\t\tif (!el) return;\n\t\tif (isPlaying) el.play().catch((e) => {\n\t\t\tplaybackErrorEvent.trigger(e);\n\t\t\tthrow e;\n\t\t});\n\t\telse el.pause();\n\t});\n\tuseEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime), listenerOptions);\n\tuseEventListener(target, \"durationchange\", () => duration.value = toValue(target).duration, listenerOptions);\n\tuseEventListener(target, \"progress\", () => buffered.value = timeRangeToArray(toValue(target).buffered), listenerOptions);\n\tuseEventListener(target, \"seeking\", () => seeking.value = true, listenerOptions);\n\tuseEventListener(target, \"seeked\", () => seeking.value = false, listenerOptions);\n\tuseEventListener(target, [\"waiting\", \"loadstart\"], () => {\n\t\twaiting.value = true;\n\t\tignorePlayingUpdates(() => playing.value = false);\n\t}, listenerOptions);\n\tuseEventListener(target, \"loadeddata\", () => waiting.value = false, listenerOptions);\n\tuseEventListener(target, \"playing\", () => {\n\t\twaiting.value = false;\n\t\tended.value = false;\n\t\tignorePlayingUpdates(() => playing.value = true);\n\t}, listenerOptions);\n\tuseEventListener(target, \"ratechange\", () => rate.value = toValue(target).playbackRate, listenerOptions);\n\tuseEventListener(target, \"stalled\", () => stalled.value = true, listenerOptions);\n\tuseEventListener(target, \"ended\", () => ended.value = true, listenerOptions);\n\tuseEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false), listenerOptions);\n\tuseEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true), listenerOptions);\n\tuseEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true, listenerOptions);\n\tuseEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false, listenerOptions);\n\tuseEventListener(target, \"volumechange\", () => {\n\t\tconst el = toValue(target);\n\t\tif (!el) return;\n\t\tvolume.value = el.volume;\n\t\tmuted.value = el.muted;\n\t}, listenerOptions);\n\t/**\n\t* The following listeners need to listen to a nested\n\t* object on the target, so we will have to use a nested\n\t* watch and manually remove the listeners\n\t*/\n\tconst listeners = [];\n\tconst stop = watch([target], () => {\n\t\tconst el = toValue(target);\n\t\tif (!el) return;\n\t\tstop();\n\t\tlisteners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);\n\t\tlisteners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);\n\t\tlisteners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks), listenerOptions);\n\t});\n\ttryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n\treturn {\n\t\tcurrentTime,\n\t\tduration,\n\t\twaiting,\n\t\tseeking,\n\t\tended,\n\t\tstalled,\n\t\tbuffered,\n\t\tplaying,\n\t\trate,\n\t\tvolume,\n\t\tmuted,\n\t\ttracks,\n\t\tselectedTrack,\n\t\tenableTrack,\n\t\tdisableTrack,\n\t\tsupportsPictureInPicture,\n\t\ttogglePictureInPicture,\n\t\tisPictureInPicture,\n\t\tonSourceError: sourceErrorEvent.on,\n\t\tonPlaybackError: playbackErrorEvent.on\n\t};\n}\n\n//#endregion\n//#region useMemoize/index.ts\n/**\n* Reactive function result cache based on arguments\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useMemoize(resolver, options) {\n\tconst initCache = () => {\n\t\tif (options === null || options === void 0 ? void 0 : options.cache) return shallowReactive(options.cache);\n\t\treturn shallowReactive(/* @__PURE__ */ new Map());\n\t};\n\tconst cache = initCache();\n\t/**\n\t* Generate key from args\n\t*/\n\tconst generateKey = (...args) => (options === null || options === void 0 ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n\t/**\n\t* Load data and save in cache\n\t*/\n\tconst _loadData = (key, ...args) => {\n\t\tcache.set(key, resolver(...args));\n\t\treturn cache.get(key);\n\t};\n\tconst loadData = (...args) => _loadData(generateKey(...args), ...args);\n\t/**\n\t* Delete key from cache\n\t*/\n\tconst deleteData = (...args) => {\n\t\tcache.delete(generateKey(...args));\n\t};\n\t/**\n\t* Clear cached data\n\t*/\n\tconst clearData = () => {\n\t\tcache.clear();\n\t};\n\tconst memoized = (...args) => {\n\t\tconst key = generateKey(...args);\n\t\tif (cache.has(key)) return cache.get(key);\n\t\treturn _loadData(key, ...args);\n\t};\n\tmemoized.load = loadData;\n\tmemoized.delete = deleteData;\n\tmemoized.clear = clearData;\n\tmemoized.generateKey = generateKey;\n\tmemoized.cache = cache;\n\treturn memoized;\n}\n\n//#endregion\n//#region useMemory/index.ts\nfunction getDefaultScheduler$6(options) {\n\tif (\"interval\" in options || \"immediate\" in options || \"immediateCallback\" in options) {\n\t\tconst { interval = 1e3, immediate, immediateCallback } = options;\n\t\treturn (cb) => useIntervalFn(cb, interval, {\n\t\t\timmediate,\n\t\t\timmediateCallback\n\t\t});\n\t}\n\treturn useIntervalFn;\n}\n/**\n* Reactive Memory Info.\n*\n* @see https://vueuse.org/useMemory\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useMemory(options = {}) {\n\tconst memory = ref();\n\tconst isSupported = /* @__PURE__ */ useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n\tif (isSupported.value) {\n\t\tconst { scheduler = getDefaultScheduler$6 } = options;\n\t\tscheduler(() => {\n\t\t\tmemory.value = performance.memory;\n\t\t});\n\t}\n\treturn {\n\t\tisSupported,\n\t\tmemory\n\t};\n}\n\n//#endregion\n//#region useMouse/index.ts\nconst UseMouseBuiltinExtractors = {\n\tpage: (event) => [event.pageX, event.pageY],\n\tclient: (event) => [event.clientX, event.clientY],\n\tscreen: (event) => [event.screenX, event.screenY],\n\tmovement: (event) => event instanceof MouseEvent ? [event.movementX, event.movementY] : null\n};\n/**\n* Reactive mouse position.\n*\n* @see https://vueuse.org/useMouse\n* @param options\n*/\nfunction useMouse(options = {}) {\n\tconst { type = \"page\", touch = true, resetOnTouchEnds = false, initialValue = {\n\t\tx: 0,\n\t\ty: 0\n\t}, window: window$1 = defaultWindow, target = window$1, scroll = true, eventFilter } = options;\n\tlet _prevMouseEvent = null;\n\tlet _prevScrollX = 0;\n\tlet _prevScrollY = 0;\n\tconst x = shallowRef(initialValue.x);\n\tconst y = shallowRef(initialValue.y);\n\tconst sourceType = shallowRef(null);\n\tconst extractor = typeof type === \"function\" ? type : UseMouseBuiltinExtractors[type];\n\tconst mouseHandler = (event) => {\n\t\tconst result = extractor(event);\n\t\t_prevMouseEvent = event;\n\t\tif (result) {\n\t\t\t[x.value, y.value] = result;\n\t\t\tsourceType.value = \"mouse\";\n\t\t}\n\t\tif (window$1) {\n\t\t\t_prevScrollX = window$1.scrollX;\n\t\t\t_prevScrollY = window$1.scrollY;\n\t\t}\n\t};\n\tconst touchHandler = (event) => {\n\t\tif (event.touches.length > 0) {\n\t\t\tconst result = extractor(event.touches[0]);\n\t\t\tif (result) {\n\t\t\t\t[x.value, y.value] = result;\n\t\t\t\tsourceType.value = \"touch\";\n\t\t\t}\n\t\t}\n\t};\n\tconst scrollHandler = () => {\n\t\tif (!_prevMouseEvent || !window$1) return;\n\t\tconst pos = extractor(_prevMouseEvent);\n\t\tif (_prevMouseEvent instanceof MouseEvent && pos) {\n\t\t\tx.value = pos[0] + window$1.scrollX - _prevScrollX;\n\t\t\ty.value = pos[1] + window$1.scrollY - _prevScrollY;\n\t\t}\n\t};\n\tconst reset = () => {\n\t\tx.value = initialValue.x;\n\t\ty.value = initialValue.y;\n\t};\n\tconst mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);\n\tconst touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);\n\tconst scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();\n\tif (target) {\n\t\tconst listenerOptions = { passive: true };\n\t\tuseEventListener(target, [\"mousemove\", \"dragover\"], mouseHandlerWrapper, listenerOptions);\n\t\tif (touch && type !== \"movement\") {\n\t\t\tuseEventListener(target, [\"touchstart\", \"touchmove\"], touchHandlerWrapper, listenerOptions);\n\t\t\tif (resetOnTouchEnds) useEventListener(target, \"touchend\", reset, listenerOptions);\n\t\t}\n\t\tif (scroll && type === \"page\") useEventListener(window$1, \"scroll\", scrollHandlerWrapper, listenerOptions);\n\t}\n\treturn {\n\t\tx,\n\t\ty,\n\t\tsourceType\n\t};\n}\n\n//#endregion\n//#region useMouseInElement/index.ts\n/**\n* Reactive mouse position related to an element.\n*\n* @see https://vueuse.org/useMouseInElement\n* @param target\n* @param options\n*/\nfunction useMouseInElement(target, options = {}) {\n\tconst { windowResize = true, windowScroll = true, handleOutside = true, window: window$1 = defaultWindow } = options;\n\tconst type = options.type || \"page\";\n\tconst { x, y, sourceType } = useMouse(options);\n\tconst targetRef = shallowRef(target !== null && target !== void 0 ? target : window$1 === null || window$1 === void 0 ? void 0 : window$1.document.body);\n\tconst elementX = shallowRef(0);\n\tconst elementY = shallowRef(0);\n\tconst elementPositionX = shallowRef(0);\n\tconst elementPositionY = shallowRef(0);\n\tconst elementHeight = shallowRef(0);\n\tconst elementWidth = shallowRef(0);\n\tconst isOutside = shallowRef(true);\n\tfunction update() {\n\t\tif (!window$1) return;\n\t\tconst el = unrefElement(targetRef);\n\t\tif (!el || !(el instanceof Element)) return;\n\t\tfor (const rect of el.getClientRects()) {\n\t\t\tconst { left, top, width, height } = rect;\n\t\t\telementPositionX.value = left + (type === \"page\" ? window$1.pageXOffset : 0);\n\t\t\telementPositionY.value = top + (type === \"page\" ? window$1.pageYOffset : 0);\n\t\t\telementHeight.value = height;\n\t\t\telementWidth.value = width;\n\t\t\tconst elX = x.value - elementPositionX.value;\n\t\t\tconst elY = y.value - elementPositionY.value;\n\t\t\tisOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n\t\t\tif (handleOutside || !isOutside.value) {\n\t\t\t\telementX.value = elX;\n\t\t\t\telementY.value = elY;\n\t\t\t}\n\t\t\tif (!isOutside.value) break;\n\t\t}\n\t}\n\tconst stopFnList = [];\n\tfunction stop() {\n\t\tstopFnList.forEach((fn) => fn());\n\t\tstopFnList.length = 0;\n\t}\n\ttryOnMounted(() => {\n\t\tupdate();\n\t});\n\tif (window$1) {\n\t\tconst { stop: stopResizeObserver } = useResizeObserver(targetRef, update);\n\t\tconst { stop: stopMutationObserver } = useMutationObserver(targetRef, update, { attributeFilter: [\"style\", \"class\"] });\n\t\tconst stopWatch = watch([\n\t\t\ttargetRef,\n\t\t\tx,\n\t\t\ty\n\t\t], update);\n\t\tstopFnList.push(stopResizeObserver, stopMutationObserver, stopWatch);\n\t\tuseEventListener(document, \"mouseleave\", () => isOutside.value = true, { passive: true });\n\t\tif (windowScroll) stopFnList.push(useEventListener(\"scroll\", update, {\n\t\t\tcapture: true,\n\t\t\tpassive: true\n\t\t}));\n\t\tif (windowResize) stopFnList.push(useEventListener(\"resize\", update, { passive: true }));\n\t}\n\treturn {\n\t\tx,\n\t\ty,\n\t\tsourceType,\n\t\telementX,\n\t\telementY,\n\t\telementPositionX,\n\t\telementPositionY,\n\t\telementHeight,\n\t\telementWidth,\n\t\tisOutside,\n\t\tstop\n\t};\n}\n\n//#endregion\n//#region useMousePressed/index.ts\n/**\n* Reactive mouse pressing state.\n*\n* @see https://vueuse.org/useMousePressed\n* @param options\n*/\nfunction useMousePressed(options = {}) {\n\tconst { touch = true, drag = true, capture = false, initialValue = false, window: window$1 = defaultWindow } = options;\n\tconst pressed = shallowRef(initialValue);\n\tconst sourceType = shallowRef(null);\n\tif (!window$1) return {\n\t\tpressed,\n\t\tsourceType\n\t};\n\tconst onPressed = (srcType) => (event) => {\n\t\tvar _options$onPressed;\n\t\tpressed.value = true;\n\t\tsourceType.value = srcType;\n\t\t(_options$onPressed = options.onPressed) === null || _options$onPressed === void 0 || _options$onPressed.call(options, event);\n\t};\n\tconst onReleased = (event) => {\n\t\tvar _options$onReleased;\n\t\tpressed.value = false;\n\t\tsourceType.value = null;\n\t\t(_options$onReleased = options.onReleased) === null || _options$onReleased === void 0 || _options$onReleased.call(options, event);\n\t};\n\tconst target = computed(() => unrefElement(options.target) || window$1);\n\tconst listenerOptions = {\n\t\tpassive: true,\n\t\tcapture\n\t};\n\tuseEventListener(target, \"mousedown\", onPressed(\"mouse\"), listenerOptions);\n\tuseEventListener(window$1, \"mouseleave\", onReleased, listenerOptions);\n\tuseEventListener(window$1, \"mouseup\", onReleased, listenerOptions);\n\tif (drag) {\n\t\tuseEventListener(target, \"dragstart\", onPressed(\"mouse\"), listenerOptions);\n\t\tuseEventListener(window$1, \"drop\", onReleased, listenerOptions);\n\t\tuseEventListener(window$1, \"dragend\", onReleased, listenerOptions);\n\t}\n\tif (touch) {\n\t\tuseEventListener(target, \"touchstart\", onPressed(\"touch\"), listenerOptions);\n\t\tuseEventListener(window$1, \"touchend\", onReleased, listenerOptions);\n\t\tuseEventListener(window$1, \"touchcancel\", onReleased, listenerOptions);\n\t}\n\treturn {\n\t\tpressed,\n\t\tsourceType\n\t};\n}\n\n//#endregion\n//#region useNavigatorLanguage/index.ts\n/**\n*\n* Reactive useNavigatorLanguage\n*\n* Detects the currently selected user language and returns a reactive language\n* @see https://vueuse.org/useNavigatorLanguage\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useNavigatorLanguage(options = {}) {\n\tconst { window: window$1 = defaultWindow } = options;\n\tconst navigator$1 = window$1 === null || window$1 === void 0 ? void 0 : window$1.navigator;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => navigator$1 && \"language\" in navigator$1);\n\tconst language = shallowRef(navigator$1 === null || navigator$1 === void 0 ? void 0 : navigator$1.language);\n\tuseEventListener(window$1, \"languagechange\", () => {\n\t\tif (navigator$1) language.value = navigator$1.language;\n\t}, { passive: true });\n\treturn {\n\t\tisSupported,\n\t\tlanguage\n\t};\n}\n\n//#endregion\n//#region useNetwork/index.ts\n/**\n* Reactive Network status.\n*\n* @see https://vueuse.org/useNetwork\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useNetwork(options = {}) {\n\tconst { window: window$1 = defaultWindow } = options;\n\tconst navigator$1 = window$1 === null || window$1 === void 0 ? void 0 : window$1.navigator;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => navigator$1 && \"connection\" in navigator$1);\n\tconst isOnline = shallowRef(true);\n\tconst saveData = shallowRef(false);\n\tconst offlineAt = shallowRef(void 0);\n\tconst onlineAt = shallowRef(void 0);\n\tconst downlink = shallowRef(void 0);\n\tconst downlinkMax = shallowRef(void 0);\n\tconst rtt = shallowRef(void 0);\n\tconst effectiveType = shallowRef(void 0);\n\tconst type = shallowRef(\"unknown\");\n\tconst connection = isSupported.value && navigator$1.connection;\n\tfunction updateNetworkInformation() {\n\t\tif (!navigator$1) return;\n\t\tisOnline.value = navigator$1.onLine;\n\t\tofflineAt.value = isOnline.value ? void 0 : Date.now();\n\t\tonlineAt.value = isOnline.value ? Date.now() : void 0;\n\t\tif (connection) {\n\t\t\tdownlink.value = connection.downlink;\n\t\t\tdownlinkMax.value = connection.downlinkMax;\n\t\t\teffectiveType.value = connection.effectiveType;\n\t\t\trtt.value = connection.rtt;\n\t\t\tsaveData.value = connection.saveData;\n\t\t\ttype.value = connection.type;\n\t\t}\n\t}\n\tconst listenerOptions = { passive: true };\n\tif (window$1) {\n\t\tuseEventListener(window$1, \"offline\", () => {\n\t\t\tisOnline.value = false;\n\t\t\tofflineAt.value = Date.now();\n\t\t}, listenerOptions);\n\t\tuseEventListener(window$1, \"online\", () => {\n\t\t\tisOnline.value = true;\n\t\t\tonlineAt.value = Date.now();\n\t\t}, listenerOptions);\n\t}\n\tif (connection) useEventListener(connection, \"change\", updateNetworkInformation, listenerOptions);\n\tupdateNetworkInformation();\n\treturn {\n\t\tisSupported,\n\t\tisOnline: readonly(isOnline),\n\t\tsaveData: readonly(saveData),\n\t\tofflineAt: readonly(offlineAt),\n\t\tonlineAt: readonly(onlineAt),\n\t\tdownlink: readonly(downlink),\n\t\tdownlinkMax: readonly(downlinkMax),\n\t\teffectiveType: readonly(effectiveType),\n\t\trtt: readonly(rtt),\n\t\ttype: readonly(type)\n\t};\n}\n\n//#endregion\n//#region useNow/index.ts\nfunction getDefaultScheduler$5(options) {\n\tif (\"interval\" in options || \"immediate\" in options) {\n\t\tconst { interval = \"requestAnimationFrame\", immediate = true } = options;\n\t\treturn interval === \"requestAnimationFrame\" ? (fn) => useRafFn(fn, { immediate }) : (fn) => useIntervalFn(fn, interval, options);\n\t}\n\treturn useRafFn;\n}\n/**\n* Reactive current Date instance.\n*\n* @see https://vueuse.org/useNow\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useNow(options = {}) {\n\tconst { controls: exposeControls = false, scheduler = getDefaultScheduler$5(options) } = options;\n\tconst now = ref(/* @__PURE__ */ new Date());\n\tconst update = () => now.value = /* @__PURE__ */ new Date();\n\tconst controls = scheduler(update);\n\tif (exposeControls) return {\n\t\tnow,\n\t\t...controls\n\t};\n\telse return now;\n}\n\n//#endregion\n//#region useObjectUrl/index.ts\n/**\n* Reactive URL representing an object.\n*\n* @see https://vueuse.org/useObjectUrl\n* @param object\n*/\nfunction useObjectUrl(object) {\n\tconst url = shallowRef();\n\tconst release = () => {\n\t\tif (url.value) URL.revokeObjectURL(url.value);\n\t\turl.value = void 0;\n\t};\n\twatch(() => toValue(object), (newObject) => {\n\t\trelease();\n\t\tif (newObject) url.value = URL.createObjectURL(newObject);\n\t}, { immediate: true });\n\ttryOnScopeDispose(release);\n\treturn readonly(url);\n}\n\n//#endregion\n//#region ../math/useClamp/index.ts\n/**\n* Reactively clamp a value between two other values.\n*\n* @see https://vueuse.org/useClamp\n* @param value number\n* @param min\n* @param max\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useClamp(value, min, max) {\n\tif (typeof value === \"function\" || isReadonly(value)) return computed(() => clamp(toValue(value), toValue(min), toValue(max)));\n\tconst _value = ref(value);\n\treturn computed({\n\t\tget() {\n\t\t\treturn _value.value = clamp(_value.value, toValue(min), toValue(max));\n\t\t},\n\t\tset(value$1) {\n\t\t\t_value.value = clamp(value$1, toValue(min), toValue(max));\n\t\t}\n\t});\n}\n\n//#endregion\n//#region useOffsetPagination/index.ts\nfunction useOffsetPagination(options) {\n\tconst { total = Number.POSITIVE_INFINITY, pageSize = 10, page = 1, onPageChange = noop, onPageSizeChange = noop, onPageCountChange = noop } = options;\n\tconst currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);\n\tconst pageCount = computed(() => Math.max(1, Math.ceil(toValue(total) / toValue(currentPageSize))));\n\tconst currentPage = useClamp(page, 1, pageCount);\n\tconst isFirstPage = computed(() => currentPage.value === 1);\n\tconst isLastPage = computed(() => currentPage.value === pageCount.value);\n\tif (isRef(page)) syncRef(page, currentPage, { direction: isReadonly(page) ? \"ltr\" : \"both\" });\n\tif (isRef(pageSize)) syncRef(pageSize, currentPageSize, { direction: isReadonly(pageSize) ? \"ltr\" : \"both\" });\n\tfunction prev() {\n\t\tcurrentPage.value--;\n\t}\n\tfunction next() {\n\t\tcurrentPage.value++;\n\t}\n\tconst returnValue = {\n\t\tcurrentPage,\n\t\tcurrentPageSize,\n\t\tpageCount,\n\t\tisFirstPage,\n\t\tisLastPage,\n\t\tprev,\n\t\tnext\n\t};\n\twatch(currentPage, () => {\n\t\tonPageChange(reactive(returnValue));\n\t});\n\twatch(currentPageSize, () => {\n\t\tonPageSizeChange(reactive(returnValue));\n\t});\n\twatch(pageCount, () => {\n\t\tonPageCountChange(reactive(returnValue));\n\t});\n\treturn returnValue;\n}\n\n//#endregion\n//#region useOnline/index.ts\n/**\n* Reactive online state.\n*\n* @see https://vueuse.org/useOnline\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useOnline(options = {}) {\n\tconst { isOnline } = useNetwork(options);\n\treturn isOnline;\n}\n\n//#endregion\n//#region usePageLeave/index.ts\n/**\n* Reactive state to show whether mouse leaves the page.\n*\n* @see https://vueuse.org/usePageLeave\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction usePageLeave(options = {}) {\n\tconst { window: window$1 = defaultWindow } = options;\n\tconst isLeft = shallowRef(false);\n\tconst handler = (event) => {\n\t\tif (!window$1) return;\n\t\tevent = event || window$1.event;\n\t\tisLeft.value = !(event.relatedTarget || event.toElement);\n\t};\n\tif (window$1) {\n\t\tconst listenerOptions = { passive: true };\n\t\tuseEventListener(window$1, \"mouseout\", handler, listenerOptions);\n\t\tuseEventListener(window$1.document, \"mouseleave\", handler, listenerOptions);\n\t\tuseEventListener(window$1.document, \"mouseenter\", handler, listenerOptions);\n\t}\n\treturn isLeft;\n}\n\n//#endregion\n//#region useScreenOrientation/index.ts\n/**\n* Reactive screen orientation\n*\n* @see https://vueuse.org/useScreenOrientation\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useScreenOrientation(options = {}) {\n\tconst { window: window$1 = defaultWindow } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => window$1 && \"screen\" in window$1 && \"orientation\" in window$1.screen);\n\tconst screenOrientation = isSupported.value ? window$1.screen.orientation : {};\n\tconst orientation = ref(screenOrientation.type);\n\tconst angle = shallowRef(screenOrientation.angle || 0);\n\tif (isSupported.value) useEventListener(window$1, \"orientationchange\", () => {\n\t\torientation.value = screenOrientation.type;\n\t\tangle.value = screenOrientation.angle;\n\t}, { passive: true });\n\tconst lockOrientation = (type) => {\n\t\tif (isSupported.value && typeof screenOrientation.lock === \"function\") return screenOrientation.lock(type);\n\t\treturn Promise.reject(/* @__PURE__ */ new Error(\"Not supported\"));\n\t};\n\tconst unlockOrientation = () => {\n\t\tif (isSupported.value && typeof screenOrientation.unlock === \"function\") screenOrientation.unlock();\n\t};\n\treturn {\n\t\tisSupported,\n\t\torientation,\n\t\tangle,\n\t\tlockOrientation,\n\t\tunlockOrientation\n\t};\n}\n\n//#endregion\n//#region useParallax/index.ts\n/**\n* Create parallax effect easily. It uses `useDeviceOrientation` and fallback to `useMouse`\n* if orientation is not supported.\n*\n* @param target\n* @param options\n*/\nfunction useParallax(target, options = {}) {\n\tconst { deviceOrientationTiltAdjust = (i) => i, deviceOrientationRollAdjust = (i) => i, mouseTiltAdjust = (i) => i, mouseRollAdjust = (i) => i, window: window$1 = defaultWindow } = options;\n\tconst orientation = reactive(useDeviceOrientation({ window: window$1 }));\n\tconst screenOrientation = reactive(useScreenOrientation({ window: window$1 }));\n\tconst { elementX: x, elementY: y, elementWidth: width, elementHeight: height } = useMouseInElement(target, {\n\t\thandleOutside: false,\n\t\twindow: window$1\n\t});\n\tconst source = computed(() => {\n\t\tif (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0)) return \"deviceOrientation\";\n\t\treturn \"mouse\";\n\t});\n\treturn {\n\t\troll: computed(() => {\n\t\t\tif (source.value === \"deviceOrientation\") {\n\t\t\t\tlet value;\n\t\t\t\tswitch (screenOrientation.orientation) {\n\t\t\t\t\tcase \"landscape-primary\":\n\t\t\t\t\t\tvalue = orientation.gamma / 90;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"landscape-secondary\":\n\t\t\t\t\t\tvalue = -orientation.gamma / 90;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"portrait-primary\":\n\t\t\t\t\t\tvalue = -orientation.beta / 90;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"portrait-secondary\":\n\t\t\t\t\t\tvalue = orientation.beta / 90;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: value = -orientation.beta / 90;\n\t\t\t\t}\n\t\t\t\treturn deviceOrientationRollAdjust(value);\n\t\t\t} else return mouseRollAdjust(-(y.value - height.value / 2) / height.value);\n\t\t}),\n\t\ttilt: computed(() => {\n\t\t\tif (source.value === \"deviceOrientation\") {\n\t\t\t\tlet value;\n\t\t\t\tswitch (screenOrientation.orientation) {\n\t\t\t\t\tcase \"landscape-primary\":\n\t\t\t\t\t\tvalue = orientation.beta / 90;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"landscape-secondary\":\n\t\t\t\t\t\tvalue = -orientation.beta / 90;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"portrait-primary\":\n\t\t\t\t\t\tvalue = orientation.gamma / 90;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"portrait-secondary\":\n\t\t\t\t\t\tvalue = -orientation.gamma / 90;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: value = orientation.gamma / 90;\n\t\t\t\t}\n\t\t\t\treturn deviceOrientationTiltAdjust(value);\n\t\t\t} else return mouseTiltAdjust((x.value - width.value / 2) / width.value);\n\t\t}),\n\t\tsource\n\t};\n}\n\n//#endregion\n//#region useParentElement/index.ts\nfunction useParentElement(element = useCurrentElement()) {\n\tconst parentElement = shallowRef();\n\tconst update = () => {\n\t\tconst el = unrefElement(element);\n\t\tif (el) parentElement.value = el.parentElement;\n\t};\n\ttryOnMounted(update);\n\twatch(() => toValue(element), update);\n\treturn parentElement;\n}\n\n//#endregion\n//#region usePerformanceObserver/index.ts\n/**\n* Observe performance metrics.\n*\n* @see https://vueuse.org/usePerformanceObserver\n* @param options\n*/\nfunction usePerformanceObserver(options, callback) {\n\tconst { window: window$1 = defaultWindow, immediate = true,...performanceOptions } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => window$1 && \"PerformanceObserver\" in window$1);\n\tlet observer;\n\tconst stop = () => {\n\t\tobserver === null || observer === void 0 || observer.disconnect();\n\t};\n\tconst start = () => {\n\t\tif (isSupported.value) {\n\t\t\tstop();\n\t\t\tobserver = new PerformanceObserver(callback);\n\t\t\tobserver.observe(performanceOptions);\n\t\t}\n\t};\n\ttryOnScopeDispose(stop);\n\tif (immediate) start();\n\treturn {\n\t\tisSupported,\n\t\tstart,\n\t\tstop\n\t};\n}\n\n//#endregion\n//#region usePointer/index.ts\nconst defaultState = {\n\tx: 0,\n\ty: 0,\n\tpointerId: 0,\n\tpressure: 0,\n\ttiltX: 0,\n\ttiltY: 0,\n\twidth: 0,\n\theight: 0,\n\ttwist: 0,\n\tpointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\n/**\n* Reactive pointer state.\n*\n* @see https://vueuse.org/usePointer\n* @param options\n*/\nfunction usePointer(options = {}) {\n\tconst { target = defaultWindow } = options;\n\tconst isInside = shallowRef(false);\n\tconst state = shallowRef(options.initialValue || {});\n\tObject.assign(state.value, defaultState, state.value);\n\tconst handler = (event) => {\n\t\tisInside.value = true;\n\t\tif (options.pointerTypes && !options.pointerTypes.includes(event.pointerType)) return;\n\t\tstate.value = objectPick(event, keys, false);\n\t};\n\tif (target) {\n\t\tconst listenerOptions = { passive: true };\n\t\tuseEventListener(target, [\n\t\t\t\"pointerdown\",\n\t\t\t\"pointermove\",\n\t\t\t\"pointerup\"\n\t\t], handler, listenerOptions);\n\t\tuseEventListener(target, \"pointerleave\", () => isInside.value = false, listenerOptions);\n\t}\n\treturn {\n\t\t...toRefs(state),\n\t\tisInside\n\t};\n}\n\n//#endregion\n//#region usePointerLock/index.ts\n/**\n* Reactive pointer lock.\n*\n* @see https://vueuse.org/usePointerLock\n* @param target\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction usePointerLock(target, options = {}) {\n\tconst { document: document$1 = defaultDocument } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => document$1 && \"pointerLockElement\" in document$1);\n\tconst element = shallowRef();\n\tconst triggerElement = shallowRef();\n\tlet targetElement;\n\tif (isSupported.value) {\n\t\tconst listenerOptions = { passive: true };\n\t\tuseEventListener(document$1, \"pointerlockchange\", () => {\n\t\t\tvar _pointerLockElement;\n\t\t\tconst currentElement = (_pointerLockElement = document$1.pointerLockElement) !== null && _pointerLockElement !== void 0 ? _pointerLockElement : element.value;\n\t\t\tif (targetElement && currentElement === targetElement) {\n\t\t\t\telement.value = document$1.pointerLockElement;\n\t\t\t\tif (!element.value) targetElement = triggerElement.value = null;\n\t\t\t}\n\t\t}, listenerOptions);\n\t\tuseEventListener(document$1, \"pointerlockerror\", () => {\n\t\t\tvar _pointerLockElement2;\n\t\t\tconst currentElement = (_pointerLockElement2 = document$1.pointerLockElement) !== null && _pointerLockElement2 !== void 0 ? _pointerLockElement2 : element.value;\n\t\t\tif (targetElement && currentElement === targetElement) {\n\t\t\t\tconst action = document$1.pointerLockElement ? \"release\" : \"acquire\";\n\t\t\t\tthrow new Error(`Failed to ${action} pointer lock.`);\n\t\t\t}\n\t\t}, listenerOptions);\n\t}\n\tasync function lock(e) {\n\t\tvar _unrefElement;\n\t\tif (!isSupported.value) throw new Error(\"Pointer Lock API is not supported by your browser.\");\n\t\ttriggerElement.value = e instanceof Event ? e.currentTarget : null;\n\t\ttargetElement = e instanceof Event ? (_unrefElement = unrefElement(target)) !== null && _unrefElement !== void 0 ? _unrefElement : triggerElement.value : unrefElement(e);\n\t\tif (!targetElement) throw new Error(\"Target element undefined.\");\n\t\ttargetElement.requestPointerLock();\n\t\treturn await until(element).toBe(targetElement);\n\t}\n\tasync function unlock() {\n\t\tif (!element.value) return false;\n\t\tdocument$1.exitPointerLock();\n\t\tawait until(element).toBeNull();\n\t\treturn true;\n\t}\n\treturn {\n\t\tisSupported,\n\t\telement,\n\t\ttriggerElement,\n\t\tlock,\n\t\tunlock\n\t};\n}\n\n//#endregion\n//#region usePointerSwipe/index.ts\n/**\n* Reactive swipe detection based on PointerEvents.\n*\n* @see https://vueuse.org/usePointerSwipe\n* @param target\n* @param options\n*/\nfunction usePointerSwipe(target, options = {}) {\n\tconst targetRef = toRef(target);\n\tconst { threshold = 50, onSwipe, onSwipeEnd, onSwipeStart, disableTextSelect = false } = options;\n\tconst posStart = reactive({\n\t\tx: 0,\n\t\ty: 0\n\t});\n\tconst updatePosStart = (x, y) => {\n\t\tposStart.x = x;\n\t\tposStart.y = y;\n\t};\n\tconst posEnd = reactive({\n\t\tx: 0,\n\t\ty: 0\n\t});\n\tconst updatePosEnd = (x, y) => {\n\t\tposEnd.x = x;\n\t\tposEnd.y = y;\n\t};\n\tconst distanceX = computed(() => posStart.x - posEnd.x);\n\tconst distanceY = computed(() => posStart.y - posEnd.y);\n\tconst { max, abs } = Math;\n\tconst isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n\tconst isSwiping = shallowRef(false);\n\tconst isPointerDown = shallowRef(false);\n\tconst direction = computed(() => {\n\t\tif (!isThresholdExceeded.value) return \"none\";\n\t\tif (abs(distanceX.value) > abs(distanceY.value)) return distanceX.value > 0 ? \"left\" : \"right\";\n\t\telse return distanceY.value > 0 ? \"up\" : \"down\";\n\t});\n\tconst eventIsAllowed = (e) => {\n\t\tvar _ref, _options$pointerTypes, _options$pointerTypes2;\n\t\tconst isReleasingButton = e.buttons === 0;\n\t\tconst isPrimaryButton = e.buttons === 1;\n\t\treturn (_ref = (_options$pointerTypes = (_options$pointerTypes2 = options.pointerTypes) === null || _options$pointerTypes2 === void 0 ? void 0 : _options$pointerTypes2.includes(e.pointerType)) !== null && _options$pointerTypes !== void 0 ? _options$pointerTypes : isReleasingButton || isPrimaryButton) !== null && _ref !== void 0 ? _ref : true;\n\t};\n\tconst listenerOptions = { passive: true };\n\tconst stops = [\n\t\tuseEventListener(target, \"pointerdown\", (e) => {\n\t\t\tif (!eventIsAllowed(e)) return;\n\t\t\tisPointerDown.value = true;\n\t\t\tconst eventTarget = e.target;\n\t\t\teventTarget === null || eventTarget === void 0 || eventTarget.setPointerCapture(e.pointerId);\n\t\t\tconst { clientX: x, clientY: y } = e;\n\t\t\tupdatePosStart(x, y);\n\t\t\tupdatePosEnd(x, y);\n\t\t\tonSwipeStart === null || onSwipeStart === void 0 || onSwipeStart(e);\n\t\t}, listenerOptions),\n\t\tuseEventListener(target, \"pointermove\", (e) => {\n\t\t\tif (!eventIsAllowed(e)) return;\n\t\t\tif (!isPointerDown.value) return;\n\t\t\tconst { clientX: x, clientY: y } = e;\n\t\t\tupdatePosEnd(x, y);\n\t\t\tif (!isSwiping.value && isThresholdExceeded.value) isSwiping.value = true;\n\t\t\tif (isSwiping.value) onSwipe === null || onSwipe === void 0 || onSwipe(e);\n\t\t}, listenerOptions),\n\t\tuseEventListener(target, \"pointerup\", (e) => {\n\t\t\tif (!eventIsAllowed(e)) return;\n\t\t\tif (isSwiping.value) onSwipeEnd === null || onSwipeEnd === void 0 || onSwipeEnd(e, direction.value);\n\t\t\tisPointerDown.value = false;\n\t\t\tisSwiping.value = false;\n\t\t}, listenerOptions)\n\t];\n\ttryOnMounted(() => {\n\t\tvar _targetRef$value;\n\t\t(_targetRef$value = targetRef.value) === null || _targetRef$value === void 0 || (_targetRef$value = _targetRef$value.style) === null || _targetRef$value === void 0 || _targetRef$value.setProperty(\"touch-action\", \"pan-y\");\n\t\tif (disableTextSelect) {\n\t\t\tvar _targetRef$value2, _targetRef$value3, _targetRef$value4;\n\t\t\t(_targetRef$value2 = targetRef.value) === null || _targetRef$value2 === void 0 || (_targetRef$value2 = _targetRef$value2.style) === null || _targetRef$value2 === void 0 || _targetRef$value2.setProperty(\"-webkit-user-select\", \"none\");\n\t\t\t(_targetRef$value3 = targetRef.value) === null || _targetRef$value3 === void 0 || (_targetRef$value3 = _targetRef$value3.style) === null || _targetRef$value3 === void 0 || _targetRef$value3.setProperty(\"-ms-user-select\", \"none\");\n\t\t\t(_targetRef$value4 = targetRef.value) === null || _targetRef$value4 === void 0 || (_targetRef$value4 = _targetRef$value4.style) === null || _targetRef$value4 === void 0 || _targetRef$value4.setProperty(\"user-select\", \"none\");\n\t\t}\n\t});\n\tconst stop = () => stops.forEach((s) => s());\n\treturn {\n\t\tisSwiping: readonly(isSwiping),\n\t\tdirection: readonly(direction),\n\t\tposStart: readonly(posStart),\n\t\tposEnd: readonly(posEnd),\n\t\tdistanceX,\n\t\tdistanceY,\n\t\tstop\n\t};\n}\n\n//#endregion\n//#region usePreferredColorScheme/index.ts\n/**\n* Reactive prefers-color-scheme media query.\n*\n* @see https://vueuse.org/usePreferredColorScheme\n* @param [options]\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction usePreferredColorScheme(options) {\n\tconst isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n\tconst isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n\treturn computed(() => {\n\t\tif (isDark.value) return \"dark\";\n\t\tif (isLight.value) return \"light\";\n\t\treturn \"no-preference\";\n\t});\n}\n\n//#endregion\n//#region usePreferredContrast/index.ts\n/**\n* Reactive prefers-contrast media query.\n*\n* @see https://vueuse.org/usePreferredContrast\n* @param [options]\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction usePreferredContrast(options) {\n\tconst isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n\tconst isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n\tconst isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n\treturn computed(() => {\n\t\tif (isMore.value) return \"more\";\n\t\tif (isLess.value) return \"less\";\n\t\tif (isCustom.value) return \"custom\";\n\t\treturn \"no-preference\";\n\t});\n}\n\n//#endregion\n//#region usePreferredLanguages/index.ts\n/**\n* Reactive Navigator Languages.\n*\n* @see https://vueuse.org/usePreferredLanguages\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction usePreferredLanguages(options = {}) {\n\tconst { window: window$1 = defaultWindow } = options;\n\tif (!window$1) return shallowRef([\"en\"]);\n\tconst navigator$1 = window$1.navigator;\n\tconst value = shallowRef(navigator$1.languages);\n\tuseEventListener(window$1, \"languagechange\", () => {\n\t\tvalue.value = navigator$1.languages;\n\t}, { passive: true });\n\treturn value;\n}\n\n//#endregion\n//#region usePreferredReducedMotion/index.ts\n/**\n* Reactive prefers-reduced-motion media query.\n*\n* @see https://vueuse.org/usePreferredReducedMotion\n* @param [options]\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction usePreferredReducedMotion(options) {\n\tconst isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n\treturn computed(() => {\n\t\tif (isReduced.value) return \"reduce\";\n\t\treturn \"no-preference\";\n\t});\n}\n\n//#endregion\n//#region usePreferredReducedTransparency/index.ts\n/**\n* Reactive prefers-reduced-transparency media query.\n*\n* @see https://vueuse.org/usePreferredReducedTransparency\n* @param [options]\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction usePreferredReducedTransparency(options) {\n\tconst isReduced = useMediaQuery(\"(prefers-reduced-transparency: reduce)\", options);\n\treturn computed(() => {\n\t\tif (isReduced.value) return \"reduce\";\n\t\treturn \"no-preference\";\n\t});\n}\n\n//#endregion\n//#region usePrevious/index.ts\nfunction usePrevious(value, initialValue) {\n\tconst previous = shallowRef(initialValue);\n\twatch(toRef(value), (_, oldValue) => {\n\t\tprevious.value = oldValue;\n\t}, { flush: \"sync\" });\n\treturn readonly(previous);\n}\n\n//#endregion\n//#region useScreenSafeArea/index.ts\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\n/**\n* Reactive `env(safe-area-inset-*)`\n*\n* @see https://vueuse.org/useScreenSafeArea\n*/\nfunction useScreenSafeArea() {\n\tconst top = shallowRef(\"\");\n\tconst right = shallowRef(\"\");\n\tconst bottom = shallowRef(\"\");\n\tconst left = shallowRef(\"\");\n\tif (isClient) {\n\t\tconst topCssVar = useCssVar(topVarName);\n\t\tconst rightCssVar = useCssVar(rightVarName);\n\t\tconst bottomCssVar = useCssVar(bottomVarName);\n\t\tconst leftCssVar = useCssVar(leftVarName);\n\t\ttopCssVar.value = \"env(safe-area-inset-top, 0px)\";\n\t\trightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n\t\tbottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n\t\tleftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n\t\ttryOnMounted(update);\n\t\tuseEventListener(\"resize\", useDebounceFn(update), { passive: true });\n\t}\n\tfunction update() {\n\t\ttop.value = getValue(topVarName);\n\t\tright.value = getValue(rightVarName);\n\t\tbottom.value = getValue(bottomVarName);\n\t\tleft.value = getValue(leftVarName);\n\t}\n\treturn {\n\t\ttop,\n\t\tright,\n\t\tbottom,\n\t\tleft,\n\t\tupdate\n\t};\n}\nfunction getValue(position) {\n\treturn getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\n//#endregion\n//#region useScriptTag/index.ts\n/**\n* Async script tag loading.\n*\n* @see https://vueuse.org/useScriptTag\n* @param src\n* @param onLoaded\n* @param options\n*/\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n\tconst { immediate = true, manual = false, type = \"text/javascript\", async = true, crossOrigin, referrerPolicy, noModule, defer, document: document$1 = defaultDocument, attrs = {}, nonce = void 0 } = options;\n\tconst scriptTag = shallowRef(null);\n\tlet _promise = null;\n\t/**\n\t* Load the script specified via `src`.\n\t*\n\t* @param waitForScriptLoad Whether if the Promise should resolve once the \"load\" event is emitted by the <script> attribute, or right after appending it to the DOM.\n\t* @returns Promise<HTMLScriptElement>\n\t*/\n\tconst loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n\t\tconst resolveWithElement = (el$1) => {\n\t\t\tscriptTag.value = el$1;\n\t\t\tresolve(el$1);\n\t\t\treturn el$1;\n\t\t};\n\t\tif (!document$1) {\n\t\t\tresolve(false);\n\t\t\treturn;\n\t\t}\n\t\tlet shouldAppend = false;\n\t\tlet el = document$1.querySelector(`script[src=\"${toValue(src)}\"]`);\n\t\tif (!el) {\n\t\t\tel = document$1.createElement(\"script\");\n\t\t\tel.type = type;\n\t\t\tel.async = async;\n\t\t\tel.src = toValue(src);\n\t\t\tif (defer) el.defer = defer;\n\t\t\tif (crossOrigin) el.crossOrigin = crossOrigin;\n\t\t\tif (noModule) el.noModule = noModule;\n\t\t\tif (referrerPolicy) el.referrerPolicy = referrerPolicy;\n\t\t\tif (nonce) el.nonce = nonce;\n\t\t\tObject.entries(attrs).forEach(([name, value]) => el === null || el === void 0 ? void 0 : el.setAttribute(name, value));\n\t\t\tshouldAppend = true;\n\t\t} else if (el.hasAttribute(\"data-loaded\")) resolveWithElement(el);\n\t\tconst listenerOptions = { passive: true };\n\t\tuseEventListener(el, \"error\", (event) => reject(event), listenerOptions);\n\t\tuseEventListener(el, \"abort\", (event) => reject(event), listenerOptions);\n\t\tuseEventListener(el, \"load\", () => {\n\t\t\tel.setAttribute(\"data-loaded\", \"true\");\n\t\t\tonLoaded(el);\n\t\t\tresolveWithElement(el);\n\t\t}, listenerOptions);\n\t\tif (shouldAppend) el = document$1.head.appendChild(el);\n\t\tif (!waitForScriptLoad) resolveWithElement(el);\n\t});\n\t/**\n\t* Exposed singleton wrapper for `loadScript`, avoiding calling it twice.\n\t*\n\t* @param waitForScriptLoad Whether if the Promise should resolve once the \"load\" event is emitted by the <script> attribute, or right after appending it to the DOM.\n\t* @returns Promise<HTMLScriptElement>\n\t*/\n\tconst load = (waitForScriptLoad = true) => {\n\t\tif (!_promise) _promise = loadScript(waitForScriptLoad);\n\t\treturn _promise;\n\t};\n\t/**\n\t* Unload the script specified by `src`.\n\t*/\n\tconst unload = () => {\n\t\tif (!document$1) return;\n\t\t_promise = null;\n\t\tif (scriptTag.value) scriptTag.value = null;\n\t\tconst el = document$1.querySelector(`script[src=\"${toValue(src)}\"]`);\n\t\tif (el) document$1.head.removeChild(el);\n\t};\n\tif (immediate && !manual) tryOnMounted(load);\n\tif (!manual) tryOnUnmounted(unload);\n\treturn {\n\t\tscriptTag,\n\t\tload,\n\t\tunload\n\t};\n}\n\n//#endregion\n//#region useScrollLock/index.ts\nfunction checkOverflowScroll(ele) {\n\tconst style = window.getComputedStyle(ele);\n\tif (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientWidth < ele.scrollWidth || style.overflowY === \"auto\" && ele.clientHeight < ele.scrollHeight) return true;\n\telse {\n\t\tconst parent = ele.parentNode;\n\t\tif (!parent || parent.tagName === \"BODY\") return false;\n\t\treturn checkOverflowScroll(parent);\n\t}\n}\nfunction preventDefault(rawEvent) {\n\tconst e = rawEvent || window.event;\n\tconst _target = e.target;\n\tif (checkOverflowScroll(_target)) return false;\n\tif (e.touches.length > 1) return true;\n\tif (e.preventDefault) e.preventDefault();\n\treturn false;\n}\nconst elInitialOverflow = /* @__PURE__ */ new WeakMap();\n/**\n* Lock scrolling of the element.\n*\n* @see https://vueuse.org/useScrollLock\n* @param element\n*/\nfunction useScrollLock(element, initialState = false) {\n\tconst isLocked = shallowRef(initialState);\n\tlet stopTouchMoveListener = null;\n\tlet initialOverflow = \"\";\n\twatch(toRef(element), (el) => {\n\t\tconst target = resolveElement(toValue(el));\n\t\tif (target) {\n\t\t\tconst ele = target;\n\t\t\tif (!elInitialOverflow.get(ele)) elInitialOverflow.set(ele, ele.style.overflow);\n\t\t\tif (ele.style.overflow !== \"hidden\") initialOverflow = ele.style.overflow;\n\t\t\tif (ele.style.overflow === \"hidden\") return isLocked.value = true;\n\t\t\tif (isLocked.value) return ele.style.overflow = \"hidden\";\n\t\t}\n\t}, { immediate: true });\n\tconst lock = () => {\n\t\tconst el = resolveElement(toValue(element));\n\t\tif (!el || isLocked.value) return;\n\t\tif (isIOS) stopTouchMoveListener = useEventListener(el, \"touchmove\", (e) => {\n\t\t\tpreventDefault(e);\n\t\t}, { passive: false });\n\t\tel.style.overflow = \"hidden\";\n\t\tisLocked.value = true;\n\t};\n\tconst unlock = () => {\n\t\tconst el = resolveElement(toValue(element));\n\t\tif (!el || !isLocked.value) return;\n\t\tif (isIOS) stopTouchMoveListener === null || stopTouchMoveListener === void 0 || stopTouchMoveListener();\n\t\tel.style.overflow = initialOverflow;\n\t\telInitialOverflow.delete(el);\n\t\tisLocked.value = false;\n\t};\n\ttryOnScopeDispose(unlock);\n\treturn computed({\n\t\tget() {\n\t\t\treturn isLocked.value;\n\t\t},\n\t\tset(v) {\n\t\t\tif (v) lock();\n\t\t\telse unlock();\n\t\t}\n\t});\n}\n\n//#endregion\n//#region useSessionStorage/index.ts\n/**\n* Reactive SessionStorage.\n*\n* @see https://vueuse.org/useSessionStorage\n* @param key\n* @param initialValue\n* @param options\n*/\nfunction useSessionStorage(key, initialValue, options = {}) {\n\tconst { window: window$1 = defaultWindow } = options;\n\treturn useStorage(key, initialValue, window$1 === null || window$1 === void 0 ? void 0 : window$1.sessionStorage, options);\n}\n\n//#endregion\n//#region useShare/index.ts\n/**\n* Reactive Web Share API.\n*\n* @see https://vueuse.org/useShare\n* @param shareOptions\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useShare(shareOptions = {}, options = {}) {\n\tconst { navigator: navigator$1 = defaultNavigator } = options;\n\tconst _navigator = navigator$1;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => _navigator && \"canShare\" in _navigator);\n\tconst share = async (overrideOptions = {}) => {\n\t\tif (isSupported.value) {\n\t\t\tconst data = {\n\t\t\t\t...toValue(shareOptions),\n\t\t\t\t...toValue(overrideOptions)\n\t\t\t};\n\t\t\tlet granted = false;\n\t\t\tif (_navigator.canShare) granted = _navigator.canShare(data);\n\t\t\tif (granted) return _navigator.share(data);\n\t\t}\n\t};\n\treturn {\n\t\tisSupported,\n\t\tshare\n\t};\n}\n\n//#endregion\n//#region useSorted/index.ts\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n\tconst [source] = args;\n\tlet compareFn = defaultCompare;\n\tlet options = {};\n\tif (args.length === 2) if (typeof args[1] === \"object\") {\n\t\tvar _options$compareFn;\n\t\toptions = args[1];\n\t\tcompareFn = (_options$compareFn = options.compareFn) !== null && _options$compareFn !== void 0 ? _options$compareFn : defaultCompare;\n\t} else {\n\t\tvar _args$;\n\t\tcompareFn = (_args$ = args[1]) !== null && _args$ !== void 0 ? _args$ : defaultCompare;\n\t}\n\telse if (args.length > 2) {\n\t\tvar _args$2, _args$3;\n\t\tcompareFn = (_args$2 = args[1]) !== null && _args$2 !== void 0 ? _args$2 : defaultCompare;\n\t\toptions = (_args$3 = args[2]) !== null && _args$3 !== void 0 ? _args$3 : {};\n\t}\n\tconst { dirty = false, sortFn = defaultSortFn } = options;\n\tif (!dirty) return computed(() => sortFn([...toValue(source)], compareFn));\n\twatchEffect(() => {\n\t\tconst result = sortFn(toValue(source), compareFn);\n\t\tif (isRef(source)) source.value = result;\n\t\telse source.splice(0, source.length, ...result);\n\t});\n\treturn source;\n}\n\n//#endregion\n//#region useSpeechRecognition/index.ts\n/**\n* Reactive SpeechRecognition.\n*\n* @see https://vueuse.org/useSpeechRecognition\n* @see https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition SpeechRecognition\n* @param options\n*/\nfunction useSpeechRecognition(options = {}) {\n\tconst { interimResults = true, continuous = true, maxAlternatives = 1, window: window$1 = defaultWindow } = options;\n\tconst lang = toRef(options.lang || \"en-US\");\n\tconst isListening = shallowRef(false);\n\tconst isFinal = shallowRef(false);\n\tconst result = shallowRef(\"\");\n\tconst error = shallowRef(void 0);\n\tlet recognition;\n\tconst start = () => {\n\t\tisListening.value = true;\n\t};\n\tconst stop = () => {\n\t\tisListening.value = false;\n\t};\n\tconst toggle = (value = !isListening.value) => {\n\t\tif (value) start();\n\t\telse stop();\n\t};\n\tconst SpeechRecognition = window$1 && (window$1.SpeechRecognition || window$1.webkitSpeechRecognition);\n\tconst isSupported = /* @__PURE__ */ useSupported(() => SpeechRecognition);\n\tif (isSupported.value) {\n\t\trecognition = new SpeechRecognition();\n\t\trecognition.continuous = continuous;\n\t\trecognition.interimResults = interimResults;\n\t\trecognition.lang = toValue(lang);\n\t\trecognition.maxAlternatives = maxAlternatives;\n\t\trecognition.onstart = () => {\n\t\t\tisListening.value = true;\n\t\t\tisFinal.value = false;\n\t\t};\n\t\twatch(lang, (lang$1) => {\n\t\t\tif (recognition && !isListening.value) recognition.lang = lang$1;\n\t\t});\n\t\trecognition.onresult = (event) => {\n\t\t\tconst currentResult = event.results[event.resultIndex];\n\t\t\tconst { transcript } = currentResult[0];\n\t\t\tisFinal.value = currentResult.isFinal;\n\t\t\tresult.value = transcript;\n\t\t\terror.value = void 0;\n\t\t};\n\t\trecognition.onerror = (event) => {\n\t\t\terror.value = event;\n\t\t};\n\t\trecognition.onend = () => {\n\t\t\tisListening.value = false;\n\t\t\trecognition.lang = toValue(lang);\n\t\t};\n\t\twatch(isListening, (newValue, oldValue) => {\n\t\t\tif (newValue === oldValue) return;\n\t\t\ttry {\n\t\t\t\tif (newValue) recognition.start();\n\t\t\t\telse recognition.stop();\n\t\t\t} catch (err) {\n\t\t\t\terror.value = err;\n\t\t\t}\n\t\t});\n\t}\n\ttryOnScopeDispose(() => {\n\t\tstop();\n\t});\n\treturn {\n\t\tisSupported,\n\t\tisListening,\n\t\tisFinal,\n\t\trecognition,\n\t\tresult,\n\t\terror,\n\t\ttoggle,\n\t\tstart,\n\t\tstop\n\t};\n}\n\n//#endregion\n//#region useSpeechSynthesis/index.ts\n/**\n* Reactive SpeechSynthesis.\n*\n* @see https://vueuse.org/useSpeechSynthesis\n* @see https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis SpeechSynthesis\n*/\nfunction useSpeechSynthesis(text, options = {}) {\n\tconst { pitch = 1, rate = 1, volume = 1, window: window$1 = defaultWindow, onBoundary } = options;\n\tconst synth = window$1 && window$1.speechSynthesis;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => synth);\n\tconst isPlaying = shallowRef(false);\n\tconst status = shallowRef(\"init\");\n\tconst spokenText = toRef(text || \"\");\n\tconst lang = toRef(options.lang || \"en-US\");\n\tconst error = shallowRef(void 0);\n\tconst toggle = (value = !isPlaying.value) => {\n\t\tisPlaying.value = value;\n\t};\n\tconst bindEventsForUtterance = (utterance$1) => {\n\t\tutterance$1.lang = toValue(lang);\n\t\tutterance$1.voice = toValue(options.voice) || null;\n\t\tutterance$1.pitch = toValue(pitch);\n\t\tutterance$1.rate = toValue(rate);\n\t\tutterance$1.volume = toValue(volume);\n\t\tutterance$1.onstart = () => {\n\t\t\tisPlaying.value = true;\n\t\t\tstatus.value = \"play\";\n\t\t};\n\t\tutterance$1.onpause = () => {\n\t\t\tisPlaying.value = false;\n\t\t\tstatus.value = \"pause\";\n\t\t};\n\t\tutterance$1.onresume = () => {\n\t\t\tisPlaying.value = true;\n\t\t\tstatus.value = \"play\";\n\t\t};\n\t\tutterance$1.onend = () => {\n\t\t\tisPlaying.value = false;\n\t\t\tstatus.value = \"end\";\n\t\t};\n\t\tutterance$1.onerror = (event) => {\n\t\t\terror.value = event;\n\t\t};\n\t\tutterance$1.onboundary = (event) => {\n\t\t\tonBoundary === null || onBoundary === void 0 || onBoundary(event);\n\t\t};\n\t};\n\tconst utterance = computed(() => {\n\t\tisPlaying.value = false;\n\t\tstatus.value = \"init\";\n\t\tconst newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n\t\tbindEventsForUtterance(newUtterance);\n\t\treturn newUtterance;\n\t});\n\tconst speak = () => {\n\t\tsynth.cancel();\n\t\tif (utterance) synth.speak(utterance.value);\n\t};\n\tconst stop = () => {\n\t\tsynth.cancel();\n\t\tisPlaying.value = false;\n\t};\n\tif (isSupported.value) {\n\t\tbindEventsForUtterance(utterance.value);\n\t\twatch(lang, (lang$1) => {\n\t\t\tif (utterance.value && !isPlaying.value) utterance.value.lang = lang$1;\n\t\t});\n\t\tif (options.voice) watch(options.voice, () => {\n\t\t\tsynth.cancel();\n\t\t});\n\t\twatch(isPlaying, () => {\n\t\t\tif (isPlaying.value) synth.resume();\n\t\t\telse synth.pause();\n\t\t});\n\t}\n\ttryOnScopeDispose(() => {\n\t\tisPlaying.value = false;\n\t});\n\treturn {\n\t\tisSupported,\n\t\tisPlaying,\n\t\tstatus,\n\t\tutterance,\n\t\terror,\n\t\tstop,\n\t\ttoggle,\n\t\tspeak\n\t};\n}\n\n//#endregion\n//#region useStepper/index.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction useStepper(steps, initialStep) {\n\tconst stepsRef = ref(steps);\n\tconst stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n\tconst index = ref(stepNames.value.indexOf(initialStep !== null && initialStep !== void 0 ? initialStep : stepNames.value[0]));\n\tconst current = computed(() => at(index.value));\n\tconst isFirst = computed(() => index.value === 0);\n\tconst isLast = computed(() => index.value === stepNames.value.length - 1);\n\tconst next = computed(() => stepNames.value[index.value + 1]);\n\tconst previous = computed(() => stepNames.value[index.value - 1]);\n\tfunction at(index$1) {\n\t\tif (Array.isArray(stepsRef.value)) return stepsRef.value[index$1];\n\t\treturn stepsRef.value[stepNames.value[index$1]];\n\t}\n\tfunction get(step) {\n\t\tif (!stepNames.value.includes(step)) return;\n\t\treturn at(stepNames.value.indexOf(step));\n\t}\n\tfunction goTo(step) {\n\t\tif (stepNames.value.includes(step)) index.value = stepNames.value.indexOf(step);\n\t}\n\tfunction goToNext() {\n\t\tif (isLast.value) return;\n\t\tindex.value++;\n\t}\n\tfunction goToPrevious() {\n\t\tif (isFirst.value) return;\n\t\tindex.value--;\n\t}\n\tfunction goBackTo(step) {\n\t\tif (isAfter(step)) goTo(step);\n\t}\n\tfunction isNext(step) {\n\t\treturn stepNames.value.indexOf(step) === index.value + 1;\n\t}\n\tfunction isPrevious(step) {\n\t\treturn stepNames.value.indexOf(step) === index.value - 1;\n\t}\n\tfunction isCurrent(step) {\n\t\treturn stepNames.value.indexOf(step) === index.value;\n\t}\n\tfunction isBefore(step) {\n\t\treturn index.value < stepNames.value.indexOf(step);\n\t}\n\tfunction isAfter(step) {\n\t\treturn index.value > stepNames.value.indexOf(step);\n\t}\n\treturn {\n\t\tsteps: stepsRef,\n\t\tstepNames,\n\t\tindex,\n\t\tcurrent,\n\t\tnext,\n\t\tprevious,\n\t\tisFirst,\n\t\tisLast,\n\t\tat,\n\t\tget,\n\t\tgoTo,\n\t\tgoToNext,\n\t\tgoToPrevious,\n\t\tgoBackTo,\n\t\tisNext,\n\t\tisPrevious,\n\t\tisCurrent,\n\t\tisBefore,\n\t\tisAfter\n\t};\n}\n\n//#endregion\n//#region useStorageAsync/index.ts\n/**\n* Reactive Storage in with async support.\n*\n* @see https://vueuse.org/useStorageAsync\n* @param key\n* @param initialValue\n* @param storage\n* @param options\n*/\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n\tvar _options$serializer;\n\tconst { flush = \"pre\", deep = true, listenToStorageChanges = true, writeDefaults = true, mergeDefaults = false, shallow, window: window$1 = defaultWindow, eventFilter, onError = (e) => {\n\t\tconsole.error(e);\n\t}, onReady } = options;\n\tconst rawInit = toValue(initialValue);\n\tconst type = guessSerializerType(rawInit);\n\tconst data = (shallow ? shallowRef : ref)(toValue(initialValue));\n\tconst serializer = (_options$serializer = options.serializer) !== null && _options$serializer !== void 0 ? _options$serializer : StorageSerializers[type];\n\tif (!storage) try {\n\t\tstorage = getSSRHandler(\"getDefaultStorageAsync\", () => defaultWindow === null || defaultWindow === void 0 ? void 0 : defaultWindow.localStorage)();\n\t} catch (e) {\n\t\tonError(e);\n\t}\n\tasync function read(event) {\n\t\tif (!storage || event && event.key !== key) return;\n\t\ttry {\n\t\t\tconst rawValue = event ? event.newValue : await storage.getItem(key);\n\t\t\tif (rawValue == null) {\n\t\t\t\tdata.value = rawInit;\n\t\t\t\tif (writeDefaults && rawInit !== null) await storage.setItem(key, await serializer.write(rawInit));\n\t\t\t} else if (mergeDefaults) {\n\t\t\t\tconst value = await serializer.read(rawValue);\n\t\t\t\tif (typeof mergeDefaults === \"function\") data.value = mergeDefaults(value, rawInit);\n\t\t\t\telse if (type === \"object\" && !Array.isArray(value)) data.value = {\n\t\t\t\t\t...rawInit,\n\t\t\t\t\t...value\n\t\t\t\t};\n\t\t\t\telse data.value = value;\n\t\t\t} else data.value = await serializer.read(rawValue);\n\t\t} catch (e) {\n\t\t\tonError(e);\n\t\t}\n\t}\n\tconst promise = new Promise((resolve) => {\n\t\tread().then(() => {\n\t\t\tonReady === null || onReady === void 0 || onReady(data.value);\n\t\t\tresolve(data);\n\t\t});\n\t});\n\tif (window$1 && listenToStorageChanges) useEventListener(window$1, \"storage\", (e) => Promise.resolve().then(() => read(e)), { passive: true });\n\tif (storage) watchWithFilter(data, async () => {\n\t\ttry {\n\t\t\tif (data.value == null) await storage.removeItem(key);\n\t\t\telse await storage.setItem(key, await serializer.write(data.value));\n\t\t} catch (e) {\n\t\t\tonError(e);\n\t\t}\n\t}, {\n\t\tflush,\n\t\tdeep,\n\t\teventFilter\n\t});\n\tObject.assign(data, {\n\t\tthen: promise.then.bind(promise),\n\t\tcatch: promise.catch.bind(promise)\n\t});\n\treturn data;\n}\n\n//#endregion\n//#region useStyleTag/index.ts\nlet _id = 0;\n/**\n* Inject <style> element in head.\n*\n* Overload: Omitted id\n*\n* @see https://vueuse.org/useStyleTag\n* @param css\n* @param options\n*/\nfunction useStyleTag(css, options = {}) {\n\tconst isLoaded = shallowRef(false);\n\tconst { document: document$1 = defaultDocument, immediate = true, manual = false, id = `vueuse_styletag_${++_id}` } = options;\n\tconst cssRef = shallowRef(css);\n\tlet stop = () => {};\n\tconst load = () => {\n\t\tif (!document$1) return;\n\t\tconst el = document$1.getElementById(id) || document$1.createElement(\"style\");\n\t\tif (!el.isConnected) {\n\t\t\tel.id = id;\n\t\t\tif (options.nonce) el.nonce = options.nonce;\n\t\t\tif (options.media) el.media = options.media;\n\t\t\tdocument$1.head.appendChild(el);\n\t\t}\n\t\tif (isLoaded.value) return;\n\t\tstop = watch(cssRef, (value) => {\n\t\t\tel.textContent = value;\n\t\t}, { immediate: true });\n\t\tisLoaded.value = true;\n\t};\n\tconst unload = () => {\n\t\tif (!document$1 || !isLoaded.value) return;\n\t\tstop();\n\t\tdocument$1.head.removeChild(document$1.getElementById(id));\n\t\tisLoaded.value = false;\n\t};\n\tif (immediate && !manual) tryOnMounted(load);\n\tif (!manual) tryOnScopeDispose(unload);\n\treturn {\n\t\tid,\n\t\tcss: cssRef,\n\t\tunload,\n\t\tload,\n\t\tisLoaded: readonly(isLoaded)\n\t};\n}\n\n//#endregion\n//#region useSwipe/index.ts\n/**\n* Reactive swipe detection.\n*\n* @see https://vueuse.org/useSwipe\n* @param target\n* @param options\n*/\nfunction useSwipe(target, options = {}) {\n\tconst { threshold = 50, onSwipe, onSwipeEnd, onSwipeStart, passive = true } = options;\n\tconst coordsStart = reactive({\n\t\tx: 0,\n\t\ty: 0\n\t});\n\tconst coordsEnd = reactive({\n\t\tx: 0,\n\t\ty: 0\n\t});\n\tconst diffX = computed(() => coordsStart.x - coordsEnd.x);\n\tconst diffY = computed(() => coordsStart.y - coordsEnd.y);\n\tconst { max, abs } = Math;\n\tconst isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n\tconst isSwiping = shallowRef(false);\n\tconst direction = computed(() => {\n\t\tif (!isThresholdExceeded.value) return \"none\";\n\t\tif (abs(diffX.value) > abs(diffY.value)) return diffX.value > 0 ? \"left\" : \"right\";\n\t\telse return diffY.value > 0 ? \"up\" : \"down\";\n\t});\n\tconst getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n\tconst updateCoordsStart = (x, y) => {\n\t\tcoordsStart.x = x;\n\t\tcoordsStart.y = y;\n\t};\n\tconst updateCoordsEnd = (x, y) => {\n\t\tcoordsEnd.x = x;\n\t\tcoordsEnd.y = y;\n\t};\n\tconst listenerOptions = {\n\t\tpassive,\n\t\tcapture: !passive\n\t};\n\tconst onTouchEnd = (e) => {\n\t\tif (isSwiping.value) onSwipeEnd === null || onSwipeEnd === void 0 || onSwipeEnd(e, direction.value);\n\t\tisSwiping.value = false;\n\t};\n\tconst stops = [\n\t\tuseEventListener(target, \"touchstart\", (e) => {\n\t\t\tif (e.touches.length !== 1) return;\n\t\t\tconst [x, y] = getTouchEventCoords(e);\n\t\t\tupdateCoordsStart(x, y);\n\t\t\tupdateCoordsEnd(x, y);\n\t\t\tonSwipeStart === null || onSwipeStart === void 0 || onSwipeStart(e);\n\t\t}, listenerOptions),\n\t\tuseEventListener(target, \"touchmove\", (e) => {\n\t\t\tif (e.touches.length !== 1) return;\n\t\t\tconst [x, y] = getTouchEventCoords(e);\n\t\t\tupdateCoordsEnd(x, y);\n\t\t\tif (listenerOptions.capture && !listenerOptions.passive && Math.abs(diffX.value) > Math.abs(diffY.value)) e.preventDefault();\n\t\t\tif (!isSwiping.value && isThresholdExceeded.value) isSwiping.value = true;\n\t\t\tif (isSwiping.value) onSwipe === null || onSwipe === void 0 || onSwipe(e);\n\t\t}, listenerOptions),\n\t\tuseEventListener(target, [\"touchend\", \"touchcancel\"], onTouchEnd, listenerOptions)\n\t];\n\tconst stop = () => stops.forEach((s) => s());\n\treturn {\n\t\tisSwiping,\n\t\tdirection,\n\t\tcoordsStart,\n\t\tcoordsEnd,\n\t\tlengthX: diffX,\n\t\tlengthY: diffY,\n\t\tstop\n\t};\n}\n\n//#endregion\n//#region useTemplateRefsList/index.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction useTemplateRefsList() {\n\tconst refs = ref([]);\n\trefs.value.set = (el) => {\n\t\tif (el) refs.value.push(el);\n\t};\n\tonBeforeUpdate(() => {\n\t\trefs.value.length = 0;\n\t});\n\treturn refs;\n}\n\n//#endregion\n//#region useTextDirection/index.ts\n/**\n* Reactive dir of the element's text.\n*\n* @see https://vueuse.org/useTextDirection\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useTextDirection(options = {}) {\n\tconst { document: document$1 = defaultDocument, selector = \"html\", observe = false, initialValue = \"ltr\" } = options;\n\tfunction getValue$1() {\n\t\tvar _ref, _document$querySelect;\n\t\treturn (_ref = document$1 === null || document$1 === void 0 || (_document$querySelect = document$1.querySelector(selector)) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.getAttribute(\"dir\")) !== null && _ref !== void 0 ? _ref : initialValue;\n\t}\n\tconst dir = ref(getValue$1());\n\ttryOnMounted(() => dir.value = getValue$1());\n\tif (observe && document$1) useMutationObserver(document$1.querySelector(selector), () => dir.value = getValue$1(), { attributes: true });\n\treturn computed({\n\t\tget() {\n\t\t\treturn dir.value;\n\t\t},\n\t\tset(v) {\n\t\t\tvar _document$querySelect2, _document$querySelect3;\n\t\t\tdir.value = v;\n\t\t\tif (!document$1) return;\n\t\t\tif (dir.value) (_document$querySelect2 = document$1.querySelector(selector)) === null || _document$querySelect2 === void 0 || _document$querySelect2.setAttribute(\"dir\", dir.value);\n\t\t\telse (_document$querySelect3 = document$1.querySelector(selector)) === null || _document$querySelect3 === void 0 || _document$querySelect3.removeAttribute(\"dir\");\n\t\t}\n\t});\n}\n\n//#endregion\n//#region useTextSelection/index.ts\nfunction getRangesFromSelection(selection) {\n\tvar _selection$rangeCount;\n\tconst rangeCount = (_selection$rangeCount = selection.rangeCount) !== null && _selection$rangeCount !== void 0 ? _selection$rangeCount : 0;\n\treturn Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));\n}\n/**\n* Reactively track user text selection based on [`Window.getSelection`](https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection).\n*\n* @see https://vueuse.org/useTextSelection\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useTextSelection(options = {}) {\n\tvar _window$getSelection;\n\tconst { window: window$1 = defaultWindow } = options;\n\tconst selection = shallowRef((_window$getSelection = window$1 === null || window$1 === void 0 ? void 0 : window$1.getSelection()) !== null && _window$getSelection !== void 0 ? _window$getSelection : null);\n\tconst text = computed(() => {\n\t\tvar _selection$value$toSt, _selection$value;\n\t\treturn (_selection$value$toSt = (_selection$value = selection.value) === null || _selection$value === void 0 ? void 0 : _selection$value.toString()) !== null && _selection$value$toSt !== void 0 ? _selection$value$toSt : \"\";\n\t});\n\tconst ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n\tconst rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n\tfunction onSelectionChange() {\n\t\tselection.value = null;\n\t\tif (window$1) selection.value = window$1.getSelection();\n\t}\n\tif (window$1) useEventListener(window$1.document, \"selectionchange\", onSelectionChange, { passive: true });\n\treturn {\n\t\ttext,\n\t\trects,\n\t\tranges,\n\t\tselection\n\t};\n}\n\n//#endregion\n//#region useTextareaAutosize/index.ts\n/**\n* Call window.requestAnimationFrame(), if not available, just call the function\n*\n* @param window\n* @param fn\n*/\nfunction tryRequestAnimationFrame(window$1 = defaultWindow, fn) {\n\tif (window$1 && typeof window$1.requestAnimationFrame === \"function\") window$1.requestAnimationFrame(fn);\n\telse fn();\n}\nfunction useTextareaAutosize(options = {}) {\n\tvar _options$input, _options$styleProp;\n\tconst { window: window$1 = defaultWindow } = options;\n\tconst textarea = toRef(options === null || options === void 0 ? void 0 : options.element);\n\tconst input = toRef((_options$input = options === null || options === void 0 ? void 0 : options.input) !== null && _options$input !== void 0 ? _options$input : \"\");\n\tconst styleProp = (_options$styleProp = options === null || options === void 0 ? void 0 : options.styleProp) !== null && _options$styleProp !== void 0 ? _options$styleProp : \"height\";\n\tconst textareaScrollHeight = shallowRef(1);\n\tconst textareaOldWidth = shallowRef(0);\n\tfunction triggerResize() {\n\t\tvar _textarea$value;\n\t\tif (!textarea.value) return;\n\t\tlet height = \"\";\n\t\ttextarea.value.style[styleProp] = \"1px\";\n\t\ttextareaScrollHeight.value = (_textarea$value = textarea.value) === null || _textarea$value === void 0 ? void 0 : _textarea$value.scrollHeight;\n\t\tconst _styleTarget = toValue(options === null || options === void 0 ? void 0 : options.styleTarget);\n\t\tif (_styleTarget) _styleTarget.style[styleProp] = `${textareaScrollHeight.value}px`;\n\t\telse height = `${textareaScrollHeight.value}px`;\n\t\ttextarea.value.style[styleProp] = height;\n\t}\n\twatch([input, textarea], () => nextTick(triggerResize), { immediate: true });\n\twatch(textareaScrollHeight, () => {\n\t\tvar _options$onResize;\n\t\treturn options === null || options === void 0 || (_options$onResize = options.onResize) === null || _options$onResize === void 0 ? void 0 : _options$onResize.call(options);\n\t});\n\tuseResizeObserver(textarea, ([{ contentRect }]) => {\n\t\tif (textareaOldWidth.value === contentRect.width) return;\n\t\ttryRequestAnimationFrame(window$1, () => {\n\t\t\ttextareaOldWidth.value = contentRect.width;\n\t\t\ttriggerResize();\n\t\t});\n\t});\n\tif (options === null || options === void 0 ? void 0 : options.watch) watch(options.watch, triggerResize, {\n\t\timmediate: true,\n\t\tdeep: true\n\t});\n\treturn {\n\t\ttextarea,\n\t\tinput,\n\t\ttriggerResize\n\t};\n}\n\n//#endregion\n//#region useThrottledRefHistory/index.ts\n/**\n* Shorthand for [useRefHistory](https://vueuse.org/useRefHistory) with throttled filter.\n*\n* @see https://vueuse.org/useThrottledRefHistory\n* @param source\n* @param options\n*/\nfunction useThrottledRefHistory(source, options = {}) {\n\tconst { throttle = 200, trailing = true } = options;\n\tconst filter = throttleFilter(throttle, trailing);\n\treturn { ...useRefHistory(source, {\n\t\t...options,\n\t\teventFilter: filter\n\t}) };\n}\n\n//#endregion\n//#region useTimeAgo/index.ts\nconst DEFAULT_UNITS = [\n\t{\n\t\tmax: 6e4,\n\t\tvalue: 1e3,\n\t\tname: \"second\"\n\t},\n\t{\n\t\tmax: 276e4,\n\t\tvalue: 6e4,\n\t\tname: \"minute\"\n\t},\n\t{\n\t\tmax: 72e6,\n\t\tvalue: 36e5,\n\t\tname: \"hour\"\n\t},\n\t{\n\t\tmax: 5184e5,\n\t\tvalue: 864e5,\n\t\tname: \"day\"\n\t},\n\t{\n\t\tmax: 24192e5,\n\t\tvalue: 6048e5,\n\t\tname: \"week\"\n\t},\n\t{\n\t\tmax: 28512e6,\n\t\tvalue: 2592e6,\n\t\tname: \"month\"\n\t},\n\t{\n\t\tmax: Number.POSITIVE_INFINITY,\n\t\tvalue: 31536e6,\n\t\tname: \"year\"\n\t}\n];\nconst DEFAULT_MESSAGES = {\n\tjustNow: \"just now\",\n\tpast: (n) => n.match(/\\d/) ? `${n} ago` : n,\n\tfuture: (n) => n.match(/\\d/) ? `in ${n}` : n,\n\tmonth: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n\tyear: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n\tday: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n\tweek: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n\thour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n\tminute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n\tsecond: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n\tinvalid: \"\"\n};\nfunction DEFAULT_FORMATTER(date) {\n\treturn date.toISOString().slice(0, 10);\n}\nfunction getDefaultScheduler$4(options) {\n\tif (\"updateInterval\" in options) {\n\t\tconst { updateInterval = 3e4 } = options;\n\t\treturn (cb) => useIntervalFn(cb, updateInterval);\n\t}\n\treturn (cb) => useIntervalFn(cb, 3e4);\n}\n/**\n* Reactive time ago formatter.\n*\n* @see https://vueuse.org/useTimeAgo\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useTimeAgo(time, options = {}) {\n\tconst { controls: exposeControls = false, scheduler = getDefaultScheduler$4(options) } = options;\n\tconst { now,...controls } = useNow({\n\t\tscheduler,\n\t\tcontrols: true\n\t});\n\tconst timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now)));\n\tif (exposeControls) return {\n\t\ttimeAgo,\n\t\t...controls\n\t};\n\telse return timeAgo;\n}\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\n\tconst { max, messages = DEFAULT_MESSAGES, fullDateFormatter = DEFAULT_FORMATTER, units = DEFAULT_UNITS, showSecond = false, rounding = \"round\" } = options;\n\tconst roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n\tconst diff = +now - +from;\n\tconst absDiff = Math.abs(diff);\n\tfunction getValue$1(diff$1, unit) {\n\t\treturn roundFn(Math.abs(diff$1) / unit.value);\n\t}\n\tfunction format(diff$1, unit) {\n\t\tconst val = getValue$1(diff$1, unit);\n\t\tconst past = diff$1 > 0;\n\t\tconst str = applyFormat(unit.name, val, past);\n\t\treturn applyFormat(past ? \"past\" : \"future\", str, past);\n\t}\n\tfunction applyFormat(name, val, isPast) {\n\t\tconst formatter = messages[name];\n\t\tif (typeof formatter === \"function\") return formatter(val, isPast);\n\t\treturn formatter.replace(\"{0}\", val.toString());\n\t}\n\tif (absDiff < 6e4 && !showSecond) return messages.justNow;\n\tif (typeof max === \"number\" && absDiff > max) return fullDateFormatter(new Date(from));\n\tif (typeof max === \"string\") {\n\t\tvar _units$find;\n\t\tconst unitMax = (_units$find = units.find((i) => i.name === max)) === null || _units$find === void 0 ? void 0 : _units$find.max;\n\t\tif (unitMax && absDiff > unitMax) return fullDateFormatter(new Date(from));\n\t}\n\tfor (const [idx, unit] of units.entries()) {\n\t\tif (getValue$1(diff, unit) <= 0 && units[idx - 1]) return format(diff, units[idx - 1]);\n\t\tif (absDiff < unit.max) return format(diff, unit);\n\t}\n\treturn messages.invalid;\n}\n\n//#endregion\n//#region useTimeAgoIntl/index.ts\nconst UNITS = [\n\t{\n\t\tname: \"year\",\n\t\tms: 31536e6\n\t},\n\t{\n\t\tname: \"month\",\n\t\tms: 2592e6\n\t},\n\t{\n\t\tname: \"week\",\n\t\tms: 6048e5\n\t},\n\t{\n\t\tname: \"day\",\n\t\tms: 864e5\n\t},\n\t{\n\t\tname: \"hour\",\n\t\tms: 36e5\n\t},\n\t{\n\t\tname: \"minute\",\n\t\tms: 6e4\n\t},\n\t{\n\t\tname: \"second\",\n\t\tms: 1e3\n\t}\n];\nfunction getDefaultScheduler$3(options) {\n\tif (\"updateInterval\" in options) {\n\t\tconst { updateInterval = 3e4 } = options;\n\t\treturn (cb) => useIntervalFn(cb, updateInterval);\n\t}\n\treturn (cb) => useIntervalFn(cb, 3e4);\n}\nfunction useTimeAgoIntl(time, options = {}) {\n\tconst { controls: exposeControls = false, scheduler = getDefaultScheduler$3(options) } = options;\n\tconst { now,...controls } = useNow({\n\t\tscheduler,\n\t\tcontrols: true\n\t});\n\tconst result = computed(() => getTimeAgoIntlResult(new Date(toValue(time)), options, toValue(now)));\n\tconst parts = computed(() => result.value.parts);\n\tconst timeAgoIntl = computed(() => formatTimeAgoIntlParts(parts.value, {\n\t\t...options,\n\t\tlocale: result.value.resolvedLocale\n\t}));\n\treturn exposeControls ? {\n\t\ttimeAgoIntl,\n\t\tparts,\n\t\t...controls\n\t} : timeAgoIntl;\n}\n/**\n* Non-reactive version of useTimeAgoIntl\n*/\nfunction formatTimeAgoIntl(from, options = {}, now = Date.now()) {\n\tconst { parts, resolvedLocale } = getTimeAgoIntlResult(from, options, now);\n\treturn formatTimeAgoIntlParts(parts, {\n\t\t...options,\n\t\tlocale: resolvedLocale\n\t});\n}\n/**\n* Get parts from `Intl.RelativeTimeFormat.formatToParts`.\n*/\nfunction getTimeAgoIntlResult(from, options = {}, now = Date.now()) {\n\tvar _options$units;\n\tconst { locale, relativeTimeFormatOptions = { numeric: \"auto\" } } = options;\n\tconst rtf = new Intl.RelativeTimeFormat(locale, relativeTimeFormatOptions);\n\tconst { locale: resolvedLocale } = rtf.resolvedOptions();\n\tconst diff = +from - +now;\n\tconst absDiff = Math.abs(diff);\n\tconst units = (_options$units = options.units) !== null && _options$units !== void 0 ? _options$units : UNITS;\n\tfor (const { name, ms } of units) if (absDiff >= ms) return {\n\t\tresolvedLocale,\n\t\tparts: rtf.formatToParts(Math.round(diff / ms), name)\n\t};\n\treturn {\n\t\tresolvedLocale,\n\t\tparts: rtf.formatToParts(0, units[units.length - 1].name)\n\t};\n}\n/**\n* Format parts into a string\n*/\nfunction formatTimeAgoIntlParts(parts, options = {}) {\n\tconst { insertSpace = true, joinParts, locale } = options;\n\tif (typeof joinParts === \"function\") return joinParts(parts, locale);\n\tif (!insertSpace) return parts.map((part) => part.value).join(\"\");\n\treturn parts.map((part) => part.value.trim()).join(\" \");\n}\n\n//#endregion\n//#region useTimeoutPoll/index.ts\nfunction useTimeoutPoll(fn, interval, options = {}) {\n\tconst { immediate = true, immediateCallback = false } = options;\n\tconst { start } = useTimeoutFn(loop, interval, { immediate });\n\tconst isActive = shallowRef(false);\n\tasync function loop() {\n\t\tif (!isActive.value) return;\n\t\tawait fn();\n\t\tstart();\n\t}\n\tfunction resume() {\n\t\tif (!isActive.value) {\n\t\t\tisActive.value = true;\n\t\t\tif (immediateCallback) fn();\n\t\t\tstart();\n\t\t}\n\t}\n\tfunction pause() {\n\t\tisActive.value = false;\n\t}\n\tif (immediate && isClient) resume();\n\ttryOnScopeDispose(pause);\n\treturn {\n\t\tisActive,\n\t\tpause,\n\t\tresume\n\t};\n}\n\n//#endregion\n//#region useTimestamp/index.ts\nfunction getDefaultScheduler$2(options) {\n\tif (\"interval\" in options || \"immediate\" in options) {\n\t\tconst { interval = \"requestAnimationFrame\", immediate = true } = options;\n\t\treturn interval === \"requestAnimationFrame\" ? (cb) => useRafFn(cb, { immediate }) : (cb) => useIntervalFn(cb, interval, { immediate });\n\t}\n\treturn useRafFn;\n}\nfunction useTimestamp(options = {}) {\n\tconst { controls: exposeControls = false, offset = 0, scheduler = getDefaultScheduler$2(options), callback } = options;\n\tconst ts = shallowRef(timestamp() + offset);\n\tconst update = () => ts.value = timestamp() + offset;\n\tconst controls = scheduler(callback ? () => {\n\t\tupdate();\n\t\tcallback(ts.value);\n\t} : update);\n\tif (exposeControls) return {\n\t\ttimestamp: ts,\n\t\t...controls\n\t};\n\telse return ts;\n}\n\n//#endregion\n//#region useTitle/index.ts\nfunction useTitle(newTitle = null, options = {}) {\n\tvar _document$title, _ref;\n\tconst { document: document$1 = defaultDocument, restoreOnUnmount = (t) => t } = options;\n\tconst originalTitle = (_document$title = document$1 === null || document$1 === void 0 ? void 0 : document$1.title) !== null && _document$title !== void 0 ? _document$title : \"\";\n\tconst title = toRef((_ref = newTitle !== null && newTitle !== void 0 ? newTitle : document$1 === null || document$1 === void 0 ? void 0 : document$1.title) !== null && _ref !== void 0 ? _ref : null);\n\tconst isReadonly$1 = !!(newTitle && typeof newTitle === \"function\");\n\tfunction format(t) {\n\t\tif (!(\"titleTemplate\" in options)) return t;\n\t\tconst template = options.titleTemplate || \"%s\";\n\t\treturn typeof template === \"function\" ? template(t) : toValue(template).replace(/%s/g, t);\n\t}\n\twatch(title, (newValue, oldValue) => {\n\t\tif (newValue !== oldValue && document$1) document$1.title = format(newValue !== null && newValue !== void 0 ? newValue : \"\");\n\t}, { immediate: true });\n\tif (options.observe && !options.titleTemplate && document$1 && !isReadonly$1) {\n\t\tvar _document$head;\n\t\tuseMutationObserver((_document$head = document$1.head) === null || _document$head === void 0 ? void 0 : _document$head.querySelector(\"title\"), () => {\n\t\t\tif (document$1 && document$1.title !== title.value) title.value = format(document$1.title);\n\t\t}, { childList: true });\n\t}\n\ttryOnScopeDispose(() => {\n\t\tif (restoreOnUnmount) {\n\t\t\tconst restoredTitle = restoreOnUnmount(originalTitle, title.value || \"\");\n\t\t\tif (restoredTitle != null && document$1) document$1.title = restoredTitle;\n\t\t}\n\t});\n\treturn title;\n}\n\n//#endregion\n//#region useTransition/index.ts\nconst _TransitionPresets = {\n\teaseInSine: [\n\t\t.12,\n\t\t0,\n\t\t.39,\n\t\t0\n\t],\n\teaseOutSine: [\n\t\t.61,\n\t\t1,\n\t\t.88,\n\t\t1\n\t],\n\teaseInOutSine: [\n\t\t.37,\n\t\t0,\n\t\t.63,\n\t\t1\n\t],\n\teaseInQuad: [\n\t\t.11,\n\t\t0,\n\t\t.5,\n\t\t0\n\t],\n\teaseOutQuad: [\n\t\t.5,\n\t\t1,\n\t\t.89,\n\t\t1\n\t],\n\teaseInOutQuad: [\n\t\t.45,\n\t\t0,\n\t\t.55,\n\t\t1\n\t],\n\teaseInCubic: [\n\t\t.32,\n\t\t0,\n\t\t.67,\n\t\t0\n\t],\n\teaseOutCubic: [\n\t\t.33,\n\t\t1,\n\t\t.68,\n\t\t1\n\t],\n\teaseInOutCubic: [\n\t\t.65,\n\t\t0,\n\t\t.35,\n\t\t1\n\t],\n\teaseInQuart: [\n\t\t.5,\n\t\t0,\n\t\t.75,\n\t\t0\n\t],\n\teaseOutQuart: [\n\t\t.25,\n\t\t1,\n\t\t.5,\n\t\t1\n\t],\n\teaseInOutQuart: [\n\t\t.76,\n\t\t0,\n\t\t.24,\n\t\t1\n\t],\n\teaseInQuint: [\n\t\t.64,\n\t\t0,\n\t\t.78,\n\t\t0\n\t],\n\teaseOutQuint: [\n\t\t.22,\n\t\t1,\n\t\t.36,\n\t\t1\n\t],\n\teaseInOutQuint: [\n\t\t.83,\n\t\t0,\n\t\t.17,\n\t\t1\n\t],\n\teaseInExpo: [\n\t\t.7,\n\t\t0,\n\t\t.84,\n\t\t0\n\t],\n\teaseOutExpo: [\n\t\t.16,\n\t\t1,\n\t\t.3,\n\t\t1\n\t],\n\teaseInOutExpo: [\n\t\t.87,\n\t\t0,\n\t\t.13,\n\t\t1\n\t],\n\teaseInCirc: [\n\t\t.55,\n\t\t0,\n\t\t1,\n\t\t.45\n\t],\n\teaseOutCirc: [\n\t\t0,\n\t\t.55,\n\t\t.45,\n\t\t1\n\t],\n\teaseInOutCirc: [\n\t\t.85,\n\t\t0,\n\t\t.15,\n\t\t1\n\t],\n\teaseInBack: [\n\t\t.36,\n\t\t0,\n\t\t.66,\n\t\t-.56\n\t],\n\teaseOutBack: [\n\t\t.34,\n\t\t1.56,\n\t\t.64,\n\t\t1\n\t],\n\teaseInOutBack: [\n\t\t.68,\n\t\t-.6,\n\t\t.32,\n\t\t1.6\n\t]\n};\n/**\n* Common transitions\n*\n* @see https://easings.net\n*/\nconst TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);\n/**\n* Create an easing function from cubic bezier points.\n*/\nfunction createEasingFunction([p0, p1, p2, p3]) {\n\tconst a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n\tconst b = (a1, a2) => 3 * a2 - 6 * a1;\n\tconst c = (a1) => 3 * a1;\n\tconst calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n\tconst getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n\tconst getTforX = (x) => {\n\t\tlet aGuessT = x;\n\t\tfor (let i = 0; i < 4; ++i) {\n\t\t\tconst currentSlope = getSlope(aGuessT, p0, p2);\n\t\t\tif (currentSlope === 0) return aGuessT;\n\t\t\tconst currentX = calcBezier(aGuessT, p0, p2) - x;\n\t\t\taGuessT -= currentX / currentSlope;\n\t\t}\n\t\treturn aGuessT;\n\t};\n\treturn (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction lerp(a, b, alpha) {\n\treturn a + alpha * (b - a);\n}\nfunction defaultInterpolation(a, b, t) {\n\tconst aVal = toValue(a);\n\tconst bVal = toValue(b);\n\tif (typeof aVal === \"number\" && typeof bVal === \"number\") return lerp(aVal, bVal, t);\n\tif (Array.isArray(aVal) && Array.isArray(bVal)) return aVal.map((v, i) => lerp(v, toValue(bVal[i]), t));\n\tthrow new TypeError(\"Unknown transition type, specify an interpolation function.\");\n}\nfunction normalizeEasing(easing) {\n\tvar _toValue;\n\treturn typeof easing === \"function\" ? easing : (_toValue = toValue(easing)) !== null && _toValue !== void 0 ? _toValue : identity;\n}\n/**\n* Transition from one value to another.\n*\n* @param source\n* @param from\n* @param to\n* @param options\n*/\nfunction transition(source, from, to, options = {}) {\n\tvar _toValue2;\n\tconst { window: window$1 = defaultWindow } = options;\n\tconst fromVal = toValue(from);\n\tconst toVal = toValue(to);\n\tconst duration = (_toValue2 = toValue(options.duration)) !== null && _toValue2 !== void 0 ? _toValue2 : 1e3;\n\tconst startedAt = Date.now();\n\tconst endAt = Date.now() + duration;\n\tconst interpolation = typeof options.interpolation === \"function\" ? options.interpolation : defaultInterpolation;\n\tconst trans = typeof options.easing !== \"undefined\" ? normalizeEasing(options.easing) : normalizeEasing(options.transition);\n\tconst ease = typeof trans === \"function\" ? trans : createEasingFunction(trans);\n\treturn new Promise((resolve) => {\n\t\tsource.value = fromVal;\n\t\tconst tick = () => {\n\t\t\tvar _options$abort;\n\t\t\tif ((_options$abort = options.abort) === null || _options$abort === void 0 ? void 0 : _options$abort.call(options)) {\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst now = Date.now();\n\t\t\tsource.value = interpolation(fromVal, toVal, ease((now - startedAt) / duration));\n\t\t\tif (now < endAt) window$1 === null || window$1 === void 0 || window$1.requestAnimationFrame(tick);\n\t\t\telse {\n\t\t\t\tsource.value = toVal;\n\t\t\t\tresolve();\n\t\t\t}\n\t\t};\n\t\ttick();\n\t});\n}\n/**\n* Transition from one value to another.\n* @deprecated The `executeTransition` function is deprecated, use `transition` instead.\n*\n* @param source\n* @param from\n* @param to\n* @param options\n*/\nfunction executeTransition(source, from, to, options = {}) {\n\treturn transition(source, from, to, options);\n}\n/**\n* Follow value with a transition.\n*\n* @see https://vueuse.org/useTransition\n* @param source\n* @param options\n*/\nfunction useTransition(source, options = {}) {\n\tlet currentId = 0;\n\tconst sourceVal = () => {\n\t\tconst v = toValue(source);\n\t\treturn typeof options.interpolation === \"undefined\" && Array.isArray(v) ? v.map(toValue) : v;\n\t};\n\tconst outputRef = shallowRef(sourceVal());\n\twatch(sourceVal, async (to) => {\n\t\tvar _options$onStarted, _options$onFinished;\n\t\tif (toValue(options.disabled)) return;\n\t\tconst id = ++currentId;\n\t\tif (options.delay) await promiseTimeout(toValue(options.delay));\n\t\tif (id !== currentId) return;\n\t\t(_options$onStarted = options.onStarted) === null || _options$onStarted === void 0 || _options$onStarted.call(options);\n\t\tawait transition(outputRef, outputRef.value, to, {\n\t\t\t...options,\n\t\t\tabort: () => {\n\t\t\t\tvar _options$abort2;\n\t\t\t\treturn id !== currentId || ((_options$abort2 = options.abort) === null || _options$abort2 === void 0 ? void 0 : _options$abort2.call(options));\n\t\t\t}\n\t\t});\n\t\t(_options$onFinished = options.onFinished) === null || _options$onFinished === void 0 || _options$onFinished.call(options);\n\t}, { deep: true });\n\twatch(() => toValue(options.disabled), (disabled) => {\n\t\tif (disabled) {\n\t\t\tcurrentId++;\n\t\t\toutputRef.value = sourceVal();\n\t\t}\n\t});\n\ttryOnScopeDispose(() => {\n\t\tcurrentId++;\n\t});\n\treturn computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value);\n}\n\n//#endregion\n//#region useUrlSearchParams/index.ts\n/**\n* Reactive URLSearchParams\n*\n* @see https://vueuse.org/useUrlSearchParams\n* @param mode\n* @param options\n*/\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n\tconst { initialValue = {}, removeNullishValues = true, removeFalsyValues = false, write: enableWrite = true, writeMode = \"replace\", window: window$1 = defaultWindow, stringify = (params) => params.toString() } = options;\n\tif (!window$1) return reactive(initialValue);\n\tconst state = reactive({});\n\tfunction getRawParams() {\n\t\tif (mode === \"history\") return window$1.location.search || \"\";\n\t\telse if (mode === \"hash\") {\n\t\t\tconst hash = window$1.location.hash || \"\";\n\t\t\tconst index = hash.indexOf(\"?\");\n\t\t\treturn index > 0 ? hash.slice(index) : \"\";\n\t\t} else return (window$1.location.hash || \"\").replace(/^#/, \"\");\n\t}\n\tfunction constructQuery(params) {\n\t\tconst stringified = stringify(params);\n\t\tif (mode === \"history\") return `${stringified ? `?${stringified}` : \"\"}${window$1.location.hash || \"\"}`;\n\t\tif (mode === \"hash-params\") return `${window$1.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n\t\tconst hash = window$1.location.hash || \"#\";\n\t\tconst index = hash.indexOf(\"?\");\n\t\tif (index > 0) return `${window$1.location.search || \"\"}${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n\t\treturn `${window$1.location.search || \"\"}${hash}${stringified ? `?${stringified}` : \"\"}`;\n\t}\n\tfunction read() {\n\t\treturn new URLSearchParams(getRawParams());\n\t}\n\tfunction updateState(params) {\n\t\tconst unusedKeys = new Set(Object.keys(state));\n\t\tfor (const key of params.keys()) {\n\t\t\tconst paramsForKey = params.getAll(key);\n\t\t\tstate[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n\t\t\tunusedKeys.delete(key);\n\t\t}\n\t\tArray.from(unusedKeys).forEach((key) => delete state[key]);\n\t}\n\tconst { pause, resume } = watchPausable(state, () => {\n\t\tconst params = new URLSearchParams(\"\");\n\t\tObject.keys(state).forEach((key) => {\n\t\t\tconst mapEntry = state[key];\n\t\t\tif (Array.isArray(mapEntry)) mapEntry.forEach((value) => params.append(key, value));\n\t\t\telse if (removeNullishValues && mapEntry == null) params.delete(key);\n\t\t\telse if (removeFalsyValues && !mapEntry) params.delete(key);\n\t\t\telse params.set(key, mapEntry);\n\t\t});\n\t\twrite(params, false);\n\t}, { deep: true });\n\tfunction write(params, shouldUpdate, shouldWriteHistory = true) {\n\t\tpause();\n\t\tif (shouldUpdate) updateState(params);\n\t\tif (writeMode === \"replace\") window$1.history.replaceState(window$1.history.state, window$1.document.title, window$1.location.pathname + constructQuery(params));\n\t\telse if (shouldWriteHistory) window$1.history.pushState(window$1.history.state, window$1.document.title, window$1.location.pathname + constructQuery(params));\n\t\tnextTick(() => resume());\n\t}\n\tfunction onChanged() {\n\t\tif (!enableWrite) return;\n\t\twrite(read(), true, false);\n\t}\n\tconst listenerOptions = { passive: true };\n\tuseEventListener(window$1, \"popstate\", onChanged, listenerOptions);\n\tif (mode !== \"history\") useEventListener(window$1, \"hashchange\", onChanged, listenerOptions);\n\tconst initial = read();\n\tif (initial.keys().next().value) updateState(initial);\n\telse Object.assign(state, initialValue);\n\treturn state;\n}\n\n//#endregion\n//#region useUserMedia/index.ts\n/**\n* Reactive `mediaDevices.getUserMedia` streaming\n*\n* @see https://vueuse.org/useUserMedia\n* @param options\n*/\nfunction useUserMedia(options = {}) {\n\tvar _options$enabled, _options$autoSwitch;\n\tconst enabled = shallowRef((_options$enabled = options.enabled) !== null && _options$enabled !== void 0 ? _options$enabled : false);\n\tconst autoSwitch = shallowRef((_options$autoSwitch = options.autoSwitch) !== null && _options$autoSwitch !== void 0 ? _options$autoSwitch : true);\n\tconst constraints = ref(options.constraints);\n\tconst { navigator: navigator$1 = defaultNavigator } = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => {\n\t\tvar _navigator$mediaDevic;\n\t\treturn navigator$1 === null || navigator$1 === void 0 || (_navigator$mediaDevic = navigator$1.mediaDevices) === null || _navigator$mediaDevic === void 0 ? void 0 : _navigator$mediaDevic.getUserMedia;\n\t});\n\tconst stream = shallowRef();\n\tfunction getDeviceOptions(type) {\n\t\tswitch (type) {\n\t\t\tcase \"video\":\n\t\t\t\tif (constraints.value) return constraints.value.video || false;\n\t\t\t\tbreak;\n\t\t\tcase \"audio\":\n\t\t\t\tif (constraints.value) return constraints.value.audio || false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tasync function _start() {\n\t\tif (!isSupported.value || stream.value) return;\n\t\tstream.value = await navigator$1.mediaDevices.getUserMedia({\n\t\t\tvideo: getDeviceOptions(\"video\"),\n\t\t\taudio: getDeviceOptions(\"audio\")\n\t\t});\n\t\treturn stream.value;\n\t}\n\tfunction _stop() {\n\t\tvar _stream$value;\n\t\t(_stream$value = stream.value) === null || _stream$value === void 0 || _stream$value.getTracks().forEach((t) => t.stop());\n\t\tstream.value = void 0;\n\t}\n\tfunction stop() {\n\t\t_stop();\n\t\tenabled.value = false;\n\t}\n\tasync function start() {\n\t\tawait _start();\n\t\tif (stream.value) enabled.value = true;\n\t\treturn stream.value;\n\t}\n\tasync function restart() {\n\t\t_stop();\n\t\treturn await start();\n\t}\n\twatch(enabled, (v) => {\n\t\tif (v) _start();\n\t\telse _stop();\n\t}, { immediate: true });\n\twatch(constraints, () => {\n\t\tif (autoSwitch.value && stream.value) restart();\n\t}, {\n\t\timmediate: true,\n\t\tdeep: true\n\t});\n\ttryOnScopeDispose(() => {\n\t\tstop();\n\t});\n\treturn {\n\t\tisSupported,\n\t\tstream,\n\t\tstart,\n\t\tstop,\n\t\trestart,\n\t\tconstraints,\n\t\tenabled,\n\t\tautoSwitch\n\t};\n}\n\n//#endregion\n//#region useVModel/index.ts\n/**\n* Shorthand for v-model binding, props + emit -> ref\n*\n* @see https://vueuse.org/useVModel\n* @param props\n* @param key (default 'modelValue')\n* @param emit\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useVModel(props, key, emit, options = {}) {\n\tvar _vm$$emit, _vm$proxy;\n\tconst { clone = false, passive = false, eventName, deep = false, defaultValue, shouldEmit } = options;\n\tconst vm = getCurrentInstance();\n\tconst _emit = emit || (vm === null || vm === void 0 ? void 0 : vm.emit) || (vm === null || vm === void 0 || (_vm$$emit = vm.$emit) === null || _vm$$emit === void 0 ? void 0 : _vm$$emit.bind(vm)) || (vm === null || vm === void 0 || (_vm$proxy = vm.proxy) === null || _vm$proxy === void 0 || (_vm$proxy = _vm$proxy.$emit) === null || _vm$proxy === void 0 ? void 0 : _vm$proxy.bind(vm === null || vm === void 0 ? void 0 : vm.proxy));\n\tlet event = eventName;\n\tif (!key) key = \"modelValue\";\n\tevent = event || `update:${key.toString()}`;\n\tconst cloneFn = (val) => !clone ? val : typeof clone === \"function\" ? clone(val) : cloneFnJSON(val);\n\tconst getValue$1 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\n\tconst triggerEmit = (value) => {\n\t\tif (shouldEmit) {\n\t\t\tif (shouldEmit(value)) _emit(event, value);\n\t\t} else _emit(event, value);\n\t};\n\tif (passive) {\n\t\tconst proxy = ref(getValue$1());\n\t\tlet isUpdating = false;\n\t\twatch(() => props[key], (v) => {\n\t\t\tif (!isUpdating) {\n\t\t\t\tisUpdating = true;\n\t\t\t\tproxy.value = cloneFn(v);\n\t\t\t\tnextTick(() => isUpdating = false);\n\t\t\t}\n\t\t});\n\t\twatch(proxy, (v) => {\n\t\t\tif (!isUpdating && (v !== props[key] || deep)) triggerEmit(v);\n\t\t}, { deep });\n\t\treturn proxy;\n\t} else return computed({\n\t\tget() {\n\t\t\treturn getValue$1();\n\t\t},\n\t\tset(value) {\n\t\t\ttriggerEmit(value);\n\t\t}\n\t});\n}\n\n//#endregion\n//#region useVModels/index.ts\n/**\n* Shorthand for props v-model binding. Think like `toRefs(props)` but changes will also emit out.\n*\n* @see https://vueuse.org/useVModels\n* @param props\n* @param emit\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useVModels(props, emit, options = {}) {\n\tconst ret = {};\n\tfor (const key in props) ret[key] = useVModel(props, key, emit, options);\n\treturn ret;\n}\n\n//#endregion\n//#region useVibrate/index.ts\nfunction getDefaultScheduler$1(options = { interval: 0 }) {\n\tconst { interval } = options;\n\tif (interval === 0) return;\n\treturn (fn) => useIntervalFn(fn, interval, {\n\t\timmediate: false,\n\t\timmediateCallback: false\n\t});\n}\n/**\n* Reactive vibrate\n*\n* @see https://vueuse.org/useVibrate\n* @see https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useVibrate(options) {\n\tconst { pattern = [], scheduler = getDefaultScheduler$1(options), navigator: navigator$1 = defaultNavigator } = options || {};\n\tconst isSupported = /* @__PURE__ */ useSupported(() => typeof navigator$1 !== \"undefined\" && \"vibrate\" in navigator$1);\n\tconst patternRef = toRef(pattern);\n\tconst vibrate = (pattern$1 = patternRef.value) => {\n\t\tif (isSupported.value) navigator$1.vibrate(pattern$1);\n\t};\n\tconst intervalControls = scheduler === null || scheduler === void 0 ? void 0 : scheduler(vibrate);\n\tconst stop = () => {\n\t\tif (isSupported.value) navigator$1.vibrate(0);\n\t\tintervalControls === null || intervalControls === void 0 || intervalControls.pause();\n\t};\n\treturn {\n\t\tisSupported,\n\t\tpattern,\n\t\tintervalControls,\n\t\tvibrate,\n\t\tstop\n\t};\n}\n\n//#endregion\n//#region useVirtualList/index.ts\n/**\n* Please consider using [`vue-virtual-scroller`](https://github.com/Akryum/vue-virtual-scroller) if you are looking for more features.\n*/\nfunction useVirtualList(list, options) {\n\tconst { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n\treturn {\n\t\tlist: currentList,\n\t\tscrollTo,\n\t\tcontainerProps: {\n\t\t\tref: containerRef,\n\t\t\tonScroll: () => {\n\t\t\t\tcalculateRange();\n\t\t\t},\n\t\t\tstyle: containerStyle\n\t\t},\n\t\twrapperProps\n\t};\n}\nfunction useVirtualListResources(list) {\n\tconst containerRef = shallowRef(null);\n\tconst size = useElementSize(containerRef);\n\tconst currentList = ref([]);\n\tconst source = shallowRef(list);\n\treturn {\n\t\tstate: ref({\n\t\t\tstart: 0,\n\t\t\tend: 10\n\t\t}),\n\t\tsource,\n\t\tcurrentList,\n\t\tsize,\n\t\tcontainerRef\n\t};\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n\treturn (containerSize) => {\n\t\tif (typeof itemSize === \"number\") return Math.ceil(containerSize / itemSize);\n\t\tconst { start = 0 } = state.value;\n\t\tlet sum = 0;\n\t\tlet capacity = 0;\n\t\tfor (let i = start; i < source.value.length; i++) {\n\t\t\tconst size = itemSize(i);\n\t\t\tsum += size;\n\t\t\tcapacity = i;\n\t\t\tif (sum > containerSize) break;\n\t\t}\n\t\treturn capacity - start;\n\t};\n}\nfunction createGetOffset(source, itemSize) {\n\treturn (scrollDirection) => {\n\t\tif (typeof itemSize === \"number\") return Math.floor(scrollDirection / itemSize) + 1;\n\t\tlet sum = 0;\n\t\tlet offset = 0;\n\t\tfor (let i = 0; i < source.value.length; i++) {\n\t\t\tconst size = itemSize(i);\n\t\t\tsum += size;\n\t\t\tif (sum >= scrollDirection) {\n\t\t\t\toffset = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn offset + 1;\n\t};\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n\treturn () => {\n\t\tconst element = containerRef.value;\n\t\tif (element) {\n\t\t\tconst offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n\t\t\tconst viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n\t\t\tconst from = offset - overscan;\n\t\t\tconst to = offset + viewCapacity + overscan;\n\t\t\tstate.value = {\n\t\t\t\tstart: from < 0 ? 0 : from,\n\t\t\t\tend: to > source.value.length ? source.value.length : to\n\t\t\t};\n\t\t\tcurrentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n\t\t\t\tdata: ele,\n\t\t\t\tindex: index + state.value.start\n\t\t\t}));\n\t\t}\n\t};\n}\nfunction createGetDistance(itemSize, source) {\n\treturn (index) => {\n\t\tif (typeof itemSize === \"number\") return index * itemSize;\n\t\treturn source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n\t};\n}\nfunction useWatchForSizes(size, list, containerRef, calculateRange) {\n\twatch([\n\t\tsize.width,\n\t\tsize.height,\n\t\t() => toValue(list),\n\t\tcontainerRef\n\t], () => {\n\t\tcalculateRange();\n\t});\n}\nfunction createComputedTotalSize(itemSize, source) {\n\treturn computed(() => {\n\t\tif (typeof itemSize === \"number\") return source.value.length * itemSize;\n\t\treturn source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n\t});\n}\nconst scrollToDictionaryForElementScrollKey = {\n\thorizontal: \"scrollLeft\",\n\tvertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n\treturn (index) => {\n\t\tif (containerRef.value) {\n\t\t\tcontainerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n\t\t\tcalculateRange();\n\t\t}\n\t};\n}\nfunction useHorizontalVirtualList(options, list) {\n\tconst resources = useVirtualListResources(list);\n\tconst { state, source, currentList, size, containerRef } = resources;\n\tconst containerStyle = { overflowX: \"auto\" };\n\tconst { itemWidth, overscan = 5 } = options;\n\tconst getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n\tconst calculateRange = createCalculateRange(\"horizontal\", overscan, createGetOffset(source, itemWidth), getViewCapacity, resources);\n\tconst getDistanceLeft = createGetDistance(itemWidth, source);\n\tconst offsetLeft = computed(() => getDistanceLeft(state.value.start));\n\tconst totalWidth = createComputedTotalSize(itemWidth, source);\n\tuseWatchForSizes(size, list, containerRef, calculateRange);\n\treturn {\n\t\tscrollTo: createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef),\n\t\tcalculateRange,\n\t\twrapperProps: computed(() => {\n\t\t\treturn { style: {\n\t\t\t\theight: \"100%\",\n\t\t\t\twidth: `${totalWidth.value - offsetLeft.value}px`,\n\t\t\t\tmarginLeft: `${offsetLeft.value}px`,\n\t\t\t\tdisplay: \"flex\"\n\t\t\t} };\n\t\t}),\n\t\tcontainerStyle,\n\t\tcurrentList,\n\t\tcontainerRef\n\t};\n}\nfunction useVerticalVirtualList(options, list) {\n\tconst resources = useVirtualListResources(list);\n\tconst { state, source, currentList, size, containerRef } = resources;\n\tconst containerStyle = { overflowY: \"auto\" };\n\tconst { itemHeight, overscan = 5 } = options;\n\tconst getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n\tconst calculateRange = createCalculateRange(\"vertical\", overscan, createGetOffset(source, itemHeight), getViewCapacity, resources);\n\tconst getDistanceTop = createGetDistance(itemHeight, source);\n\tconst offsetTop = computed(() => getDistanceTop(state.value.start));\n\tconst totalHeight = createComputedTotalSize(itemHeight, source);\n\tuseWatchForSizes(size, list, containerRef, calculateRange);\n\treturn {\n\t\tcalculateRange,\n\t\tscrollTo: createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef),\n\t\tcontainerStyle,\n\t\twrapperProps: computed(() => {\n\t\t\treturn { style: {\n\t\t\t\twidth: \"100%\",\n\t\t\t\theight: `${totalHeight.value - offsetTop.value}px`,\n\t\t\t\tmarginTop: `${offsetTop.value}px`\n\t\t\t} };\n\t\t}),\n\t\tcurrentList,\n\t\tcontainerRef\n\t};\n}\n\n//#endregion\n//#region useWakeLock/index.ts\n/**\n* Reactive Screen Wake Lock API.\n*\n* @see https://vueuse.org/useWakeLock\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useWakeLock(options = {}) {\n\tconst { navigator: navigator$1 = defaultNavigator, document: document$1 = defaultDocument } = options;\n\tconst requestedType = shallowRef(false);\n\tconst sentinel = shallowRef(null);\n\tconst documentVisibility = useDocumentVisibility({ document: document$1 });\n\tconst isSupported = /* @__PURE__ */ useSupported(() => navigator$1 && \"wakeLock\" in navigator$1);\n\tconst isActive = computed(() => !!sentinel.value && documentVisibility.value === \"visible\");\n\tif (isSupported.value) {\n\t\tuseEventListener(sentinel, \"release\", () => {\n\t\t\tvar _sentinel$value$type, _sentinel$value;\n\t\t\trequestedType.value = (_sentinel$value$type = (_sentinel$value = sentinel.value) === null || _sentinel$value === void 0 ? void 0 : _sentinel$value.type) !== null && _sentinel$value$type !== void 0 ? _sentinel$value$type : false;\n\t\t}, { passive: true });\n\t\twhenever(() => documentVisibility.value === \"visible\" && (document$1 === null || document$1 === void 0 ? void 0 : document$1.visibilityState) === \"visible\" && requestedType.value, (type) => {\n\t\t\trequestedType.value = false;\n\t\t\tforceRequest(type);\n\t\t});\n\t}\n\tasync function forceRequest(type) {\n\t\tvar _sentinel$value2;\n\t\tawait ((_sentinel$value2 = sentinel.value) === null || _sentinel$value2 === void 0 ? void 0 : _sentinel$value2.release());\n\t\tsentinel.value = isSupported.value ? await navigator$1.wakeLock.request(type) : null;\n\t}\n\tasync function request(type) {\n\t\tif (documentVisibility.value === \"visible\") await forceRequest(type);\n\t\telse requestedType.value = type;\n\t}\n\tasync function release() {\n\t\trequestedType.value = false;\n\t\tconst s = sentinel.value;\n\t\tsentinel.value = null;\n\t\tawait (s === null || s === void 0 ? void 0 : s.release());\n\t}\n\treturn {\n\t\tsentinel,\n\t\tisSupported,\n\t\tisActive,\n\t\trequest,\n\t\tforceRequest,\n\t\trelease\n\t};\n}\n\n//#endregion\n//#region useWebNotification/index.ts\n/**\n* Reactive useWebNotification\n*\n* @see https://vueuse.org/useWebNotification\n* @see https://developer.mozilla.org/en-US/docs/Web/API/notification\n*/\nfunction useWebNotification(options = {}) {\n\tconst { window: window$1 = defaultWindow, requestPermissions: _requestForPermissions = true } = options;\n\tconst defaultWebNotificationOptions = options;\n\tconst isSupported = /* @__PURE__ */ useSupported(() => {\n\t\tif (!window$1 || !(\"Notification\" in window$1)) return false;\n\t\tif (Notification.permission === \"granted\") return true;\n\t\ttry {\n\t\t\tconst notification$1 = new Notification(\"\");\n\t\t\tnotification$1.onshow = () => {\n\t\t\t\tnotification$1.close();\n\t\t\t};\n\t\t} catch (e) {\n\t\t\tif (e.name === \"TypeError\") return false;\n\t\t}\n\t\treturn true;\n\t});\n\tconst permissionGranted = shallowRef(isSupported.value && \"permission\" in Notification && Notification.permission === \"granted\");\n\tconst notification = ref(null);\n\tconst ensurePermissions = async () => {\n\t\tif (!isSupported.value) return;\n\t\tif (!permissionGranted.value && Notification.permission !== \"denied\") {\n\t\t\tif (await Notification.requestPermission() === \"granted\") permissionGranted.value = true;\n\t\t}\n\t\treturn permissionGranted.value;\n\t};\n\tconst { on: onClick, trigger: clickTrigger } = createEventHook();\n\tconst { on: onShow, trigger: showTrigger } = createEventHook();\n\tconst { on: onError, trigger: errorTrigger } = createEventHook();\n\tconst { on: onClose, trigger: closeTrigger } = createEventHook();\n\tconst show = async (overrides) => {\n\t\tif (!isSupported.value || !permissionGranted.value) return;\n\t\tconst options$1 = Object.assign({}, defaultWebNotificationOptions, overrides);\n\t\tnotification.value = new Notification(options$1.title || \"\", options$1);\n\t\tnotification.value.onclick = clickTrigger;\n\t\tnotification.value.onshow = showTrigger;\n\t\tnotification.value.onerror = errorTrigger;\n\t\tnotification.value.onclose = closeTrigger;\n\t\treturn notification.value;\n\t};\n\tconst close = () => {\n\t\tif (notification.value) notification.value.close();\n\t\tnotification.value = null;\n\t};\n\tif (_requestForPermissions) tryOnMounted(ensurePermissions);\n\ttryOnScopeDispose(close);\n\tif (isSupported.value && window$1) {\n\t\tconst document$1 = window$1.document;\n\t\tuseEventListener(document$1, \"visibilitychange\", (e) => {\n\t\t\te.preventDefault();\n\t\t\tif (document$1.visibilityState === \"visible\") close();\n\t\t});\n\t}\n\treturn {\n\t\tisSupported,\n\t\tnotification,\n\t\tensurePermissions,\n\t\tpermissionGranted,\n\t\tshow,\n\t\tclose,\n\t\tonClick,\n\t\tonShow,\n\t\tonError,\n\t\tonClose\n\t};\n}\n\n//#endregion\n//#region useWebSocket/index.ts\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n\tif (options === true) return {};\n\treturn options;\n}\nfunction getDefaultScheduler(options) {\n\tif (\"interval\" in options) {\n\t\tconst { interval = 1e3 } = options;\n\t\treturn (cb) => useIntervalFn(cb, interval, { immediate: false });\n\t}\n\treturn (cb) => useIntervalFn(cb, 1e3, { immediate: false });\n}\n/**\n* Reactive WebSocket client.\n*\n* @see https://vueuse.org/useWebSocket\n* @param url\n*/\nfunction useWebSocket(url, options = {}) {\n\tconst { onConnected, onDisconnected, onError, onMessage, immediate = true, autoConnect = true, autoClose = true, protocols = [] } = options;\n\tconst data = ref(null);\n\tconst status = shallowRef(\"CLOSED\");\n\tconst wsRef = ref();\n\tconst urlRef = toRef(url);\n\tlet heartbeatPause;\n\tlet heartbeatResume;\n\tlet explicitlyClosed = false;\n\tlet retried = 0;\n\tlet bufferedData = [];\n\tlet retryTimeout;\n\tlet pongTimeoutWait;\n\tconst _sendBuffer = () => {\n\t\tif (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n\t\t\tfor (const buffer of bufferedData) wsRef.value.send(buffer);\n\t\t\tbufferedData = [];\n\t\t}\n\t};\n\tconst resetRetry = () => {\n\t\tif (retryTimeout != null) {\n\t\t\tclearTimeout(retryTimeout);\n\t\t\tretryTimeout = void 0;\n\t\t}\n\t};\n\tconst resetHeartbeat = () => {\n\t\tclearTimeout(pongTimeoutWait);\n\t\tpongTimeoutWait = void 0;\n\t};\n\tconst close = (code = 1e3, reason) => {\n\t\tresetRetry();\n\t\tif (!isClient && !isWorker || !wsRef.value) return;\n\t\texplicitlyClosed = true;\n\t\tresetHeartbeat();\n\t\theartbeatPause === null || heartbeatPause === void 0 || heartbeatPause();\n\t\twsRef.value.close(code, reason);\n\t\twsRef.value = void 0;\n\t};\n\tconst send = (data$1, useBuffer = true) => {\n\t\tif (!wsRef.value || status.value !== \"OPEN\") {\n\t\t\tif (useBuffer) bufferedData.push(data$1);\n\t\t\treturn false;\n\t\t}\n\t\t_sendBuffer();\n\t\twsRef.value.send(data$1);\n\t\treturn true;\n\t};\n\tconst _init = () => {\n\t\tif (explicitlyClosed || typeof urlRef.value === \"undefined\") return;\n\t\tconst ws = new WebSocket(urlRef.value, protocols);\n\t\twsRef.value = ws;\n\t\tstatus.value = \"CONNECTING\";\n\t\tws.onopen = () => {\n\t\t\tstatus.value = \"OPEN\";\n\t\t\tretried = 0;\n\t\t\tonConnected === null || onConnected === void 0 || onConnected(ws);\n\t\t\theartbeatResume === null || heartbeatResume === void 0 || heartbeatResume();\n\t\t\t_sendBuffer();\n\t\t};\n\t\tws.onclose = (ev) => {\n\t\t\tstatus.value = \"CLOSED\";\n\t\t\tresetHeartbeat();\n\t\t\theartbeatPause === null || heartbeatPause === void 0 || heartbeatPause();\n\t\t\tonDisconnected === null || onDisconnected === void 0 || onDisconnected(ws, ev);\n\t\t\tif (!explicitlyClosed && options.autoReconnect && (wsRef.value == null || ws === wsRef.value)) {\n\t\t\t\tconst { retries = -1, delay = 1e3, onFailed } = resolveNestedOptions(options.autoReconnect);\n\t\t\t\tif ((typeof retries === \"function\" ? retries : () => typeof retries === \"number\" && (retries < 0 || retried < retries))(retried)) {\n\t\t\t\t\tretried += 1;\n\t\t\t\t\tconst delayTime = typeof delay === \"function\" ? delay(retried) : delay;\n\t\t\t\t\tretryTimeout = setTimeout(_init, delayTime);\n\t\t\t\t} else onFailed === null || onFailed === void 0 || onFailed();\n\t\t\t}\n\t\t};\n\t\tws.onerror = (e) => {\n\t\t\tonError === null || onError === void 0 || onError(ws, e);\n\t\t};\n\t\tws.onmessage = (e) => {\n\t\t\tif (options.heartbeat) {\n\t\t\t\tresetHeartbeat();\n\t\t\t\tconst { message = DEFAULT_PING_MESSAGE, responseMessage = message } = resolveNestedOptions(options.heartbeat);\n\t\t\t\tif (e.data === toValue(responseMessage)) return;\n\t\t\t}\n\t\t\tdata.value = e.data;\n\t\t\tonMessage === null || onMessage === void 0 || onMessage(ws, e);\n\t\t};\n\t};\n\tif (options.heartbeat) {\n\t\tconst { message = DEFAULT_PING_MESSAGE, scheduler = getDefaultScheduler(resolveNestedOptions(options.heartbeat)), pongTimeout = 1e3 } = resolveNestedOptions(options.heartbeat);\n\t\tconst { pause, resume } = scheduler(() => {\n\t\t\tsend(toValue(message), false);\n\t\t\tif (pongTimeoutWait != null) return;\n\t\t\tpongTimeoutWait = setTimeout(() => {\n\t\t\t\tclose();\n\t\t\t\texplicitlyClosed = false;\n\t\t\t}, pongTimeout);\n\t\t});\n\t\theartbeatPause = pause;\n\t\theartbeatResume = resume;\n\t}\n\tif (autoClose) {\n\t\tif (isClient) useEventListener(\"beforeunload\", () => close(), { passive: true });\n\t\ttryOnScopeDispose(close);\n\t}\n\tconst open = () => {\n\t\tif (!isClient && !isWorker) return;\n\t\tclose();\n\t\texplicitlyClosed = false;\n\t\tretried = 0;\n\t\t_init();\n\t};\n\tif (immediate) open();\n\tif (autoConnect) watch(urlRef, open);\n\treturn {\n\t\tdata,\n\t\tstatus,\n\t\tclose,\n\t\tsend,\n\t\topen,\n\t\tws: wsRef\n\t};\n}\n\n//#endregion\n//#region useWebWorker/index.ts\nfunction useWebWorker(arg0, workerOptions, options) {\n\tconst { window: window$1 = defaultWindow } = options !== null && options !== void 0 ? options : {};\n\tconst data = ref(null);\n\tconst worker = shallowRef();\n\tconst post = (...args) => {\n\t\tif (!worker.value) return;\n\t\tworker.value.postMessage(...args);\n\t};\n\tconst terminate = function terminate$1() {\n\t\tif (!worker.value) return;\n\t\tworker.value.terminate();\n\t};\n\tif (window$1) {\n\t\tif (typeof arg0 === \"string\") worker.value = new Worker(arg0, workerOptions);\n\t\telse if (typeof arg0 === \"function\") worker.value = arg0();\n\t\telse worker.value = arg0;\n\t\tworker.value.onmessage = (e) => {\n\t\t\tdata.value = e.data;\n\t\t};\n\t\ttryOnScopeDispose(() => {\n\t\t\tif (worker.value) worker.value.terminate();\n\t\t});\n\t}\n\treturn {\n\t\tdata,\n\t\tpost,\n\t\tterminate,\n\t\tworker\n\t};\n}\n\n//#endregion\n//#region useWebWorkerFn/lib/depsParser.ts\n/**\n*\n* Concatenates the dependencies into a comma separated string.\n* this string will then be passed as an argument to the \"importScripts\" function\n*\n* @param deps array of string\n* @param localDeps array of function\n* @returns a string composed by the concatenation of the array\n* elements \"deps\" and \"importScripts\".\n*\n* @example\n* depsParser(['demo1', 'demo2']) // return importScripts('demo1', 'demo2')\n*/\nfunction depsParser(deps, localDeps) {\n\tif (deps.length === 0 && localDeps.length === 0) return \"\";\n\tconst depsString = deps.map((dep) => `'${dep}'`).toString();\n\tconst depsFunctionString = localDeps.filter((dep) => typeof dep === \"function\").map((fn) => {\n\t\tconst str = fn.toString();\n\t\tif (str.trim().startsWith(\"function\")) return str;\n\t\telse return `const ${fn.name} = ${str}`;\n\t}).join(\";\");\n\tconst importString = `importScripts(${depsString});`;\n\treturn `${depsString.trim() === \"\" ? \"\" : importString} ${depsFunctionString}`;\n}\nvar depsParser_default = depsParser;\n\n//#endregion\n//#region useWebWorkerFn/lib/jobRunner.ts\n/**\n* This function accepts as a parameter a function \"userFunc\"\n* And as a result returns an anonymous function.\n* This anonymous function, accepts as arguments,\n* the parameters to pass to the function \"useArgs\" and returns a Promise\n* This function can be used as a wrapper, only inside a Worker\n* because it depends by \"postMessage\".\n*\n* @param userFunc {Function} fn the function to run with web worker\n*\n* @returns returns a function that accepts the parameters\n* to be passed to the \"userFunc\" function\n*/\nfunction jobRunner(userFunc) {\n\treturn (e) => {\n\t\tconst userFuncArgs = e.data[0];\n\t\treturn Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n\t\t\tpostMessage([\"SUCCESS\", result]);\n\t\t}).catch((error) => {\n\t\t\tpostMessage([\"ERROR\", error]);\n\t\t});\n\t};\n}\nvar jobRunner_default = jobRunner;\n\n//#endregion\n//#region useWebWorkerFn/lib/createWorkerBlobUrl.ts\n/**\n* Converts the \"fn\" function into the syntax needed to be executed within a web worker\n*\n* @param fn the function to run with web worker\n* @param deps array of strings, imported into the worker through \"importScripts\"\n* @param localDeps array of function, local dependencies\n*\n* @returns a blob url, containing the code of \"fn\" as a string\n*\n* @example\n* createWorkerBlobUrl((a,b) => a+b, [])\n* // return \"onmessage=return Promise.resolve((a,b) => a + b)\n* .then(postMessage(['SUCCESS', result]))\n* .catch(postMessage(['ERROR', error])\"\n*/\nfunction createWorkerBlobUrl(fn, deps, localDeps) {\n\tconst blobCode = `${depsParser_default(deps, localDeps)}; onmessage=(${jobRunner_default})(${fn})`;\n\tconst blob = new Blob([blobCode], { type: \"text/javascript\" });\n\treturn URL.createObjectURL(blob);\n}\nvar createWorkerBlobUrl_default = createWorkerBlobUrl;\n\n//#endregion\n//#region useWebWorkerFn/index.ts\n/**\n* Run expensive function without blocking the UI, using a simple syntax that makes use of Promise.\n*\n* @see https://vueuse.org/useWebWorkerFn\n* @param fn\n* @param options\n*/\nfunction useWebWorkerFn(fn, options = {}) {\n\tconst { dependencies = [], localDependencies = [], timeout, window: window$1 = defaultWindow } = options;\n\tconst worker = ref();\n\tconst workerStatus = shallowRef(\"PENDING\");\n\tconst promise = ref({});\n\tconst timeoutId = shallowRef();\n\tconst workerTerminate = (status = \"PENDING\") => {\n\t\tif (worker.value && worker.value._url && window$1) {\n\t\t\tworker.value.terminate();\n\t\t\tURL.revokeObjectURL(worker.value._url);\n\t\t\tpromise.value = {};\n\t\t\tworker.value = void 0;\n\t\t\twindow$1.clearTimeout(timeoutId.value);\n\t\t\tworkerStatus.value = status;\n\t\t}\n\t};\n\tworkerTerminate();\n\ttryOnScopeDispose(workerTerminate);\n\tconst generateWorker = () => {\n\t\tconst blobUrl = createWorkerBlobUrl_default(fn, dependencies, localDependencies);\n\t\tconst newWorker = new Worker(blobUrl);\n\t\tnewWorker._url = blobUrl;\n\t\tnewWorker.onmessage = (e) => {\n\t\t\tconst { resolve = () => {}, reject = () => {} } = promise.value;\n\t\t\tconst [status, result] = e.data;\n\t\t\tswitch (status) {\n\t\t\t\tcase \"SUCCESS\":\n\t\t\t\t\tresolve(result);\n\t\t\t\t\tworkerTerminate(status);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treject(result);\n\t\t\t\t\tworkerTerminate(\"ERROR\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t\tnewWorker.onerror = (e) => {\n\t\t\tconst { reject = () => {} } = promise.value;\n\t\t\te.preventDefault();\n\t\t\treject(e);\n\t\t\tworkerTerminate(\"ERROR\");\n\t\t};\n\t\tif (timeout) timeoutId.value = setTimeout(() => workerTerminate(\"TIMEOUT_EXPIRED\"), timeout);\n\t\treturn newWorker;\n\t};\n\tconst callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n\t\tvar _worker$value;\n\t\tpromise.value = {\n\t\t\tresolve,\n\t\t\treject\n\t\t};\n\t\t(_worker$value = worker.value) === null || _worker$value === void 0 || _worker$value.postMessage([[...fnArgs]]);\n\t\tworkerStatus.value = \"RUNNING\";\n\t});\n\tconst workerFn = (...fnArgs) => {\n\t\tif (workerStatus.value === \"RUNNING\") {\n\t\t\tconsole.error(\"[useWebWorkerFn] You can only run one instance of the worker at a time.\");\n\t\t\treturn Promise.reject();\n\t\t}\n\t\tworker.value = generateWorker();\n\t\treturn callWorker(...fnArgs);\n\t};\n\treturn {\n\t\tworkerFn,\n\t\tworkerStatus,\n\t\tworkerTerminate\n\t};\n}\n\n//#endregion\n//#region useWindowFocus/index.ts\n/**\n* Reactively track window focus with `window.onfocus` and `window.onblur`.\n*\n* @see https://vueuse.org/useWindowFocus\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useWindowFocus(options = {}) {\n\tconst { window: window$1 = defaultWindow } = options;\n\tif (!window$1) return shallowRef(false);\n\tconst focused = shallowRef(window$1.document.hasFocus());\n\tconst listenerOptions = { passive: true };\n\tuseEventListener(window$1, \"blur\", () => {\n\t\tfocused.value = false;\n\t}, listenerOptions);\n\tuseEventListener(window$1, \"focus\", () => {\n\t\tfocused.value = true;\n\t}, listenerOptions);\n\treturn focused;\n}\n\n//#endregion\n//#region useWindowScroll/index.ts\n/**\n* Reactive window scroll.\n*\n* @see https://vueuse.org/useWindowScroll\n* @param options\n*/\nfunction useWindowScroll(options = {}) {\n\tconst { window: window$1 = defaultWindow,...rest } = options;\n\treturn useScroll(window$1, rest);\n}\n\n//#endregion\n//#region useWindowSize/index.ts\n/**\n* Reactive window size.\n*\n* @see https://vueuse.org/useWindowSize\n* @param options\n*\n* @__NO_SIDE_EFFECTS__\n*/\nfunction useWindowSize(options = {}) {\n\tconst { window: window$1 = defaultWindow, initialWidth = Number.POSITIVE_INFINITY, initialHeight = Number.POSITIVE_INFINITY, listenOrientation = true, includeScrollbar = true, type = \"inner\" } = options;\n\tconst width = shallowRef(initialWidth);\n\tconst height = shallowRef(initialHeight);\n\tconst update = () => {\n\t\tif (window$1) if (type === \"outer\") {\n\t\t\twidth.value = window$1.outerWidth;\n\t\t\theight.value = window$1.outerHeight;\n\t\t} else if (type === \"visual\" && window$1.visualViewport) {\n\t\t\tconst { width: visualViewportWidth, height: visualViewportHeight, scale } = window$1.visualViewport;\n\t\t\twidth.value = Math.round(visualViewportWidth * scale);\n\t\t\theight.value = Math.round(visualViewportHeight * scale);\n\t\t} else if (includeScrollbar) {\n\t\t\twidth.value = window$1.innerWidth;\n\t\t\theight.value = window$1.innerHeight;\n\t\t} else {\n\t\t\twidth.value = window$1.document.documentElement.clientWidth;\n\t\t\theight.value = window$1.document.documentElement.clientHeight;\n\t\t}\n\t};\n\tupdate();\n\ttryOnMounted(update);\n\tconst listenerOptions = { passive: true };\n\tuseEventListener(\"resize\", update, listenerOptions);\n\tif (window$1 && type === \"visual\" && window$1.visualViewport) useEventListener(window$1.visualViewport, \"resize\", update, listenerOptions);\n\tif (listenOrientation) watch(useMediaQuery(\"(orientation: portrait)\"), () => update());\n\treturn {\n\t\twidth,\n\t\theight\n\t};\n}\n\n//#endregion\nexport { DefaultMagicKeysAliasMap, StorageSerializers, TransitionPresets, asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsElement, breakpointsMasterCss, breakpointsPrimeFlex, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, breakpointsVuetifyV2, breakpointsVuetifyV3, cloneFnJSON, computedAsync, computedInject, createFetch, createReusableTemplate, createTemplatePromise, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, executeTransition, formatTimeAgo, formatTimeAgoIntl, formatTimeAgoIntlParts, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onElementRemoval, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, provideSSRWidth, setSSRHandler, templateRef, transition, unrefElement, useActiveElement, useAnimate, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useClipboardItems, useCloned, useColorMode, useConfirmDialog, useCountdown, useCssSupports, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, useParentElement, usePerformanceObserver, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePreferredReducedTransparency, usePrevious, useRafFn, useRefHistory, useResizeObserver, useSSRWidth, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeAgoIntl, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };","import { ref, readonly } from \"vue\";\nconst MOBILE_BREAKPOINT = 1024;\nconst MOBILE_SMALL_BREAKPOINT = MOBILE_BREAKPOINT / 2;\nconst isLessThanBreakpoint = (breakpoint) => document.documentElement.clientWidth < breakpoint;\nconst isMobile = ref(isLessThanBreakpoint(MOBILE_BREAKPOINT));\nconst isSmallMobile = ref(isLessThanBreakpoint(MOBILE_SMALL_BREAKPOINT));\nwindow.addEventListener(\"resize\", () => {\n  isMobile.value = isLessThanBreakpoint(MOBILE_BREAKPOINT);\n  isSmallMobile.value = isLessThanBreakpoint(MOBILE_SMALL_BREAKPOINT);\n}, { passive: true });\nfunction useIsMobile() {\n  return readonly(isMobile);\n}\nfunction useIsSmallMobile() {\n  return readonly(isSmallMobile);\n}\nexport {\n  MOBILE_BREAKPOINT,\n  MOBILE_SMALL_BREAKPOINT,\n  useIsMobile,\n  useIsSmallMobile\n};\n//# sourceMappingURL=index.mjs.map\n","import { defineComponent, ref, createBlock, openBlock, unref, withCtx, createTextVNode, toDisplayString, renderSlot, createCommentVNode } from \"vue\";\nimport { r as register, f as t33, a as t } from \"./_l10n-Dq_eYxz_.mjs\";\nimport { N as NcButton } from \"./NcButton-C9D47Igd.mjs\";\nimport { N as NcIconSvgWrapper } from \"./NcIconSvgWrapper-BvLanNaW.mjs\";\nimport { N as NcLoadingIcon } from \"./NcLoadingIcon-b_ajZ_nQ.mjs\";\nregister(t33);\nconst _sfc_main = /* @__PURE__ */ defineComponent({\n  __name: \"NcDialogButton\",\n  props: {\n    callback: { type: Function, default: () => {\n    } },\n    disabled: { type: Boolean, default: false },\n    icon: { default: void 0 },\n    label: {},\n    type: { default: \"button\" },\n    variant: { default: \"tertiary\" }\n  },\n  emits: [\"click\"],\n  setup(__props, { emit: __emit }) {\n    const props = __props;\n    const emit = __emit;\n    const isLoading = ref(false);\n    async function handleClick(e) {\n      if (isLoading.value) {\n        return;\n      }\n      isLoading.value = true;\n      try {\n        const fallback = props.type === \"reset\" ? false : void 0;\n        const result = await props.callback?.() ?? fallback;\n        if (result !== false) {\n          emit(\"click\", e, result);\n        }\n      } finally {\n        isLoading.value = false;\n      }\n    }\n    return (_ctx, _cache) => {\n      return openBlock(), createBlock(unref(NcButton), {\n        \"aria-label\": _ctx.label,\n        disabled: _ctx.disabled,\n        type: _ctx.type,\n        variant: _ctx.variant,\n        onClick: handleClick\n      }, {\n        icon: withCtx(() => [\n          renderSlot(_ctx.$slots, \"icon\", {}, () => [\n            isLoading.value ? (openBlock(), createBlock(unref(NcLoadingIcon), {\n              key: 0,\n              name: unref(t)(\"LoadingÂ â€¦\")\n              /* TRANSLATORS: The button is in a loading state*/\n            }, null, 8, [\"name\"])) : _ctx.icon !== void 0 ? (openBlock(), createBlock(unref(NcIconSvgWrapper), {\n              key: 1,\n              svg: _ctx.icon\n            }, null, 8, [\"svg\"])) : createCommentVNode(\"\", true)\n          ])\n        ]),\n        default: withCtx(() => [\n          createTextVNode(toDisplayString(_ctx.label) + \" \", 1)\n        ]),\n        _: 3\n      }, 8, [\"aria-label\", \"disabled\", \"type\", \"variant\"]);\n    };\n  }\n});\nexport {\n  _sfc_main as _\n};\n//# sourceMappingURL=NcDialogButton.vue_vue_type_script_setup_true_lang-DABuSwSR.mjs.map\n","import { formatRelativeTime, getCanonicalLocale } from \"@nextcloud/l10n\";\nimport { computed, toValue, ref, watchEffect, onUnmounted, readonly } from \"vue\";\nimport { r as register, d as t2, a as t } from \"../../chunks/_l10n-Dq_eYxz_.mjs\";\nregister(t2);\nconst FEW_SECONDS_AGO = {\n  long: t(\"a few seconds ago\"),\n  short: t(\"seconds ago\"),\n  // FOR TRANSLATORS: Shorter version of 'a few seconds ago'\n  narrow: t(\"sec. ago\")\n  // FOR TRANSLATORS: If possible in your language an even shorter version of 'a few seconds ago'\n};\nfunction useFormatRelativeTime(timestamp = Date.now(), opts = {}) {\n  let timeoutId;\n  const date = computed(() => new Date(toValue(timestamp)));\n  const options = computed(() => {\n    const { language, relativeTime: relativeTime2, ignoreSeconds } = toValue(opts);\n    return {\n      ...language && { language },\n      ...relativeTime2 && { relativeTime: relativeTime2 },\n      ignoreSeconds: ignoreSeconds ? FEW_SECONDS_AGO[relativeTime2 || \"long\"] : false\n    };\n  });\n  const relativeTime = ref(\"\");\n  watchEffect(() => updateRelativeTime());\n  function updateRelativeTime() {\n    relativeTime.value = formatRelativeTime(date.value, options.value);\n    if (toValue(opts).update !== false) {\n      const diff = Math.abs(Date.now() - new Date(toValue(timestamp)).getTime());\n      const interval = diff > 12e4 || options.value.ignoreSeconds ? Math.min(diff / 60, 18e5) : 1e3;\n      timeoutId = window.setTimeout(updateRelativeTime, interval);\n    }\n  }\n  onUnmounted(() => timeoutId && window.clearTimeout(timeoutId));\n  return readonly(relativeTime);\n}\nfunction useFormatTime(timestamp, opts) {\n  const options = computed(() => ({\n    locale: getCanonicalLocale(),\n    format: { dateStyle: \"short\", timeStyle: \"medium\" },\n    ...toValue(opts)\n  }));\n  const formatter = computed(() => new Intl.DateTimeFormat(options.value.locale, options.value.format));\n  return computed(() => formatter.value.format(toValue(timestamp)));\n}\nexport {\n  useFormatRelativeTime,\n  useFormatTime\n};\n//# sourceMappingURL=index.mjs.map\n","const isMac = /mac|ipad|iphone|darwin/i.test(navigator.userAgent);\nexport {\n  isMac as i\n};\n//# sourceMappingURL=platform-CC2ecGvV.mjs.map\n","import { onKeyStroke } from \"@vueuse/core\";\nimport { i as isMac } from \"../../chunks/platform-CC2ecGvV.mjs\";\nconst disableKeyboardShortcuts = window.OCP?.Accessibility?.disableKeyboardShortcuts?.();\nconst derivedKeysRegex = /^[a-zA-Z0-9]$/;\nconst nonAsciiPrintableRegex = /^[^\\x20-\\x7F]$/;\nfunction shouldIgnoreEvent(event, options) {\n  if (!(event.target instanceof HTMLElement) || event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement || event.target instanceof HTMLSelectElement || event.target.isContentEditable) {\n    return true;\n  }\n  if (options.allowInModal) {\n    return false;\n  }\n  return Array.from(document.getElementsByClassName(\"modal-mask\")).filter((el) => el.checkVisibility()).length > 0;\n}\nfunction eventHandler(callback, options) {\n  return (event) => {\n    const ctrlKeyPressed = isMac ? event.metaKey : event.ctrlKey;\n    if (ctrlKeyPressed !== Boolean(options.ctrl)) {\n      return;\n    } else if (event.altKey !== Boolean(options.alt)) {\n      return;\n    } else if (options.shift !== void 0 && event.shiftKey !== Boolean(options.shift)) {\n      return;\n    } else if (shouldIgnoreEvent(event, options)) {\n      return;\n    }\n    if (options.prevent) {\n      event.preventDefault();\n    }\n    if (options.stop) {\n      event.stopPropagation();\n    }\n    callback(event);\n  };\n}\nfunction useHotKey(keysOrFilter, callback = () => {\n}, options = {}) {\n  if (disableKeyboardShortcuts) {\n    return () => {\n    };\n  }\n  const validateKeyEvent = (event, key) => {\n    if (event.key === key) {\n      return true;\n    }\n    if (options.caseSensitive) {\n      const isKeyInLowerCase = key === key.toLowerCase();\n      const isEventKeyInLowerCase = event.key === event.key.toLowerCase();\n      if (isKeyInLowerCase !== isEventKeyInLowerCase) {\n        return false;\n      }\n    }\n    if (derivedKeysRegex.test(key) && nonAsciiPrintableRegex.test(event.key)) {\n      return event.code.replace(/^(?:Key|Digit|Numpad)/, \"\") === key.toUpperCase();\n    }\n    return event.key.toLowerCase() === key.toLowerCase();\n  };\n  const keyFilter = (event) => {\n    if (typeof keysOrFilter === \"function\") {\n      return keysOrFilter(event);\n    } else if (typeof keysOrFilter === \"string\") {\n      return validateKeyEvent(event, keysOrFilter);\n    } else if (Array.isArray(keysOrFilter)) {\n      return keysOrFilter.some((key) => validateKeyEvent(event, key));\n    } else {\n      return true;\n    }\n  };\n  const stopKeyDown = onKeyStroke(keyFilter, eventHandler(callback, options), {\n    eventName: \"keydown\",\n    dedupe: true,\n    passive: !options.prevent\n  });\n  const stopKeyUp = options.push ? onKeyStroke(keyFilter, eventHandler(callback, options), {\n    eventName: \"keyup\",\n    passive: !options.prevent\n  }) : () => {\n  };\n  return () => {\n    stopKeyDown();\n    stopKeyUp();\n  };\n}\nexport {\n  useHotKey\n};\n//# sourceMappingURL=index.mjs.map\n","function checkIfDarkTheme(el = document.body) {\n  const backgroundInvertIfDark = window.getComputedStyle(el).getPropertyValue(\"--background-invert-if-dark\");\n  if (backgroundInvertIfDark !== void 0) {\n    return backgroundInvertIfDark === \"invert(100%)\";\n  }\n  return false;\n}\nconst isDarkTheme = checkIfDarkTheme();\nexport {\n  checkIfDarkTheme,\n  isDarkTheme\n};\n//# sourceMappingURL=index.mjs.map\n","import { ref, readonly } from \"vue\";\nconst isFullscreen = ref(checkIfIsFullscreen());\nwindow.addEventListener(\"resize\", () => {\n  isFullscreen.value = checkIfIsFullscreen();\n});\nfunction checkIfIsFullscreen() {\n  return window.outerHeight === window.screen.height;\n}\nfunction useIsFullscreen() {\n  return readonly(isFullscreen);\n}\nexport {\n  useIsFullscreen\n};\n//# sourceMappingURL=index.mjs.map\n","import '../assets/NcModal-bYmoCrzo.css';\nimport { getCurrentInstance, warn, defineComponent, mergeModels, useCssVars, computed, useModel, useTemplateRef, onMounted, onUnmounted, watch, toRef, ref, watchEffect, nextTick, createBlock, openBlock, Teleport, createVNode, Transition, withCtx, withDirectives, createElementVNode, mergeProps, unref, createElementBlock, createCommentVNode, toDisplayString, normalizeClass, renderSlot, withModifiers, vShow } from \"vue\";\nimport { E as mdiPause, F as mdiPlay, b as mdiClose, z as mdiChevronLeft, c as mdiChevronRight } from \"./mdi-CpchYUUV.mjs\";\nimport { useIntervalFn, useSwipe } from \"@vueuse/core\";\nimport { createFocusTrap } from \"focus-trap\";\nimport { N as NcActions } from \"./NcActions-BWDsG06k.mjs\";\nimport { N as NcButton } from \"./NcButton-C9D47Igd.mjs\";\nimport { N as NcIconSvgWrapper } from \"./NcIconSvgWrapper-BvLanNaW.mjs\";\nimport \"../composables/useFormatDateTime/index.mjs\";\nimport { useHotKey } from \"../composables/useHotKey/index.mjs\";\nimport \"../composables/useIsDarkTheme/index.mjs\";\nimport \"../composables/useIsFullscreen/index.mjs\";\nimport \"../composables/useIsMobile/index.mjs\";\nimport { r as register, D as t36, A as t19, a as t } from \"./_l10n-Dq_eYxz_.mjs\";\nimport { c as createElementId } from \"./createElementId-DhjFt1I9.mjs\";\nimport { g as getTrapStack } from \"./focusTrap-HJQ4pqHV.mjs\";\nimport { i as isRtl } from \"./rtl-v0UOPAM7.mjs\";\nimport { _ as _export_sfc } from \"./_plugin-vue_export-helper-1tPrXgE0.mjs\";\n/*!\n * SPDX-FileCopyrightText: 2025 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\nfunction getSameNodeParent(instance) {\n  if (!instance.parent) {\n    return null;\n  }\n  if (\"vapor\" in instance || \"vapor\" in instance.parent) {\n    warn(\"Vapor instances are not supported in useScopeIdAttrs :(\");\n    return null;\n  }\n  if (instance.parent.subTree !== instance.vnode) {\n    return null;\n  }\n  return instance.parent;\n}\nfunction getSameNodeAncestors(instance) {\n  const ancestors = [instance];\n  let parent = getSameNodeParent(instance);\n  while (parent) {\n    ancestors.push(parent);\n    parent = getSameNodeParent(parent);\n  }\n  return ancestors;\n}\nfunction useScopeIdAttrs() {\n  const instance = getCurrentInstance();\n  if (!instance) {\n    throw new Error(\"useScopeId must be called within a setup context\");\n  }\n  const sameNodeAncestors = getSameNodeAncestors(instance);\n  const scopeIds = sameNodeAncestors.map((instance2) => instance2.vnode.scopeId).filter(Boolean);\n  const scopeIdAttrs = Object.fromEntries(scopeIds.map((scopeId) => [scopeId, \"\"]));\n  return scopeIdAttrs;\n}\nregister(t19, t36);\nconst _hoisted_1 = [\"aria-labelledby\", \"aria-describedby\"];\nconst _hoisted_2 = [\"data-theme-light\", \"data-theme-dark\"];\nconst _hoisted_3 = [\"id\"];\nconst _hoisted_4 = { class: \"icons-menu\" };\nconst _hoisted_5 = [\"title\"];\nconst _hoisted_6 = [\"id\"];\nconst _hoisted_7 = { class: \"modal-container__content\" };\nconst _sfc_main = /* @__PURE__ */ defineComponent({\n  ...{ inheritAttrs: false },\n  __name: \"NcModal\",\n  props: /* @__PURE__ */ mergeModels({\n    name: { default: \"\" },\n    hasPrevious: { type: Boolean },\n    hasNext: { type: Boolean },\n    outTransition: { type: Boolean },\n    enableSlideshow: { type: Boolean },\n    slideshowDelay: { default: 5e3 },\n    slideshowPaused: { type: Boolean },\n    disableSwipe: { type: Boolean },\n    spreadNavigation: { type: Boolean },\n    size: { default: \"normal\" },\n    noClose: { type: Boolean },\n    closeOnClickOutside: { type: Boolean },\n    dark: { type: Boolean },\n    lightBackdrop: { type: Boolean },\n    container: { default: \"body\" },\n    closeButtonOutside: { type: Boolean },\n    additionalTrapElements: { default: () => [] },\n    inlineActions: { default: 0 },\n    labelId: { default: \"\" },\n    setReturnFocus: { default: void 0 }\n  }, {\n    \"show\": { type: Boolean, ...{ default: true } },\n    \"showModifiers\": {}\n  }),\n  emits: /* @__PURE__ */ mergeModels([\"next\", \"previous\", \"close\", \"update:show\"], [\"update:show\"]),\n  setup(__props, { emit: __emit }) {\n    useCssVars((_ctx) => ({\n      \"7f724f28\": cssSlideshowDelay.value\n    }));\n    const showModal = useModel(__props, \"show\");\n    const props = __props;\n    const emit = __emit;\n    const scopeIdAttrs = useScopeIdAttrs();\n    const modalId = createElementId();\n    const maskElement = useTemplateRef(\"mask\");\n    let focusTrap;\n    onMounted(() => useFocusTrap());\n    onUnmounted(() => clearFocusTrap());\n    watch(() => props.additionalTrapElements, (elements) => {\n      if (focusTrap) {\n        focusTrap.updateContainerElements([maskElement.value, ...elements]);\n      }\n    });\n    const {\n      isActive: isPlaying,\n      pause: stopSlideshow,\n      resume: startSlideshow\n    } = useIntervalFn(nextSlide, toRef(() => props.slideshowDelay), { immediate: false });\n    const animationKey = ref(0);\n    const runSlideshow = ref(false);\n    watchEffect(() => {\n      if (runSlideshow.value && !props.slideshowPaused) {\n        startSlideshow();\n      } else if (isPlaying.value) {\n        stopSlideshow();\n      }\n    });\n    const cssSlideshowDelay = computed(() => `${props.slideshowDelay}ms`);\n    const { stop: stopSwipe } = useSwipe(maskElement, {\n      onSwipeEnd: handleSwipe\n    });\n    onUnmounted(stopSwipe);\n    useHotKey(\"Escape\", () => {\n      const trapStack = getTrapStack();\n      if (trapStack.at(-1) === focusTrap) {\n        close();\n      }\n    }, { allowInModal: true });\n    useHotKey([\"ArrowLeft\", \"ArrowRight\"], (event) => {\n      if (document.activeElement && !maskElement.value.contains(document.activeElement)) {\n        return;\n      }\n      if (event.key === \"ArrowLeft\" !== isRtl) {\n        previousSlide();\n      } else {\n        nextSlide();\n      }\n    }, { allowInModal: true });\n    onMounted(() => {\n      if (!props.name && !props.labelId) {\n        warn(\"[NcModal] You need either set the name or set a `labelId` for accessibility.\");\n      }\n    });\n    function nextSlide(event) {\n      if (!props.hasNext) {\n        runSlideshow.value = false;\n        return;\n      }\n      if (event && isPlaying.value) {\n        restartSlideshow();\n      }\n      emit(\"next\", event);\n    }\n    function previousSlide(event) {\n      if (!props.hasPrevious) {\n        return;\n      }\n      if (event && isPlaying.value) {\n        restartSlideshow();\n      }\n      emit(\"previous\", event);\n    }\n    function handleSwipe(e, direction) {\n      if (!props.disableSwipe) {\n        if (direction !== \"left\" && direction !== \"right\") {\n          return;\n        }\n        if (direction === \"left\" !== isRtl) {\n          nextSlide(e);\n        } else {\n          previousSlide(e);\n        }\n      }\n    }\n    function restartSlideshow() {\n      stopSlideshow();\n      startSlideshow();\n      animationKey.value++;\n    }\n    function close(event) {\n      if (props.noClose) {\n        return;\n      }\n      showModal.value = false;\n      setTimeout(() => {\n        emit(\"close\", event);\n      }, 300);\n    }\n    function handleClickModalWrapper(event) {\n      if (props.closeOnClickOutside) {\n        close(event);\n      }\n    }\n    async function useFocusTrap() {\n      if (!showModal.value || focusTrap) {\n        return;\n      }\n      await nextTick();\n      const options = {\n        allowOutsideClick: true,\n        fallbackFocus: maskElement.value,\n        trapStack: getTrapStack(),\n        // Esc can be used without stop in content or additionalTrapElements where it should not deactivate modal's focus trap.\n        // Focus trap is deactivated on modal close anyway.\n        escapeDeactivates: false,\n        setReturnFocus: props.setReturnFocus\n      };\n      focusTrap = createFocusTrap([maskElement.value, ...props.additionalTrapElements], options);\n      focusTrap.activate();\n    }\n    function clearFocusTrap() {\n      if (!focusTrap) {\n        return;\n      }\n      focusTrap?.deactivate();\n      focusTrap = void 0;\n    }\n    return (_ctx, _cache) => {\n      return openBlock(), createBlock(Teleport, {\n        disabled: _ctx.container === null,\n        to: _ctx.container\n      }, [\n        createVNode(Transition, {\n          name: \"fade\",\n          appear: \"\",\n          onAfterEnter: useFocusTrap,\n          onBeforeLeave: clearFocusTrap\n        }, {\n          default: withCtx(() => [\n            withDirectives(createElementVNode(\"div\", mergeProps({ ..._ctx.$attrs, ...unref(scopeIdAttrs) }, {\n              ref: \"mask\",\n              class: [\"modal-mask\", {\n                \"modal-mask--opaque\": _ctx.dark || _ctx.closeButtonOutside || _ctx.hasPrevious || _ctx.hasNext,\n                \"modal-mask--light\": _ctx.lightBackdrop\n              }],\n              role: \"dialog\",\n              \"aria-modal\": \"true\",\n              \"aria-labelledby\": _ctx.labelId || `modal-name-${unref(modalId)}`,\n              \"aria-describedby\": \"modal-description-\" + unref(modalId),\n              tabindex: \"-1\"\n            }), [\n              createVNode(Transition, {\n                name: \"fade-visibility\",\n                appear: \"\"\n              }, {\n                default: withCtx(() => [\n                  createElementVNode(\"div\", {\n                    class: \"modal-header\",\n                    \"data-theme-light\": _ctx.lightBackdrop,\n                    \"data-theme-dark\": !_ctx.lightBackdrop\n                  }, [\n                    _ctx.name.trim() !== \"\" ? (openBlock(), createElementBlock(\"h2\", {\n                      key: 0,\n                      id: \"modal-name-\" + unref(modalId),\n                      class: \"modal-header__name\"\n                    }, toDisplayString(_ctx.name), 9, _hoisted_3)) : createCommentVNode(\"\", true),\n                    createElementVNode(\"div\", _hoisted_4, [\n                      _ctx.hasNext && _ctx.enableSlideshow ? (openBlock(), createElementBlock(\"button\", {\n                        key: 0,\n                        class: normalizeClass([\"play-pause-icons\", { \"play-pause-icons--paused\": _ctx.slideshowPaused }]),\n                        title: unref(isPlaying) ? unref(t)(\"Pause slideshow\") : unref(t)(\"Start slideshow\"),\n                        type: \"button\",\n                        onClick: _cache[0] || (_cache[0] = ($event) => runSlideshow.value = !runSlideshow.value)\n                      }, [\n                        createVNode(NcIconSvgWrapper, {\n                          class: \"play-pause-icons__icon\",\n                          inline: \"\",\n                          name: unref(isPlaying) ? unref(t)(\"Pause slideshow\") : unref(t)(\"Start slideshow\"),\n                          path: unref(isPlaying) ? unref(mdiPause) : unref(mdiPlay)\n                        }, null, 8, [\"name\", \"path\"]),\n                        unref(isPlaying) ? (openBlock(), createElementBlock(\"svg\", {\n                          key: `${unref(modalId)}-animation-${animationKey.value}`,\n                          class: \"progress-ring\",\n                          height: \"50\",\n                          width: \"50\"\n                        }, [..._cache[1] || (_cache[1] = [\n                          createElementVNode(\"circle\", {\n                            class: \"progress-ring__circle\",\n                            stroke: \"white\",\n                            \"stroke-width\": \"2\",\n                            fill: \"transparent\",\n                            r: \"15\",\n                            cx: \"25\",\n                            cy: \"25\"\n                          }, null, -1)\n                        ])])) : createCommentVNode(\"\", true)\n                      ], 10, _hoisted_5)) : createCommentVNode(\"\", true),\n                      createVNode(NcActions, {\n                        class: \"header-actions\",\n                        inline: _ctx.inlineActions\n                      }, {\n                        default: withCtx(() => [\n                          renderSlot(_ctx.$slots, \"actions\", {}, void 0, true)\n                        ]),\n                        _: 3\n                      }, 8, [\"inline\"]),\n                      !_ctx.noClose && _ctx.closeButtonOutside ? (openBlock(), createBlock(NcButton, {\n                        key: 1,\n                        \"aria-label\": unref(t)(\"Close\"),\n                        class: \"header-close\",\n                        variant: \"tertiary\",\n                        onClick: close\n                      }, {\n                        icon: withCtx(() => [\n                          createVNode(NcIconSvgWrapper, { path: unref(mdiClose) }, null, 8, [\"path\"])\n                        ]),\n                        _: 1\n                      }, 8, [\"aria-label\"])) : createCommentVNode(\"\", true)\n                    ])\n                  ], 8, _hoisted_2)\n                ]),\n                _: 3\n              }),\n              createVNode(Transition, {\n                name: `modal-${_ctx.outTransition ? \"out\" : \"in\"}`,\n                appear: \"\"\n              }, {\n                default: withCtx(() => [\n                  withDirectives(createElementVNode(\"div\", {\n                    class: normalizeClass([\"modal-wrapper\", [\n                      `modal-wrapper--${_ctx.size}`,\n                      { \"modal-wrapper--spread-navigation\": _ctx.spreadNavigation }\n                    ]]),\n                    onMousedown: withModifiers(handleClickModalWrapper, [\"self\"])\n                  }, [\n                    createVNode(Transition, {\n                      name: \"fade-visibility\",\n                      appear: \"\"\n                    }, {\n                      default: withCtx(() => [\n                        withDirectives(createVNode(NcButton, {\n                          \"aria-label\": unref(t)(\"Previous\"),\n                          class: \"prev\",\n                          variant: \"tertiary-no-background\",\n                          onClick: previousSlide\n                        }, {\n                          icon: withCtx(() => [\n                            createVNode(NcIconSvgWrapper, {\n                              directional: \"\",\n                              path: unref(mdiChevronLeft),\n                              size: 40\n                            }, null, 8, [\"path\"])\n                          ]),\n                          _: 1\n                        }, 8, [\"aria-label\"]), [\n                          [vShow, _ctx.hasPrevious]\n                        ])\n                      ]),\n                      _: 1\n                    }),\n                    createElementVNode(\"div\", {\n                      id: \"modal-description-\" + unref(modalId),\n                      class: \"modal-container\"\n                    }, [\n                      createElementVNode(\"div\", _hoisted_7, [\n                        renderSlot(_ctx.$slots, \"default\", {}, void 0, true)\n                      ]),\n                      !_ctx.noClose && !_ctx.closeButtonOutside ? (openBlock(), createBlock(NcButton, {\n                        key: 0,\n                        \"aria-label\": unref(t)(\"Close\"),\n                        class: \"modal-container__close\",\n                        variant: \"tertiary\",\n                        onClick: close\n                      }, {\n                        icon: withCtx(() => [\n                          createVNode(NcIconSvgWrapper, { path: unref(mdiClose) }, null, 8, [\"path\"])\n                        ]),\n                        _: 1\n                      }, 8, [\"aria-label\"])) : createCommentVNode(\"\", true)\n                    ], 8, _hoisted_6),\n                    createVNode(Transition, {\n                      name: \"fade-visibility\",\n                      appear: \"\"\n                    }, {\n                      default: withCtx(() => [\n                        withDirectives(createVNode(NcButton, {\n                          \"aria-label\": unref(t)(\"Next\"),\n                          class: \"next\",\n                          variant: \"tertiary-no-background\",\n                          onClick: nextSlide\n                        }, {\n                          icon: withCtx(() => [\n                            createVNode(NcIconSvgWrapper, {\n                              directional: \"\",\n                              path: unref(mdiChevronRight),\n                              size: 40\n                            }, null, 8, [\"path\"])\n                          ]),\n                          _: 1\n                        }, 8, [\"aria-label\"]), [\n                          [vShow, _ctx.hasNext]\n                        ])\n                      ]),\n                      _: 1\n                    })\n                  ], 34), [\n                    [vShow, showModal.value]\n                  ])\n                ]),\n                _: 3\n              }, 8, [\"name\"])\n            ], 16, _hoisted_1), [\n              [vShow, showModal.value]\n            ])\n          ]),\n          _: 3\n        })\n      ], 8, [\"disabled\", \"to\"]);\n    };\n  }\n});\nconst NcModal = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"__scopeId\", \"data-v-67fb20ba\"]]);\nexport {\n  NcModal as N\n};\n//# sourceMappingURL=NcModal-DHryP_87.mjs.map\n","import '../assets/NcDialog-BSV74Bru.css';\nimport { defineComponent, mergeModels, useModel, useSlots, useTemplateRef, computed, ref, createBlock, createCommentVNode, openBlock, unref, mergeProps, withCtx, createElementVNode, toDisplayString, resolveDynamicComponent, toHandlers, normalizeClass, createElementBlock, renderSlot, Fragment, renderList } from \"vue\";\nimport { useElementSize } from \"@vueuse/core\";\nimport { c as createElementId } from \"./createElementId-DhjFt1I9.mjs\";\nimport { _ as _sfc_main$1 } from \"./NcDialogButton.vue_vue_type_script_setup_true_lang-DABuSwSR.mjs\";\nimport { N as NcModal } from \"./NcModal-DHryP_87.mjs\";\nimport { _ as _export_sfc } from \"./_plugin-vue_export-helper-1tPrXgE0.mjs\";\nconst _hoisted_1 = [\"id\", \"textContent\"];\nconst _hoisted_2 = [\"aria-label\", \"aria-labelledby\"];\nconst _hoisted_3 = { class: \"dialog__text\" };\nconst _hoisted_4 = { class: \"dialog__actions\" };\nconst _sfc_main = /* @__PURE__ */ defineComponent({\n  __name: \"NcDialog\",\n  props: /* @__PURE__ */ mergeModels({\n    name: {},\n    message: { default: \"\" },\n    additionalTrapElements: { default: () => [] },\n    container: { default: \"body\" },\n    size: { default: \"small\" },\n    buttons: { default: () => [] },\n    isForm: { type: Boolean },\n    noClose: { type: Boolean },\n    closeOnClickOutside: { type: Boolean },\n    outTransition: { type: Boolean },\n    navigationAriaLabel: { default: \"\" },\n    navigationAriaLabelledby: { default: \"\" },\n    contentClasses: { default: \"\" },\n    dialogClasses: { default: \"\" },\n    navigationClasses: { default: \"\" }\n  }, {\n    \"open\": { type: Boolean, ...{ default: true } },\n    \"openModifiers\": {}\n  }),\n  emits: /* @__PURE__ */ mergeModels([\"closing\", \"reset\", \"submit\"], [\"update:open\"]),\n  setup(__props, { emit: __emit }) {\n    const open = useModel(__props, \"open\");\n    const props = __props;\n    const emit = __emit;\n    const slots = useSlots();\n    const wrapperElement = useTemplateRef(\"wrapper\");\n    const { width: dialogWidth } = useElementSize(wrapperElement, { width: 900, height: 0 });\n    const isNavigationCollapsed = computed(() => dialogWidth.value < 876);\n    const hasNavigation = computed(() => slots?.navigation !== void 0);\n    const navigationId = createElementId();\n    const navigationAriaLabelAttr = computed(() => props.navigationAriaLabel || void 0);\n    const navigationAriaLabelledbyAttr = computed(() => {\n      if (props.navigationAriaLabel) {\n        return void 0;\n      }\n      return props.navigationAriaLabelledby || navigationId;\n    });\n    const dialogRootElement = useTemplateRef(\"dialogElement\");\n    const dialogTagName = computed(() => props.isForm && !hasNavigation.value ? \"form\" : \"div\");\n    const dialogListeners = computed(() => {\n      if (dialogTagName.value !== \"form\") {\n        return {};\n      }\n      return {\n        /**\n         * @param event - Form submit event\n         */\n        submit(event) {\n          event.preventDefault();\n          emit(\"submit\", event);\n        },\n        /**\n         * @param event - Form submit event\n         */\n        reset(event) {\n          event.preventDefault();\n          emit(\"reset\", event);\n        }\n      };\n    });\n    const showModal = ref(true);\n    function handleButtonClose(button, result) {\n      if (button.type === \"submit\" && dialogTagName.value === \"form\" && \"reportValidity\" in dialogRootElement.value && !dialogRootElement.value.reportValidity()) {\n        return;\n      }\n      handleClosing(result);\n      window.setTimeout(() => handleClosed(), 300);\n    }\n    function handleClosing(result) {\n      showModal.value = false;\n      emit(\"closing\", result);\n    }\n    function handleClosed() {\n      showModal.value = true;\n      open.value = false;\n    }\n    const modalProps = computed(() => ({\n      noClose: props.noClose,\n      container: props.container === void 0 ? \"body\" : props.container,\n      // we do not pass the name as we already have the name as the headline\n      // name: props.name,\n      // But we need to set the correct label id so the dialog is labelled\n      labelId: navigationId,\n      size: props.size,\n      show: open.value && showModal.value,\n      outTransition: props.outTransition,\n      closeOnClickOutside: props.closeOnClickOutside,\n      additionalTrapElements: props.additionalTrapElements\n    }));\n    return (_ctx, _cache) => {\n      return open.value ? (openBlock(), createBlock(unref(NcModal), mergeProps({\n        key: 0,\n        class: \"dialog__modal\",\n        disableSwipe: \"\"\n      }, modalProps.value, {\n        onClose: handleClosed,\n        \"onUpdate:show\": _cache[0] || (_cache[0] = ($event) => handleClosing())\n      }), {\n        default: withCtx(() => [\n          createElementVNode(\"h2\", {\n            id: unref(navigationId),\n            class: \"dialog__name\",\n            textContent: toDisplayString(_ctx.name)\n          }, null, 8, _hoisted_1),\n          (openBlock(), createBlock(resolveDynamicComponent(dialogTagName.value), mergeProps({\n            ref: \"dialogElement\",\n            class: [\"dialog\", _ctx.dialogClasses]\n          }, toHandlers(dialogListeners.value)), {\n            default: withCtx(() => [\n              createElementVNode(\"div\", {\n                ref: \"wrapper\",\n                class: normalizeClass([\"dialog__wrapper\", [{ \"dialog__wrapper--collapsed\": isNavigationCollapsed.value }]])\n              }, [\n                hasNavigation.value ? (openBlock(), createElementBlock(\"nav\", {\n                  key: 0,\n                  class: normalizeClass([\"dialog__navigation\", _ctx.navigationClasses]),\n                  \"aria-label\": navigationAriaLabelAttr.value,\n                  \"aria-labelledby\": navigationAriaLabelledbyAttr.value\n                }, [\n                  renderSlot(_ctx.$slots, \"navigation\", { isCollapsed: isNavigationCollapsed.value }, void 0, true)\n                ], 10, _hoisted_2)) : createCommentVNode(\"\", true),\n                createElementVNode(\"div\", {\n                  class: normalizeClass([\"dialog__content\", _ctx.contentClasses])\n                }, [\n                  renderSlot(_ctx.$slots, \"default\", {}, () => [\n                    createElementVNode(\"p\", _hoisted_3, toDisplayString(_ctx.message), 1)\n                  ], true)\n                ], 2)\n              ], 2),\n              createElementVNode(\"div\", _hoisted_4, [\n                renderSlot(_ctx.$slots, \"actions\", {}, () => [\n                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.buttons, (button, idx) => {\n                    return openBlock(), createBlock(unref(_sfc_main$1), mergeProps({ key: idx }, { ref_for: true }, button, {\n                      onClick: (_, result) => handleButtonClose(button, result)\n                    }), null, 16, [\"onClick\"]);\n                  }), 128))\n                ], true)\n              ])\n            ]),\n            _: 3\n          }, 16, [\"class\"]))\n        ]),\n        _: 3\n      }, 16)) : createCommentVNode(\"\", true);\n    };\n  }\n});\nconst NcDialog = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"__scopeId\", \"data-v-24e91b99\"]]);\nexport {\n  NcDialog as N\n};\n//# sourceMappingURL=NcDialog-BG9t4Psg.mjs.map\n","import { createApp } from \"vue\";\nfunction spawnDialog(dialog, props = {}, options = {}) {\n  let { container } = options;\n  if (\"container\" in props && typeof props.container === \"string\") {\n    container ??= props.container;\n  }\n  const resolvedContainer = typeof container === \"string\" && document.querySelector(container) || document.body;\n  const element = resolvedContainer.appendChild(document.createElement(\"div\"));\n  return new Promise((resolve, reject) => {\n    const app = createApp(dialog, {\n      ...props,\n      // If dialog has no `container` prop passing a falsy value does nothing\n      // Otherwise it is expected that `null` disables teleport and mounts dialog in place like NcDialog/NcModal\n      container: null,\n      onClose(...rest) {\n        const payload = rest.length > 1 ? rest : rest[0];\n        app.unmount();\n        element.remove();\n        resolve(payload);\n      },\n      \"onVue:unmounted\": () => {\n        app.unmount();\n        element.remove();\n        reject(new Error(\"Dialog was unmounted without close event\"));\n      }\n    });\n    app.mount(element);\n  });\n}\nexport {\n  spawnDialog\n};\n//# sourceMappingURL=index.mjs.map\n"],"names":["getFirstDay","intl","getCanonicalLocale","weekInfo","getDayNames","locale","getDayNamesMin","formatRelativeTime","timestamp","opts","options","getLanguage","date","formatter","seconds","minutes","hours","days","weeks","months","format","NC_ACTIONS_IS_SEMANTIC_MENU","NC_ACTIONS_CLOSE_MENU","getTrapStack","createTrapStackController","pausedStack","trap","useTrapStackControl","shouldPause","trapStackController","watch","toValue","onUnmounted","sides","alignments","placements","acc","side","min","max","round","floor","createCoords","v","oppositeSideMap","oppositeAlignmentMap","clamp","start","value","end","evaluate","param","getSide","placement","getAlignment","getOppositeAxis","axis","getAxisLength","yAxisSides","getSideAxis","getAlignmentAxis","getAlignmentSides","rects","rtl","alignment","alignmentAxis","length","mainAlignmentSide","getOppositePlacement","getExpandedPlacements","oppositePlacement","getOppositeAlignmentPlacement","lrPlacement","rlPlacement","tbPlacement","btPlacement","getSideList","isStart","getOppositeAxisPlacements","flipAlignment","direction","list","expandPaddingObject","padding","getPaddingObject","rectToClientRect","rect","x","y","width","height","computeCoordsFromPlacement","_ref","reference","floating","sideAxis","alignLength","isVertical","commonX","commonY","commonAlign","coords","detectOverflow","state","_await$platform$isEle","platform","elements","strategy","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","offsetParent","offsetScale","elementClientRect","computePosition","config","middleware","validMiddleware","statefulPlacement","middlewareData","resetCount","i","_platform$detectOverf","name","fn","nextX","nextY","data","reset","arrow","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","offset","shouldAddOffset","alignmentOffset","getPlacementList","autoAlignment","allowedPlacements","autoPlacement","_middlewareData$autoP","_middlewareData$autoP2","_placementsThatFitOnE","crossAxis","detectOverflowOptions","placements$1","overflow","currentIndex","currentPlacement","alignmentSides","currentOverflows","allOverflows","nextPlacement","placementsSortedByMostSpace","d","a","b","resetPlacement","flip","_middlewareData$arrow","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","initialSideAxis","isBasePlacement","fallbackPlacements","hasFallbackAxisSideDirection","overflows","overflowsData","_middlewareData$flip2","_overflowsData$filter","nextIndex","_overflowsData$filter2","currentSideAxis","originSides","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","_middlewareData$offse","diffCoords","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","limitShift","rawOffset","computedOffset","len","limitMin","limitMax","_middlewareData$offse2","isOriginSide","size","_state$middlewareData","_state$middlewareData2","apply","heightSide","widthSide","maximumClippingHeight","maximumClippingWidth","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","xMin","xMax","yMin","yMax","nextDimensions","n","t","e","o","r","l","c","s","h","f","u","p","g","m","w","L","E","R","T","C","F","W","D","S","A","H","O","P","B","Ze","re","$","_e","Te","pe","ae","de","G","le","he","Y","q","Q","xe","Ue","Ye","Xe","Ke","Je","Qe","ne","_","ue","fe","tt","Pe","ce","et","ot","it","J","ke","Le","st","nt","z","X","Fe","rt","Re","De","pt","Ie","at","M","Z","dt","lt","ht","ut","ft","ct","mt","je","Ve","se","ee","te","K","gt","wt","$e","N","I","j","V","Ee","ve","k","Se","Ht","kt","candidateSelectors","candidateSelector","NoElement","matches","getRootNode","_element$getRootNode","_isInert","node","lookUp","_node$getAttribute","inertAtt","inert","result","isContentEditable","_node$getAttribute2","attValue","getCandidates","el","includeContainer","filter","candidates","_getCandidatesIteratively","elementsToCheck","assigned","content","nestedCandidates","validCandidate","shadowRoot","validShadowRoot","_nestedCandidates","hasTabIndex","getTabIndex","getSortOrderTabIndex","isScope","tabIndex","sortOrderedTabbables","isInput","isHiddenInput","isDetailsWithSummary","child","getCheckedRadio","nodes","form","isTabbableRadio","radioScope","queryRadios","radioSet","err","checked","isRadio","isNonTabbableRadio","isNodeAttached","_nodeRoot","nodeRoot","nodeRootHost","attached","_nodeRootHost","_nodeRootHost$ownerDo","_node$ownerDocument","_nodeRoot2","_nodeRootHost2","_nodeRootHost2$ownerD","isZeroArea","_node$getBoundingClie","isHidden","displayCheck","getShadowRoot","visible","isDirectSummary","nodeUnderDetails","originalNode","parentElement","rootNode","isDisabledFromFieldset","parentNode","isNodeMatchingSelectorFocusable","isNodeMatchingSelectorTabbable","isShadowRootTabbable","shadowHostNode","_sortByOrder","regularTabbables","orderedTabbables","item","candidateTabindex","sortable","tabbable","container","focusable","isTabbable","focusableCandidateSelector","isFocusable","_arrayLikeToArray","_arrayWithoutHoles","asyncGeneratorStep","_asyncToGenerator","_next","_throw","_createForOfIteratorHelper","_unsupportedIterableToArray","_defineProperty","_toPropertyKey","_iterableToArray","_nonIterableSpread","ownKeys","_objectSpread2","_regenerator","Generator","_regeneratorDefine","GeneratorFunction","GeneratorFunctionPrototype","_toConsumableArray","_toPrimitive","activeFocusTraps","trapStack","activeTrap","trapIndex","isSelectableInput","isEscapeEvent","isTabEvent","isKeyForward","isKeyBackward","delay","valueOrHandler","_len","params","_key","getActualTarget","event","internalTrapStack","createFocusTrap","userOptions","doc","getOption","configOverrideOptions","optionName","configOptionName","findContainerIndex","composedPath","tabbableNodes","getNodeForOption","_ref2","_ref2$hasFallback","hasFallback","_ref2$params","optionValue","getInitialFocusNode","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","focusableNodes","lastTabbableNode","firstDomTabbableNode","lastDomTabbableNode","posTabIndexesFound","forward","nodeIdx","group","_getActiveElement","activeElement","_tryFocus","getReturnFocusNode","previousActiveElement","findNextNavNode","_ref3","target","_ref3$isBackward","isBackward","destinationNode","containerIndex","containerGroup","startOfGroupIndex","_ref4","destinationGroupIndex","destinationGroup","lastOfGroupIndex","_ref5","_destinationGroupIndex","_destinationGroup","checkPointerDown","checkFocusIn","targetContained","nextNode","navAcrossContainers","mruContainerIdx","mruTabIdx","checkKeyNav","checkTabKey","checkEscapeKey","checkClick","addListeners","promise","resolve","collectAdjacentElements","containers","containerAncestors","adjacentElements","_iterator","_step","insideShadowRoot","current","parent","siblings","_iterator2","_step2","removeListeners","checkDomRemoval","mutations","isFocusedNodeRemoved","mutation","removedNodes","mutationObserver","updateObservedNodes","activateOptions","onActivate","onPostActivate","checkCanFocusTrap","preexistingTrap","revertState","_preexistingTrap$_set","finishActivation","_ref6","_callee","_context","error","_preexistingTrap$_set2","deactivateOptions","onDeactivate","onPostDeactivate","checkCanReturnFocus","returnFocus","finishDeactivation","pauseOptions","unpauseOptions","containerElements","elementsAsArray","paused","onPause","onPostPause","onUnpause","onPostUnpause","finishUnpause","_ref7","_callee2","_context2","isEnabled","_el$getAttribute","isRtl","isRTL","_sfc_main$1","defineComponent","ncPopover","style0","theme","_sfc_main","Dropdown","triggerElements","options2","logger","_sfc_render","_ctx","_cache","$props","$setup","$data","$options","_component_NcPopoverTriggerProvider","resolveComponent","_component_Dropdown","openBlock","createBlock","$event","withCtx","slotProps","renderSlot","normalizeProps","guardReactiveProps","createVNode","cssModules","NcPopover","_export_sfc","_hoisted_1","_hoisted_2","_hoisted_3","_hoisted_4","createElementBlock","mergeProps","createElementVNode","toDisplayString","createCommentVNode","IconDotsHorizontal","register","t4","isSlotPopulated","vnodes","vnode","Comment","Fragment","Text","focusableSelector","NcButton","computed","createElementId","action","url","focusList","focusIndex","newFocusIndex","currentActiveElement","focusElement","liMenuParent","indexLength","firstCheckedIndex","button","actions","findActions","actions2","validInlineActions","inlineActions","menuActions","menuItemsActions","textInputActions","linkActions","hasTextInputAction","hasMenuItemAction","hasLinkAction","renderInlineAction","iconProp","icon","text","buttonText","title","propsToForward","type","renderActionsPopover","triggerIcon","triggerRandomId","NcActions","tryOnScopeDispose","failSilently","getCurrentScope","onScopeDispose","localProvidedStateMap","injectLocal","args","_getCurrentInstance","key","instance","getCurrentInstance","owner","hasInjectionContext","inject","isClient","notNullish","val","toString","isObject","noop","createFilterWrapper","wrapper","reject","bypassFilter","invoke$1","debounceFilter","ms","timer","maxTimer","lastRejector","_clearTimeout","timer$1","lastInvoker","duration","maxDuration","pxValue","px","toArray","getLifeCycleTarget","createSharedComposable","composable","subscribers","scope","dispose","effectScope","useDebounceFn","watchWithFilter","source","cb","eventFilter","watchOptions","tryOnMounted","sync","onMounted","nextTick","useIntervalFn","interval","immediate","immediateCallback","isActive","shallowRef","clean","pause","resume","intervalValue","isRef","shallowReadonly","watchDebounced","debounce","maxWait","watchImmediate","defaultWindow","defaultDocument","unrefElement","elRef","_$el","plain","useEventListener","listener","firstParamTargets","test","_firstParamTargets$va","_firstParamTargets$va2","unref","raw_targets","raw_events","raw_listeners","raw_options","onCleanup","optionsClone","cleanups","useMounted","isMounted","useSupported","callback","useMutationObserver","window$1","mutationOptions","observer","isSupported","cleanup","stopWatch","items","newTargets","takeRecords","stop","onElementRemoval","document$1","flush","stopFn","cleanupAndUpdate","watchEffect","mutationsList","stopHandle","createKeyPredicate","keyFilter","onKeyStroke","handler","eventName","passive","dedupe","predicate","useActiveElement","_options$document","deep","triggerOnRemoval","getDeepActiveElement","_element$shadowRoot","trigger","listenerOptions","ssrWidthSymbol","useSSRWidth","ssrWidth","useMediaQuery","query","ssrSupport","mediaQuery","queryString","not","minWidth","maxWidth","res","usePreferredDark","useResizeObserver","observerOptions","_targets","els","_el","useElementSize","initialSize","box","isSVG","_unrefElement","stop1","entry","boxSize","$elem","formatBoxSize","inlineSize","blockSize","ele","stop2","useIntersectionObserver","root","rootMargin","threshold","targets","targets$1","root$1","rootMargin$1","EVENT_FOCUS_IN","EVENT_FOCUS_OUT","PSEUDO_CLASS_FOCUS_WITHIN","useFocusWithin","targetElement","_focused","focused","_targetElement$value$","_targetElement$value","_targetElement$value$2","useSwipe","onSwipe","onSwipeEnd","onSwipeStart","coordsStart","reactive","coordsEnd","diffX","diffY","abs","isThresholdExceeded","isSwiping","getTouchEventCoords","updateCoordsStart","updateCoordsEnd","onTouchEnd","stops","MOBILE_BREAKPOINT","MOBILE_SMALL_BREAKPOINT","isLessThanBreakpoint","breakpoint","isMobile","ref","isSmallMobile","useIsMobile","readonly","t33","__props","__emit","props","emit","isLoading","handleClick","fallback","NcLoadingIcon","NcIconSvgWrapper","createTextVNode","t2","FEW_SECONDS_AGO","useFormatRelativeTime","timeoutId","language","relativeTime2","ignoreSeconds","relativeTime","updateRelativeTime","diff","useFormatTime","isMac","disableKeyboardShortcuts","derivedKeysRegex","nonAsciiPrintableRegex","shouldIgnoreEvent","eventHandler","useHotKey","keysOrFilter","validateKeyEvent","isKeyInLowerCase","isEventKeyInLowerCase","stopKeyDown","stopKeyUp","checkIfDarkTheme","backgroundInvertIfDark","isFullscreen","checkIfIsFullscreen","getSameNodeParent","getSameNodeAncestors","ancestors","useScopeIdAttrs","scopeIds","instance2","scopeId","t19","t36","_hoisted_5","_hoisted_6","_hoisted_7","mergeModels","useCssVars","cssSlideshowDelay","showModal","useModel","scopeIdAttrs","modalId","maskElement","useTemplateRef","focusTrap","useFocusTrap","clearFocusTrap","isPlaying","stopSlideshow","startSlideshow","nextSlide","toRef","animationKey","runSlideshow","stopSwipe","handleSwipe","close","previousSlide","restartSlideshow","handleClickModalWrapper","Teleport","Transition","withDirectives","normalizeClass","mdiPause","mdiPlay","mdiClose","withModifiers","mdiChevronLeft","vShow","mdiChevronRight","NcModal","open","slots","useSlots","wrapperElement","dialogWidth","isNavigationCollapsed","hasNavigation","navigationId","navigationAriaLabelAttr","navigationAriaLabelledbyAttr","dialogRootElement","dialogTagName","dialogListeners","handleButtonClose","handleClosing","handleClosed","modalProps","resolveDynamicComponent","toHandlers","renderList","idx","NcDialog","spawnDialog","dialog","app","createApp","rest","payload"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]}